[{"categories":["python","数学建模"],"content":"新型冠状病毒（COVID-19/2019-nCoV）疫情分析 源文档详见：博客相关资源-新冠疫情数据分析文件 ","date":"2021-07-15","objectID":"/38/:0:0","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"重要说明 分析文档：完成度：代码质量 3:5:2 其中分析文档是指你数据分析的过程中，对各问题分析的思路、对结果的解释、说明(要求言简意赅，不要为写而写) ps:你自己写的代码胜过一切的代笔，无关美丑，只问今日比昨日更长进！加油！ 由于数据过多，查看数据尽量使用head()或tail()，以免程序长时间无响应 ======================= 本项目数据来源于丁香园。本项目主要目的是通过对疫情历史数据的分析研究，以更好的了解疫情与疫情的发展态势，为抗击疫情之决策提供数据支持。 关于本章使用的数据集，欢迎点击——\u003e我的B站视频 在评论区获取。 ","date":"2021-07-15","objectID":"/38/:1:0","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"一. 提出问题 从全国范围，你所在省市，国外疫情等三个方面主要研究以下几个问题： （一）全国累计确诊/疑似/治愈/死亡情况随时间变化趋势如何？ （二）全国新增确诊/疑似/治愈/死亡情况随时间变化趋势如何？ （三）全国新增境外输入随时间变化趋势如何？ （四）你所在的省市情况如何？ （五）国外疫情态势如何？ （六）结合你的分析结果，对个人和社会在抗击疫情方面有何建议？ ","date":"2021-07-15","objectID":"/38/:2:0","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"二. 理解数据 原始数据集：AreaInfo.csv，导入相关包及读取数据： r_hex = '#dc2624' # red, RGB = 220,38,36 dt_hex = '#2b4750' # dark teal, RGB = 43,71,80 tl_hex = '#45a0a2' # teal, RGB = 69,160,162 r1_hex = '#e87a59' # red, RGB = 232,122,89 tl1_hex = '#7dcaa9' # teal, RGB = 125,202,169 g_hex = '#649E7D' # green, RGB = 100,158,125 o_hex = '#dc8018' # orange, RGB = 220,128,24 tn_hex = '#C89F91' # tan, RGB = 200,159,145 g50_hex = '#6c6d6c' # grey-50, RGB = 108,109,108 bg_hex = '#4f6268' # blue grey, RGB = 79,98,104 g25_hex = '#c7cccf' # grey-25, RGB = 199,204,207 import numpy as np import pandas as pd import matplotlib,re import matplotlib.pyplot as plt from matplotlib.pyplot import MultipleLocator data = pd.read_csv(r'data/AreaInfo.csv') 查看与统计数据，以对数据有一个大致了解 data.head() \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rcontinentName\rcontinentEnglishName\rcountryName\rcountryEnglishName\rprovinceName\rprovinceEnglishName\rprovince_zipCode\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\rupdateTime\rcityName\rcityEnglishName\rcity_zipCode\rcity_confirmedCount\rcity_suspectedCount\rcity_curedCount\rcity_deadCount\r\r\r\r\r0\r北美洲\rNorth America\r美国\rUnited States of America\r美国\rUnited States of America\r971002\r2306247\r0.0\r640198\r120351\r2020-06-23 10:01:45\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r1\r南美洲\rSouth America\r巴西\rBrazil\r巴西\rBrazil\r973003\r1106470\r0.0\r549386\r51271\r2020-06-23 10:01:45\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r2\r欧洲\rEurope\r英国\rUnited Kingdom\r英国\rUnited Kingdom\r961007\r305289\r0.0\r539\r42647\r2020-06-23 10:01:45\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r3\r欧洲\rEurope\r俄罗斯\rRussia\r俄罗斯\rRussia\r964006\r592280\r0.0\r344416\r8206\r2020-06-23 10:01:45\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r4\r南美洲\rSouth America\r智利\rChile\r智利\rChile\r973004\r246963\r0.0\r44946\r4502\r2020-06-23 10:01:45\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r\r\r","date":"2021-07-15","objectID":"/38/:3:0","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"三. 数据清洗 ","date":"2021-07-15","objectID":"/38/:4:0","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"（一）基本数据处理 数据清洗主要包括：选取子集，缺失数据处理、数据格式转换、异常值数据处理等。 国内疫情数据选取（最终选取的数据命名为china） 选取国内疫情数据 对于更新时间(updateTime)列，需将其转换为日期类型并提取出年-月-日，并查看处理结果。(提示：dt.date) 因数据每天按小时更新，一天之内有很多重复数据，请去重并只保留一天之内最新的数据。 提示：df.drop_duplicates(subset=[‘provinceName’, ‘updateTime’], keep=‘first’, inplace=False) 其中df是你选择的国内疫情数据的DataFrame 分析：选取countryName一列中值为中国的行组成CHINA。 CHINA = data.loc[data['countryName'] == '中国'] CHINA.dropna(subset=['cityName'], how='any', inplace=True) #CHINA D:\\Anaconda\\envs\\python32\\lib\\site-packages\\ipykernel_launcher.py:2: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame\rSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\r 分析：取出含所有中国城市的列表 cities = list(set(CHINA['cityName'])) 分析：遍历取出每一个城市的子dataframe，然后用sort对updateTime进行时间排序 for city in cities: CHINA.loc[data['cityName'] == city].sort_values(by = 'updateTime') 分析：去除空值所在行 CHINA.dropna(subset=['cityName'],inplace=True) #CHINA.loc[CHINA['cityName'] == '秦皇岛'].tail(20) D:\\Anaconda\\envs\\python32\\lib\\site-packages\\ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame\rSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\r\"\"\"Entry point for launching an IPython kernel.\r 分析：将CHINA中的updateTime列进行格式化处理 CHINA.updateTime = pd.to_datetime(CHINA.updateTime,format=\"%Y-%m-%d\",errors='coerce').dt.date #CHINA.loc[data['cityName'] == '秦皇岛'].tail(15) D:\\Anaconda\\envs\\python32\\lib\\site-packages\\pandas\\core\\generic.py:5303: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame.\rTry using .loc[row_indexer,col_indexer] = value instead\rSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\rself[name] = value\r CHINA.head() \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rcontinentName\rcontinentEnglishName\rcountryName\rcountryEnglishName\rprovinceName\rprovinceEnglishName\rprovince_zipCode\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\rupdateTime\rcityName\rcityEnglishName\rcity_zipCode\rcity_confirmedCount\rcity_suspectedCount\rcity_curedCount\rcity_deadCount\r\r\r\r\r136\r亚洲\rAsia\r中国\rChina\r陕西省\rShaanxi\r610000\r317\r1.0\r307\r3\r2020-06-23\r境外输入\rNaN\r0.0\r72.0\r0.0\r65.0\r0.0\r\r\r137\r亚洲\rAsia\r中国\rChina\r陕西省\rShaanxi\r610000\r317\r1.0\r307\r3\r2020-06-23\r西安\rXi'an\r610100.0\r120.0\r0.0\r117.0\r3.0\r\r\r138\r亚洲\rAsia\r中国\rChina\r陕西省\rShaanxi\r610000\r317\r1.0\r307\r3\r2020-06-23\r安康\rAnkang\r610900.0\r26.0\r0.0\r26.0\r0.0\r\r\r139\r亚洲\rAsia\r中国\rChina\r陕西省\rShaanxi\r610000\r317\r1.0\r307\r3\r2020-06-23\r汉中\rHanzhong\r610700.0\r26.0\r0.0\r26.0\r0.0\r\r\r140\r亚洲\rAsia\r中国\rChina\r陕西省\rShaanxi\r610000\r317\r1.0\r307\r3\r2020-06-23\r咸阳\rXianyang\r610400.0\r17.0\r0.0\r17.0\r0.0\r\r\r\r\r分析：每日数据的去重只保留第一个数据，因为前面已经对时间进行排序，第一个数据即为当天最新数据 分析：考虑到合并dataframe需要用到concat，需要创建一个初始china real = CHINA.loc[data['cityName'] == cities[1]] real.drop_duplicates(subset='updateTime', keep='first', inplace=True) china = real D:\\Anaconda\\envs\\python32\\lib\\site-packages\\ipykernel_launcher.py:2: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame\rSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\r 分析：遍历每个城市dataframe进行每日数据的去重，否则会出现相同日期只保留一个城市的数据的情况 for city in cities[2:]: real_data = CHINA.loc[data['cityName'] == city] real_data.drop_duplicates(subset='updateTime', keep='first', inplace=True) china = pd.concat([real_data, china],sort=False) D:\\Anaconda\\envs\\python32\\lib\\site-packages\\ipykernel_launcher.py:3: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame\rSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returnin","date":"2021-07-15","objectID":"/38/:4:1","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"四. 数据分析及可视化 在进行数据分析及可视化时，依据每个问题选取所需变量并新建DataFrame再进行分析和可视化展示，这样数据不易乱且条理更清晰。 ","date":"2021-07-15","objectID":"/38/:5:0","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"基础分析 基础分析，只允许使用numpy、pandas和matplotlib库。 可以在一张图上多个坐标系展示也可以在多张图上展示 请根据分析目的选择图形的类型(折线图、饼图、直方图和散点图等等)，实在没有主意可以到百度疫情地图或其他疫情分析的站点激发激发灵感。 （一）全国累计确诊/疑似/治愈/死亡情况随时间变化趋势如何？ 分析：要获得全国累计情况随时间变化趋势，首先需要整合每日全国累计确诊情况做成date_confirmed 分析：要整合每日全国累计确诊情况，首先得提取每个省份每日当天最新累计确诊人数，省份数据求和后形成dataframe， for循环拼接到date_confirmed中 date = list(set(china['updateTime'])) date.sort() date [datetime.date(2020, 1, 24), datetime.date(2020, 1, 25), datetime.date(2020, 1, 26), datetime.date(2020, 1, 27), datetime.date(2020, 1, 28), datetime.date(2020, 1, 29), datetime.date(2020, 1, 30), datetime.date(2020, 1, 31), datetime.date(2020, 2, 1), datetime.date(2020, 2, 2), datetime.date(2020, 2, 3), datetime.date(2020, 2, 4), datetime.date(2020, 2, 5), datetime.date(2020, 2, 6), datetime.date(2020, 2, 7), datetime.date(2020, 2, 8), datetime.date(2020, 2, 9), datetime.date(2020, 2, 10), datetime.date(2020, 2, 11), datetime.date(2020, 2, 12), datetime.date(2020, 2, 13), datetime.date(2020, 2, 14), datetime.date(2020, 2, 15), datetime.date(2020, 2, 16), datetime.date(2020, 2, 17), datetime.date(2020, 2, 18), datetime.date(2020, 2, 19), datetime.date(2020, 2, 20), datetime.date(2020, 2, 21), datetime.date(2020, 2, 22), datetime.date(2020, 2, 23), datetime.date(2020, 2, 24), datetime.date(2020, 2, 25), datetime.date(2020, 2, 26), datetime.date(2020, 2, 27), datetime.date(2020, 2, 28), datetime.date(2020, 2, 29), datetime.date(2020, 3, 1), datetime.date(2020, 3, 2), datetime.date(2020, 3, 3), datetime.date(2020, 3, 4), datetime.date(2020, 3, 5), datetime.date(2020, 3, 6), datetime.date(2020, 3, 7), datetime.date(2020, 3, 8), datetime.date(2020, 3, 9), datetime.date(2020, 3, 10), datetime.date(2020, 3, 11), datetime.date(2020, 3, 12), datetime.date(2020, 3, 13), datetime.date(2020, 3, 14), datetime.date(2020, 3, 15), datetime.date(2020, 3, 16), datetime.date(2020, 3, 17), datetime.date(2020, 3, 18), datetime.date(2020, 3, 19), datetime.date(2020, 3, 20), datetime.date(2020, 3, 21), datetime.date(2020, 3, 22), datetime.date(2020, 3, 23), datetime.date(2020, 3, 24), datetime.date(2020, 3, 25), datetime.date(2020, 3, 26), datetime.date(2020, 3, 27), datetime.date(2020, 3, 28), datetime.date(2020, 3, 29), datetime.date(2020, 3, 30), datetime.date(2020, 3, 31), datetime.date(2020, 4, 1), datetime.date(2020, 4, 2), datetime.date(2020, 4, 3), datetime.date(2020, 4, 4), datetime.date(2020, 4, 5), datetime.date(2020, 4, 6), datetime.date(2020, 4, 7), datetime.date(2020, 4, 8), datetime.date(2020, 4, 9), datetime.date(2020, 4, 10), datetime.date(2020, 4, 11), datetime.date(2020, 4, 12), datetime.date(2020, 4, 13), datetime.date(2020, 4, 14), datetime.date(2020, 4, 15), datetime.date(2020, 4, 16), datetime.date(2020, 4, 17), datetime.date(2020, 4, 18), datetime.date(2020, 4, 19), datetime.date(2020, 4, 20), datetime.date(2020, 4, 21), datetime.date(2020, 4, 22), datetime.date(2020, 4, 23), datetime.date(2020, 4, 24), datetime.date(2020, 4, 25), datetime.date(2020, 4, 26), datetime.date(2020, 4, 27), datetime.date(2020, 4, 28), datetime.date(2020, 4, 29), datetime.date(2020, 4, 30), datetime.date(2020, 5, 1), datetime.date(2020, 5, 2), datetime.date(2020, 5, 3), datetime.date(2020, 5, 4), datetime.date(2020, 5, 5), datetime.date(2020, 5, 6), datetime.date(2020, 5, 7), datetime.date(2020, 5, 8), datetime.date(2020, 5, 9), datetime.date(2020, 5, 10), datetime.date(2020, 5, 11), datetime.date(2020, 5, 12), datetime.date(2020, 5, 13), datetime.date(2020, 5, 14), datetime.date(2020, 5, 15), datetime.date(2020, 5, 16), datetime.date(2020, 5, 17), datetime.date(2020, 5, 18), datetime.date(2020, 5, 19), datetime.date(2020, 5, 20), datetime.date(2020, 5, 21), datetime.date(2020, 5, 22), datetime.date(2020, 5, 23), datetime.date(2020, 5, 24), datetime.date(2020, 5, 25), datetime.date(2020, 5, 26), datetime.date(2020, 5, 27), datetime.date(2020, 5, 28), datetime.date(2020, 5, 29), datetime.date(2020, 5, 30), datetime.date(2020, 5, 31), datetime.date(2020, 6, 1), datetime.date(2020, 6, 2), datetime.date(2","date":"2021-07-15","objectID":"/38/:5:1","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"附加分析(选做) 附加分析，所使用的库不限，比如可以使用seaborn、pyecharts等库。 限于个人能力，没有做。 ","date":"2021-07-15","objectID":"/38/:5:2","tags":["数学建模","python"],"title":"2020新型冠状病毒（COVID-19/2019-nCoV）疫情分析(补档)","uri":"/38/"},{"categories":["python","数学建模"],"content":"前言 帮舍友整的，不知道具体实际意义。 ","date":"2021-07-14","objectID":"/39/:1:0","tags":["数学建模","python"],"title":"某区域流体数据处理(只会写操作，不知道具体意义)","uri":"/39/"},{"categories":["python","数学建模"],"content":"代码 import numpy as np import pandas as pd data = pd.read_excel(r'C:\\Users\\祈LHL\\Desktop\\data.xlsx') data.head() \r.dataframe tbody tr th:only-of-type { ,\rvertical-align: middle; ,\r} ,\r,\r.dataframe tbody tr th {\rvertical-align: top;\r}\r,\r.dataframe thead th {\rtext-align: right;\r} ,\r\r\r\rcellnumber\rx-coordinate y-coordinate\rz-coordinate density z-velocity relative-z-velocity x-coordinate.1 y-coordinate z-face-area boundary-cell-dist boundary-normal-dist 0 1 -12.597898 -2.404495 -6.320497 1.226 -22.205814 -22.205814 -12.597899 -2.404528 -0.006824 1 0.010276 1 2 -12.597898 -2.321485 -6.320487 1.226 -23.532957 -23.532957 -12.597899 -2.321584 -0.006824 1 0.020553 2 3 -12.515688 -2.404495 -6.320500 1.226 -23.167622 -23.167622 -12.515688 -2.404528 -0.006824 1 0.020636 3 4 -12.515688 -2.321485 -6.320500 1.226 -24.882029 -24.882029 -12.515688 -2.321584 -0.006824 1 0.051111 4 5 -12.433477 -2.404495 -6.320500 1.226 -23.488083 -23.488083 -12.433478 -2.404528 -0.006824 1 0.020719 \r y = data.sort_values(by=\"y-coordinate\" , ascending=False) step = 4.892/6 i = 0 y_list = [] section = [] #y6 x3 #分y while i \u003c 6: step_y = float(\"%.8f\"%(i*step)) a_y = step_y-2.446 y_min = y.loc[y['y-coordinate'] \u003e= a_y] i +=1 step_y = float(\"%.8f\"%(i*step)) b_y = step_y-2.446 y_max = y_min.loc[y_min['y-coordinate'] \u003c b_y] y_list.append(y_max) section_y = (a_y,b_y) section.append(section_y) #section[5] j = 0 step = 1.562/3 x_list = [] section_x_list = [] section_y_list = [] #在y中分x while j \u003c= 5: temp = y_list[j] m = 0 while m \u003c= 2: step_x = float(\"%.8f\"%(m*step)) a_x = step_x-12.639 x_min = temp.loc[temp['x-coordinate'] \u003e= a_x] m +=1 step_x = float(\"%.8f\"%(m*step)) b_x = step_x-12.639 x_max = x_min.loc[temp['x-coordinate'] \u003c b_x] x_list.append(x_max) section_x = (a_x,b_x) section_x_list.append(section_x) section_y_list.append(section[j]) j += 1 #18个块 section_list = [] Q_list = [] i = 0 while i \u003c= 17: temp_l = x_list[i] Q = (temp_l[\"density\"]*temp_l[\"z-velocity\"]*temp_l[\"z-face-area\"]).sum() i +=1 Q_list.append(Q) section_x_list [(-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077), (-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077), (-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077), (-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077), (-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077), (-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077)] section_y_list [(-2.446, -1.63066667), (-2.446, -1.63066667), (-2.446, -1.63066667), (-1.63066667, -0.8153333300000001), (-1.63066667, -0.8153333300000001), (-1.63066667, -0.8153333300000001), (-0.8153333300000001, 0.0), (-0.8153333300000001, 0.0), (-0.8153333300000001, 0.0), (0.0, 0.8153333299999996), (0.0, 0.8153333299999996), (0.0, 0.8153333299999996), (0.8153333299999996, 1.6306666699999997), (0.8153333299999996, 1.6306666699999997), (0.8153333299999996, 1.6306666699999997), (1.6306666699999997, 2.446), (1.6306666699999997, 2.446), (1.6306666699999997, 2.446)] index = [] i = 0 while i \u003c= 2: index.append(section_x_list[i]) i+=1 index [(-12.639, -12.118333329999999), (-12.118333329999999, -11.597666669999999), (-11.597666669999999, -11.077)] cols = [] i = 0 while i \u003c= 17: cols.append(section_y_list[i]) i+=3 cols [(-2.446, -1.63066667), (-1.63066667, -0.8153333300000001), (-0.8153333300000001, 0.0), (0.0, 0.8153333299999996), (0.8153333299999996, 1.6306666699999997), (1.6306666699999997, 2.446)] j = 0 data = {} while j \u003c=5: col = cols[j] data[col]= 1 j += 1 data {(-2.446, -1.63066667): 1, (-1.63066667, -0.8153333300000001): 1, (-0.8153333300000001, 0.0): 1, (0.0, 0.8153333299999996): 1, (0.8153333299999996, 1.6306666699999997): 1, (1.6306666699999997, 2.446): 1} temp_list = Q_list.copy() r = 0 l = 0 for i in d","date":"2021-07-14","objectID":"/39/:2:0","tags":["数学建模","python"],"title":"某区域流体数据处理(只会写操作，不知道具体意义)","uri":"/39/"},{"categories":["数学建模"],"content":"前言 感谢组员书写书面报告，代码部分由我书写，我写的很烂，将就看吧。 ","date":"2021-07-13","objectID":"/37/:1:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"第一届长三角数学建模 ","date":"2021-07-13","objectID":"/37/:2:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"B题 锅炉水冷壁温度曲线 ","date":"2021-07-13","objectID":"/37/:3:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"1Stopt多元拟合 个人体会： 只能确定2个自变量1个因变量的拟合函数形式，更高维的无法寻找公式进行拟合。 优点是优化算法基本包含，可以拿来做模型优化（简单的函数形式）。 多于2个自变量的拟合可以使用逐步线性回归法（matlab内置工具箱），缺点是拟合项数会很多，难以写出函数形式。 ps：相关资源在右上角博客资源页面 ","date":"2021-07-13","objectID":"/37/:4:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"逐步线性回归 clc clear all X1=xlsread('附件1.xlsx');%因变量 data1=X1(3172:end,11); X2=xlsread('附件2.xlsx');%自变量 data2=X2(3172:end,2:50); %1 2 3 4 6 12 13 31 34 37 38 39 %temp=[data2,data2.^2,data2.^3,log10(data2)]; %stepwise(temp,data1);%0.6990 %temp1=data2; temp1=[data2(:,1),data2(:,2),data2(:,3),data2(:,4),data2(:,6),data2(:,12),data2(:,13),data2(:,31),data2(:,34),data2(:,37),data2(:,38),data2(:,39)]; temp2=[temp1,temp1.^2,temp1.^3,temp1.^4,temp1.^5,log10(temp1),1./temp1]; %stepwise(temp2,data1);%0.6990 stepwise(temp2,data1); %12列拟合相关度54% %stats beta %temp3=[x1,x2,x3,x4,x6,x12,x13,x31,x34,x37,x38,x39]; 重点是这个： stepwise(自变量函数项,因变量); ","date":"2021-07-13","objectID":"/37/:5:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"皮尔逊相关系数 clc clear all X1=xlsread('附件1.xlsx'); data1=X1(:,11); X2=xlsread('附件2.xlsx'); data2=X2(:,44:end); data=[data1,data2]; %data=zscore(data);%对变量标准化 temp=corrcoef(data);%生成皮尔森相关性系数计算公式 pershen=temp(1,2:end);%求附件一管道十对附件二111个操作变量的皮尔森相关性系数 pershen=abs(pershen); %将皮尔森相关性系数求取绝对值 csvwrite('wenti4.csv',pershen); 类似照着写10个管道的 clc clear all X1=xlsread('附件1.xlsx'); data1=X1(:,2:11); X2=xlsread('附件2.xlsx'); data2=X2(:,2:end); data=[data1,data2]; %data=zscore(data);%对变量进行标准化 temp=corrcoef(data);% 生成皮尔森相关性系数计算公式 pershen=temp(1:10,11:end);%求附件一十个管道对附件二111个操作变量和53个状态变量的皮尔森相关性系数 pershen=abs(pershen);%将皮尔森相关性系数求取绝对值 csvwrite('wenti3.csv',pershen); %经过Excel筛选皮尔森相关性系数最大列数分别为119 112 114 5 115 121 91 92 1 73 result=[data2(:,119),data2(:,112)]; csvwrite('data10.csv',result); 拟合函数图像代码： clc; clear subplot(5,2,1) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data1.csv'); x=M(:,1); y=M(:,2); p1=-366.623574952674; p2=-6309.81591583794; p3=-57878.3062818374; p4=15903.1406517026; p5=-53.4927163299915; p6=0.0889609164030065; p7=542.236136002024; p8=-218.986158913513; p9=17.338434284516; z=(p1+p2.*log(x)+p3.*(log(x)).^2+p4*y+p5*y.^2+p6*y.^3)./(1+p7*log(x)+p8*(log(x)).^2+p9.*y); plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道一温度曲线') subplot(5,2,2) x1=(1:1:5000); M=xlsread('C:\\Users\\86152\\Desktop\\data\\data2.xlsx'); x=M(:,1); y=M(:,2); p1=-760228.816854935; p2=9.40803736929389; p3=-0.0110468670816608; p4=2.36049470120192E-7; p5=10924.026332869; p6=-58.9224433132279; p7=0.141102010823114; p8=-0.000126582641617285; z=p1+p2.*x+p3.*x.^2+p4.*x.^3+p5.*y+p6.*y.^2+p7.*y.^3+p8.*y.^4; plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道二温度曲线') subplot(5,2,3) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data3.csv'); x=M(:,1); y=M(:,2); p1=-278364.765528611; p2=-8053.13293300719; p3=702.700979973376; p4=4525.26042721373; p5=-25.4017726090204; p6=0.063270352619814; p7=-5.9005816668393E-5; z=p1+p2.*log(x)+p3.*(log(x)).^2+p4.*y+p5.*y.^2+p6.*y.^3+p7.*y.^4; plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道三温度曲线') subplot(5,2,4) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data4.csv'); x=M(:,1); y=M(:,2); p1=-72.9520473758939; p2=-556.535840804353; p3=-6289.99299391888; p4=38088.2044118192; p5=-187.688895088328; p6=-0.314791034083831; p7=-36.6632213229309; p8=-7693.38639121209; p9=65.3375954195133; p10=135.981090347525; p11=4418.78480395924; z=(p1+p3.*x+p5.*log(y)+p7*x.^2+p9.*(log(y)).^2+p11.*x.*log(y))./(1+p2.*x+p4.*log(y)+p6.*x.^2+p8.*(log(y)).^2+p10.*x.*log(y)); plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道四温度曲线') subplot(5,2,5) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data5.csv'); x=M(:,1); y=M(:,2); p1=6636.72503715224; p2=826099.455060947; p3=-498.995296492192; p4=1.80238545972406; p5=-1143812.65641828; p6=3030.85414746531; p7=-4932.54637234801; p8=3.5943846329167; z=(p1+p2.*x+p3.*x.^2+p4.*x.^3+p5.*y)./(1+p6.*x+p7.*y+p8.*y.^2); plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道五温度曲线') subplot(5,2,6) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data6.csv'); x=M(:,1); y=M(:,2); p1=-5883.284880402; p2=60.424921963928; p3=-0.164225401010505; p4=0.000149967919524129; p5=61332.3184515964; p6=79523.3753333665; p7=-54368.4125968335; p8=10405.5019030654; p9=-639.850116036068; z=p1+p2.*x+p3.*x.^2+p4.*x.^3+p5.*log(y)+p6.*(log(y)).^2+p7.*(log(y)).^3+p8.*(log(y)).^4+p9.*(log(y)).^5; plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道六温度曲线') subplot(5,2,7) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data7.csv'); x=M(:,1); y=M(:,2); p1=201478.39441699; p2=372414.059548135; p3=-147089.218042618; p4=12485.7289898091; p5=-224.561025015429; p6=3.32272031088369; p7=-173.088899267814; p8=4.01866601526878; z = (p1+p2.*log(x)+p3.*(log(x)).^2+p4.*(log(x)).^3+p5.*y+p6.*y.^2)./(1+p7.*log(x)+p8.*y); plot(x1,z); xlabel('采样点'); ylabel('温度'); title('管道七温度曲线') subplot(5,2,8) x1=(1:1:5000); M=csvread('C:\\Users\\86152\\Desktop\\data\\data8.csv'); x=M(:,1); y=M(:,2); p1=682051.099193563; p2=-166.30866016075; p3=0.443241999640146; p4=-0.0003925","date":"2021-07-13","objectID":"/37/:6:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"熵值法 function y=guiyi(x,type,ymin,ymax) %实现正向或负向指标归一化，返回归一化后的数据矩阵 %x为原始数据矩阵, 一行代表一个样本, 每列对应一个指标 %type设定正向指标1,负向指标2 %ymin,ymax为归一化的区间端点 [n,m]=size(x); y=zeros(n,m); xmin=min(x); xmax=max(x); switch type case 1 for j=1:m y(:,j)=(ymax-ymin)*(x(:,j)-xmin(j))/(xmax(j)-xmin(j))+ymin; end case 2 for j=1:m y(:,j)=(ymax-ymin)*(xmax(j)-x(:,j))/(xmax(j)-xmin(j))+ymin; end end clc clear all X=xlsread('附件1.xlsx'); data=X(:,2:end); [max_data,index1]=max(data); [min_data,index]=min(data); fangcha=var(data); [max_data,index1]=max(data); D=[fangcha;max_data]'; temp=[2 2]; [pj w]=shang(D,temp); pj%pj 评价分 w%w 权重 function [s,w]=shang(x,ind) %实现用熵值法求各指标(列）的权重及各数据行的得分 %x为原始数据矩阵, 一行代表一个样本, 每列对应一个指标 %ind指示向量，指示各列正向指标还是负向指标，1表示正向指标，2表示负向指标 %s返回各行（样本）得分，w返回各列权重 [n,m]=size(x); % n个样本, m个指标 %%数据的归一化处理 for i=1:m if ind(i)==1 %正向指标归一化 X(:,i)=guiyi(x(:,i),1,0.002,0.996); %若归一化到[0,1], 0会出问题 else %负向指标归一化 X(:,i)=guiyi(x(:,i),2,0.002,0.996); end end %%计算第j个指标下，第i个样本占该指标的比重p(i,j) for i=1:n for j=1:m p(i,j)=X(i,j)/sum(X(:,j)); end end %%计算第j个指标的熵值e(j) k=1/log(n); for j=1:m e(j)=-k*sum(p(:,j).*log(p(:,j))); end d=ones(1,m)-e; %计算信息熵冗余度 w=d./sum(d); %求权值w s=100*w*X'; %求综合得分 ","date":"2021-07-13","objectID":"/37/:7:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"第一问代码 抄的某公众号 Y=xlsread('C:\\Users\\86152\\Desktop\\附件1.xlsx'); X=Y(:,[2:11]); x1=mean(X,1) %求十个管道温度平均值 [max_X,index]=max(X) %求十个管道温度最大值 [min_X,index]=min(X) %求十个管道温度最小值 DX=var(X) %求十个管道温度方差 ","date":"2021-07-13","objectID":"/37/:8:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"多目标遗传优化算法 先写目标函数，再给定约束，求符合的自变量取值。 functiony=fun(x)y(1)=-(x(1)*100/3 + x(3)*90/3 + x(2)*80/2+x(4)*70/2); y(2)=x(3)+x(4); end clear clc fitnessfcn=@fun; % 变量个数 nvars=4; % lb\u003c= X \u003c= ub lb=[0,0,0,0]; ub=[]; % A*X \u003c= b A = [0 0 1 1 -1/3 0 0 0 0 -1/2 0 0 0 0 0 0]; b = [48 ; 30 ; 30 ; 0]; % Aeq*X = beq Aeq=[1 1 0 0;0 0 0 0; 0 0 0 0; 0 0 0 0]; beq=[120;0;0;0]; %最优个体系数paretoFraction %种群大小populationsize %最大进化代数generations %停止代数stallGenLimit %适应度函数偏差TolFun %函数gaplotpareto：绘制Pareto前沿 options=gaoptimset('paretoFraction',0.3,'populationsize',200,'generations',300,'stallGenLimit',200,'TolFun',1e-10,'PlotFcns',@gaplotpareto); [x,fval]=gamultiobj(fitnessfcn,nvars,A,b,Aeq,beq,lb,ub,options) plot(-fval(:,1),fval(:,2),'pr') xlabel('f_1(x)') ylabel('f_2(x)') title('Pareto front') grid on 完整文档详见：博客相关资源-长三角数学建模B题 ","date":"2021-07-13","objectID":"/37/:9:0","tags":["matlab","数学建模","皮尔逊相关系数","熵值法","多元函数拟合"],"title":"多元回归和熵值评价法及多目标遗传优化算法","uri":"/37/"},{"categories":["数学建模"],"content":"前言 感谢组员的共同协作，做组长的有些东西帮不上实在抱歉。 ","date":"2021-07-09","objectID":"/36/:1:0","tags":["matlab","数学建模","python"],"title":"改进的SIR差分模型及三个模型的应用","uri":"/36/"},{"categories":["数学建模"],"content":"改进的SIR差分模型 %% SIR差分模型 frame=importdata('美国covid19疫情数据l-history改.csv'); date_row=size(frame.data,1); data=frame.data; date=frame.textdata(:,1); real_date=date(2:date_row+1,:); E=zeros(2,90); l=0.000125; %日接触率 m=0.01; %日治愈率0.0005 E(1,1)=data(345,12)/300000000; E(2,1)=1-E(1,1); for i=1:90 E(1,i+1)=l*E(2,i)-m*E(1,i)+E(1,i); E(2,i+1)=E(2,i)-l*E(1,i)*E(2,i); end X=flip(data(311:345,12)');% 5.31 4.2 rate=flip(data(311:345,12)')%现阳性率 rate(isnan(rate))=0; n=length(rate); rt=0:1:n-1; %a0=[100,10]; %初值 figure(1) h1 = plot(rt,X/300000000,'*'); %画点 hold on; a=E(1,:); b=E(2,:); h2 = plot(a,'r') xlabel('日期'); %设置横坐标名 ylabel('感染人数'); %设置纵坐标名 legend([h1 h2],'3~5月感染人数','SIR模型迭代曲线','Location','NorthWest'); hold on %% 预测 X=flip(data(255:345,12)');%311行后为第一题 rate=flip(data(255:345,12)')%现阳性率 rate(isnan(rate))=0; n=length(rate); rt=0:1:n-1; figure(2) h3 = plot(rt,X/300000000,'*'); %画点 hold on; a=E(1,:); b=E(2,:); h4=plot(a,'r') xlabel('日期'); ylabel('感染人数'); legend([h3 h4],'3~6月感染人数','SIR模型迭代曲线','Location','NorthWest'); hold on %% 接种疫苗前 frame=importdata('usc.csv'); date_row=size(frame.data,1); data=frame.data; date=frame.textdata(:,1); real_date=date(2:date_row+1,:); E=zeros(3,150); l=0.0018; %日接触率 0.0018 m=0.01; %日治愈率 0.01 E(1,1)=data(320,1)/300000000; E(3,1)=28664448/300000000%43714928 33714928 28664448 E(2,1)=1-E(1,1)-E(3,1); for i=1:150 E(1,i+1)=E(1,i)+l*E(2,i)-m*E(1,i); E(2,i+1)=E(2,i)-l*E(1,i)*E(2,i); E(3,i+1)=1-E(1,i+1)- E(2,i+1); end X=data(320:486,1)';%80-482 3.1-7.1 rate=data(320:486,1)'% rate(isnan(rate))=0; n=length(rate); rt=0:1:n-1; figure(6) h11 = plot(rt,X/300000000,'*'); %画点 hold on; a=E(1,:); b=E(2,:); c=E(3,:); t=1:151; h1=plot(t,a,'r')%感染人数 %plot(t,b,'b')%健康人数 plot(t,c,'r')%移除者 %legend('i(t)','s(t)','r(t)') hold on %% 接种疫苗后 E=zeros(3,150); l=0.0018; %日接触率 0.0018 m=0.01; %日治愈率 0.01 E(1,1)=data(320,1)/300000000; E(3,1)=53714928/300000000%43714928 33714928 28664448 E(2,1)=1-E(1,1)-E(3,1); for i=1:150 E(1,i+1)=E(1,i)+l*E(2,i)-m*E(1,i); E(2,i+1)=E(2,i)-l*E(1,i)*E(2,i); E(3,i+1)=1-E(1,i+1)- E(2,i+1); end X=data(320:486,1)';%80-482 3.1-7.1 rate=data(320:486,1)'% rate(isnan(rate))=0; n=length(rate); rt=0:1:n-1; figure(6) %h11 = plot(rt,X/300000000,'*'); %画点 hold on; a=E(1,:); b=E(2,:); c=E(3,:); t=1:151; h2=plot(t,a,'b')%感染人数 %plot(t,b,'b')%健康人数 plot(t,c,'b')%移除者 %legend('i(t)','s(t)','r(t)') hold on xlabel('日期'); %设置横坐标名 ylabel('r(t)与i（t）'); %设置纵坐标名 legend([h1 h2 h11],'接种疫苗前','接种疫苗后','感染人数原始数据','Location','NorthWest'); ","date":"2021-07-09","objectID":"/36/:2:0","tags":["matlab","数学建模","python"],"title":"改进的SIR差分模型及三个模型的应用","uri":"/36/"},{"categories":["数学建模"],"content":"logistic模型预测美国人口 %改进的指数增长模型 x=flip([324985536 322941312 320635168 318300992 315993728 313830976 311556864 309321664 306771520 304093952 301231200 298379904 295516608 292805312 290107936 287625184 284968960 282162400 279040000 275854016 272656992]) y=flip([0.006330017,0.007192424,0.007333235,0.007301613,0.006891455,0.007299188,0.007226135,0.008312845,0.008805068,0.009503504,0.009555925,0.00968912,0.009259723,0.009297836,0.008631901,0.009321099,0.009946612,0.011189794,0.011549529,0.011725443,0.012112401]) n=length(x); t=0:1:n-1; rk=zeros(1,n); rk(1)=(-3*x(1)+4*x(2)-x(3))/2; rk(n)=(x(n-2)-4*x(n-1)+3*x(n))/2; for i=2:n-1 rk(i)=(x(i+1)-x(i-1))/2; end rk=rk./x; p=polyfit(t,rk,2); r0=p(1); r1=p(2); r2=p(3); x0=x(1); R=r0*t.^2+r1*t+r2; X=x0*exp((r0*t.^3)/3+(r1*t.^2)/2+r2*t); figure(1) hold on; xlabel('year'); %设置横坐标名 ylabel('rate'); %设置纵坐标名 grid on %网格线 plot(t,y,'r*') figure(2) hold on; xlabel('year'); %设置横坐标名 ylabel('population'); %设置纵坐标名 grid on %网格线 plot(t,x,'r*',t,X) figure(3) hold on; xlabel('year'); %设置横坐标名 ylabel('rate'); %设置纵坐标名 grid on %网格线 plot(t,y,'r*',t,R') %2018 t1=t(21)+1; x2018=x0*exp((r0*t1.^3)/3+(r1*t1.^2)/2+r2*t1) y2018=r0*t1.^2+r1*t1+r2 %2019 t1=t(21)+2; x2019=x0*exp((r0*t1.^3)/3+(r1*t1.^2)/2+r2*t1) y2019=r0*t1.^2+r1*t1+r2 ","date":"2021-07-09","objectID":"/36/:3:0","tags":["matlab","数学建模","python"],"title":"改进的SIR差分模型及三个模型的应用","uri":"/36/"},{"categories":["数学建模"],"content":"药物中毒急救建模 clc; clear all; syms x t; f(t)=6*(exp(-0.1155*t)-exp(-0.1386*t)); h(t)=exp(-0.1386*t); figure(1); fplot(f,[0 25]); hold on; fplot(h,[0,25]); grid on; xlabel('时间t/h'); ylabel('药量'); legend('血液中的药量y/mg','胃肠道中的药量x/mg'); figure(2) fplot(f,[0,25]); hold on; fplot(h,[0,25]); f(t)=-(exp(-0.693*t)-exp(-0.1386*t))/4; fplot(f,[0,25]); xlabel('时间t/h'); ylabel('药量'); legend('血液中的药量y/mg','胃肠道中的药量x/mg','施救后血液中的药量y/mg'); ","date":"2021-07-09","objectID":"/36/:4:0","tags":["matlab","数学建模","python"],"title":"改进的SIR差分模型及三个模型的应用","uri":"/36/"},{"categories":["数学建模"],"content":"热传导差分偏微分模型应用 clear; close all; clc; pho=[300;862;74.2;1.18]; c=[1377;2100;1726;1005]; lamda=[0.082;0.37;0.045;0.028]; a=lamda./(pho.*c); d=[0.6;6;3.6;5]*10^-3; TT=273.15; T_in=37; T_out=75; T_s=48.08; xmin=0; xmax=sum(d); N=5400; h=0.05*10^-3; k=1; r=k/h^2; I=round((xmax-xmin)/h); A=zeros(1,I); B=zeros(1,I+1); C=zeros(1,I); N1=round(d(1)/h); N2=round(d(2)/h); N3=round(d(3)/h); N4=round(d(4)/h); for i=1:N1 A(i)=-a(1)*r; B(i)=2+2*r*a(1); C(i)=-r*a(1); end for i=N1+1:N1+N2 A(i)=-a(2)*r; B(i)=2+2*r*a(2); C(i)=-r*a(2); end for i=N1+N2+1:N1+N2+N3 A(i)=-a(3)*r; B(i)=2+2*r*a(3); C(i)=-r*a(3); end for i=N1+N2+N3+1:N1+N2+N3+N4 A(i)=-a(4)*r; B(i)=2+2*r*a(4); C(i)=-r*a(4); end T=zeros(I+1,N+1); T(:,1)=(T_in+TT)*ones(I+1,1); T_xt=xlsread('CUMCM-2018-Problem-A-Chinese-Appendix.xlsx'); h_min=110; h_max=120; delta_h=0.1; H1=h_min:delta_h:h_max; delta=zeros(1,length(H1)); for j=1:length(H1) h1=h_min+(j-1)*delta_h; k1=lamda(1);k2=lamda(2);k3=lamda(3);k4=lamda(4); x1=d(1);x2=d(1)+d(2);x3=d(1)+d(2)+d(3);x4=d(1)+d(2)+d(2)+d(4); t1=T_out+TT;t2=T_in+TT;t3=T_s+TT; h5=-((h1*k2*k3*k4*t1)/(k1*k2*k3*k4-h1*k1*k2*k3*x3-h1*k1*k2*k4*x2 ... -h1*k1*k3*k4*x1+h1*k1*k2*k3*x4+h1*k1*k2*k4*x3+h1*k1*k3*k4*x2+h1*k2*k3*k4*x1)-(h1*k2*k3*k4*t3)... /(k1*k2*k3*k4-h1*k1*k2*k3*x3-h1*k1*k2*k4*x2-h1*k1*k3*k4*x1+h1*k1*k2*k3*x4+h1*k1*k2*k4*x3+h1*k1*k3*k4*x2+h1*k2*k3*k4*x1))... /(t2/k1-t3/k1); AA=diag(B)+diag(A,1)+diag(C,-1); AA(1,1)=lamda(1)/h+h1; AA(1,2)=-lamda(1)/h; AA(I+1,I)=-lamda(4)/h; AA(I+1,I+1)=lamda(4)/h+h5; AA(N1+1,N1)=-lamda(1); AA(N1+1,N1+1)=lamda(1)+lamda(2); AA(N1+1,N1+2)=-lamda(2); AA(N1+N2+1,N1+N2)=-lamda(2); AA(N1+N2+1,N1+N2+1)=lamda(2)+lamda(3); AA(N1+N2+1,N1+N2+2)=-lamda(3); AA(N1+N2+N3+1,N1+N2+N3)=-lamda(3); AA(N1+N2+N3+1,N1+N2+N3+1)=lamda(3)+lamda(4); AA(N1+N2+N3+1,N1+N2+N3+2)=-lamda(4); for n=1:k:N D=zeros(I+1,1); D(1)=h1*(T_out+TT); D(I+1)=h5*(T_in+TT); for i=2:1:N1 D(i)=r*a(1)*T(i-1,n)+(2-2*r*a(1))*T(i,n)+r*a(1)*T(i+1,n); end for i=N1+1:1:N1+N2 D(i)=r*a(2)*T(i-1,n)+(2-2*r*a(2))*T(i,n)+r*a(2)*T(i+1,n); end for i=N1+N2+1:1:N1+N2+N3 D(i)=r*a(3)*T(i-1,n)+(2-2*r*a(3))*T(i,n)+r*a(3)*T(i+1,n); end for i=N1+N2+N3+1:1:N1+N2+N3+N4 D(i)=r*a(4)*T(i-1,n)+(2-2*r*a(4))*T(i,n)+r*a(4)*T(i+1,n); end D(N1+1)=0; D(N1+N2+1)=0; D(N1+N2+N3+1)=0; T(:,n+1)=AA\\D; end delta(j)=sqrt(sum((T_xt(:,2)-T(end,:)'+TT).^2)/length(T_xt(:,1))); end %图二 figure(1); mesh(0:k:N,1000*(0:h:sum(d)),(T-TT)); %图三 T_problem1=zeros(N+1,4); T_problem1(:,1)=T(1,:)'; T_problem1(:,2)=T(N1+1,:)'; T_problem1(:,3)=T(N2+N1+1,:)'; T_problem1(:,4)=T(N3+N2+N1+1,:)'; T_problem1=T_problem1-TT; figure(2); plot(0:k:N,T_problem1(:,1)',0:k:N,T_problem1(:,2)',0:k:N,T_problem1(:,3)',0:k:N,T_problem1(:,4)',0:k:N,T_xt(:,2)'); ","date":"2021-07-09","objectID":"/36/:5:0","tags":["matlab","数学建模","python"],"title":"改进的SIR差分模型及三个模型的应用","uri":"/36/"},{"categories":["数学建模"],"content":"python数据处理(写的很乱) 为了写第一个模型整合各种数据。。。有点乱，将就看吧。 #导入需要的数据库和文件 import numpy as np import pandas as pd import matplotlib.pyplot as plt from matplotlib.pyplot import MultipleLocator odata=pd.read_csv(r'us_state_vaccinations.csv') plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False r_hex = '#dc2624' # red, RGB = 220,38,36 dt_hex = '#2b4750' # dark teal, RGB = 43,71,80 tl_hex = '#45a0a2' # teal, RGB = 69,160,162 r1_hex = '#e87a59' # red, RGB = 232,122,89 tl1_hex = '#7dcaa9' # teal, RGB = 125,202,169 g_hex = '#649E7D' # green, RGB = 100,158,125 o_hex = '#dc8018' # orange, RGB = 220,128,24 tn_hex = '#C89F91' # tan, RGB = 200,159,145 g50_hex = '#6c6d6c' # grey-50, RGB = 108,109,108 bg_hex = '#4f6268' # blue grey, RGB = 79,98,104 g25_hex = '#c7cccf' # grey-25, RGB = 199,204,207 odata \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rdate\rlocation\rtotal_vaccinations\rtotal_distributed\rpeople_vaccinated\rpeople_fully_vaccinated_per_hundred\rtotal_vaccinations_per_hundred\rpeople_fully_vaccinated\rpeople_vaccinated_per_hundred\rdistributed_per_hundred\rdaily_vaccinations_raw\rdaily_vaccinations\rdaily_vaccinations_per_million\rshare_doses_used\r\r\r\r\r0\r2021-01-12\rAlabama\r78134.0\r377025.0\r70861.0\r0.15\r1.59\r7270.0\r1.45\r7.69\rNaN\rNaN\rNaN\r0.207\r\r\r1\r2021-01-13\rAlabama\r84040.0\r378975.0\r74792.0\r0.19\r1.71\r9245.0\r1.53\r7.73\r5906.0\r5906.0\r1205.0\r0.222\r\r\r2\r2021-01-14\rAlabama\r92300.0\r435350.0\r80480.0\rNaN\r1.88\rNaN\r1.64\r8.88\r8260.0\r7083.0\r1445.0\r0.212\r\r\r3\r2021-01-15\rAlabama\r100567.0\r444650.0\r86956.0\r0.28\r2.05\r13488.0\r1.77\r9.07\r8267.0\r7478.0\r1525.0\r0.226\r\r\r4\r2021-01-16\rAlabama\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r7557.0\r7498.0\r1529.0\rNaN\r\r\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r\r\r11328\r2021-06-30\rWyoming\r421749.0\r516025.0\r226911.0\r34.38\r72.87\r198958.0\r39.21\r89.16\r55.0\r913.0\r1578.0\r0.817\r\r\r11329\r2021-07-01\rWyoming\r423238.0\r516325.0\r227741.0\r34.51\r73.13\r199743.0\r39.35\r89.21\r1489.0\r1113.0\r1923.0\r0.820\r\r\r11330\r2021-07-02\rWyoming\r424025.0\r516865.0\r228162.0\r34.59\r73.26\r200184.0\r39.42\r89.31\r787.0\r847.0\r1463.0\r0.820\r\r\r11331\r2021-07-03\rWyoming\r431008.0\r517365.0\r230914.0\r35.34\r74.47\r204522.0\r39.90\r89.39\r6983.0\r1680.0\r2903.0\r0.833\r\r\r11332\r2021-07-04\rWyoming\r431101.0\r517365.0\r230993.0\r35.35\r74.49\r204598.0\r39.91\r89.39\r93.0\r1682.0\r2906.0\r0.833\r\r\r\r11333 rows × 14 columns \r states = list(set(odata['location'])) len(states) 65\r date = list(set(odata['date'])) date.sort() date date[0] '2020-12-20'\r US = odata.loc[odata['date'] == '2021-01-12'] US \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rdate\rlocation\rtotal_vaccinations\rtotal_distributed\rpeople_vaccinated\rpeople_fully_vaccinated_per_hundred\rtotal_vaccinations_per_hundred\rpeople_fully_vaccinated\rpeople_vaccinated_per_hundred\rdistributed_per_hundred\rdaily_vaccinations_raw\rdaily_vaccinations\rdaily_vaccinations_per_million\rshare_doses_used\r\r\r\r\r0\r2021-01-12\rAlabama\r78134.0\r377025.0\r70861.0\r0.15\r1.59\r7270.0\r1.45\r7.69\rNaN\rNaN\rNaN\r0.207\r\r\r174\r2021-01-12\rAlaska\r35838.0\r141600.0\r22486.0\r0.74\r4.90\r5400.0\r3.07\r19.36\rNaN\rNaN\rNaN\r0.253\r\r\r348\r2021-01-12\rAmerican Samoa\r2124.0\r10650.0\r842.0\r0.47\r3.81\r260.0\r1.51\r19.12\rNaN\rNaN\rNaN\r0.199\r\r\r522\r2021-01-12\rArizona\r141355.0\r563025.0\r95141.0\r0.11\r1.94\r8343.0\r1.31\r7.74\rNaN\rNaN\rNaN\r0.251\r\r\r696\r2021-01-12\rArkansas\r40879.0\r274400.0\r39357.0\r0.00\r1.35\r8.0\r1.30\r9.09\rNaN\rNaN\rNaN\r0.149\r\r\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r\r\r10463\r2021-01-12\rVirginia\r190607.0\r797150.0\rNaN\rNaN\r2.23\rNaN\rNaN\r9.34\rNaN\rNaN\rNaN\r0.239\r\r\r10637\r2021-01-12\rWashington\r195567.0\r567725.0\r162105.0\r0.23\r2.57\r17689.0\r2.13\r7.46\rNaN\rNaN\rNaN\r0.344\r\r\r10811\r2021-01-12\rWest Virginia\r103330.0\r160975.0\rNaN\rNaN\r5.77\rNaN\rNaN\r8.98\rNaN\rNaN\rNaN\r0.642\r\r\r10985\r2021-01-12\rWisconsin\r137253.0\r429500.0\r125895.0\r0.19\r2.36\r11343.0\r2.16\r7.38\rNaN\rNaN\rNaN\r0.320\r\r\r11159\r2021-01-12\rWy","date":"2021-07-09","objectID":"/36/:6:0","tags":["matlab","数学建模","python"],"title":"改进的SIR差分模型及三个模型的应用","uri":"/36/"},{"categories":["电脑技巧"],"content":"一、使用说明 更新一个整库脚本 ql repo \u003crepourl\u003e \u003cpath\u003e \u003cblacklist\u003e \u003cdependence\u003e \u003cbranch\u003e 更新单个脚本文件 ql raw \u003cfileurl\u003e ","date":"2021-07-06","objectID":"/35/:1:0","tags":["linux"],"title":"JD脚本仓库合集","uri":"/35/"},{"categories":["电脑技巧"],"content":"二、拉取整库实例【以下仓库排名不分先后，纯粹随机排列】 （一）某已退圈并不愿透露姓名大佬库 的现存备份托管库`（下列方案选1个就行，排名不分先后） panghu999维护版仓库 名称： 拉取胖虎代维护 命令： ql repo https://github.com/panghu999/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp|jd_delCoupon|format_\" \"^jd[^_]|USER\" 定时规则： 0 */6 * * * JDHelloWorld维护版仓库 名称： 拉取Hello 命令： ql repo https://github.com/JDHelloWorld/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp|jd_delCoupon\" \"^jd[^_]|USER\" 定时规则： 5 */6 * * * chinnkarahoi维护版仓库 名称： 拉取chinnkarahoi 命令： ql repo https://github.com/chinnkarahoi/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp|jd_delCoupon\" \"^jd[^_]|USER\" 定时规则： 10 */6 * * * he1pu（自动提交助力码-京喜工厂、种豆得豆、东东工厂、东东农场、健康社区、京喜财富岛、东东萌宠、闪购盲盒，随机从数据库中选取助力码互助） 名称： 拉取he1pu 命令： ql repo https://github.com/he1pu/JDHelp.git \"jd_|jx_|getJDCookie\" \"activity|backUp|jd_delCoupon\" \"^jd[^_]|USER\" 定时规则： 15 */6 * * * （二）longzhuzhu（龙珠）仓库 名称： 拉取龙珠 命令： ql repo https://github.com/longzhuzhu/nianyu.git \"qx\" 定时规则： 20 */6 * * * （三）whyour/hundun（混沌）仓库 名称： 拉取混沌 命令： ql repo https://github.com/whyour/hundun.git \"quanx\" \"tokens|caiyun|didi|donate|fold|Env\" 定时规则： 25 */6 * * * （四）passerby-b仓库 名称： 拉取passerby-b 命令： ql repo https://github.com/passerby-b/JDDJ.git \"jddj_\" \"scf_test_event\" \"jddj_cookie\" 定时规则： 30 */6 * * * （五）Wenmoux（温某人）仓库 名称： 拉取温某人 命令： ql repo https://github.com/Wenmoux/scripts.git \"other|jd\" \"\" \"\" \"wen\" 定时规则： 0 */4 * * * （六）panghu999/panghu（胖虎原创）仓库 名称： 拉取胖虎原创 命令： ql repo https://github.com/panghu999/panghu.git \"jd_\" 定时规则： 0 */4 * * * （七）zoopanda（动物园）仓库 名称： 拉取动物园 命令： ql repo https://github.com/zooPanda/zoo.git \"zoo\" 定时规则： 0 */4 * * * （八）hyzaw（ddo）仓库 名称： 拉取ddo 命令： ql repo https://github.com/hyzaw/scripts.git \"ddo_\" 定时规则： 0 */4 * * * （九）Ariszy (原名Zhiyi-N)仓库 名称： 拉取执意 命令： ql repo https://github.com/Ariszy/Private-Script.git \"JD\" 定时规则： 0 */5 * * * （十）ZCY01仓库 名称： 拉取ZCY01 命令： ql repo https://github.com/ZCY01/daily_scripts.git \"jd_\" 定时规则： 0 */5 * * * （十一）monk-dust/dust（藏经阁）oreomeow备份版仓库 名称： 拉取藏经阁 命令： ql repo https://github.com/Oreomeow/dust.git \"i-chenzhe|normal|member|car\" \"backup\" 定时规则： 0 */5 * * * （十二）star261仓库 名称： 拉取star 命令： ql repo https://github.com/star261/jd.git \"scripts\" \"code\" 定时规则： 0 */5 * * * （十三）curtinlv（TopStyle）仓库 名称： 拉取TopStyle 命令： ql repo https://github.com/curtinlv/JD-Script.git 定时规则： 0 */5 * * * （十四）moposmall仓库 名称： 拉取moposmall 命令： ql repo https://github.com/moposmall/Script.git \"Me\" 定时规则： 0 */6 * * * （十五） photonmang（宠汪汪及兑换、点点券修复） 名称： 拉取photonman 命令： ql repo https://github.com/photonmang/quantumultX.git \"JDscripts\" 定时规则： 0 */6 * * * （十六）cdle 名称： 拉取cdle 命令： ql repo https://github.com/cdle/jd_study.git 定时规则： 0 */6 * * * ","date":"2021-07-06","objectID":"/35/:2:0","tags":["linux"],"title":"JD脚本仓库合集","uri":"/35/"},{"categories":["电脑技巧"],"content":"三、单脚本（定时规则都设置为 0 */8 * * * 即可） （一）翻翻乐提现单文件 ql raw https://raw.githubusercontent.com/jiulan/platypus/main/scripts/jd_ffl.js （二）curtinlv（上面拉过仓库的可以不用拉了） 15 8 * * * 赚京豆 ql raw https://raw.githubusercontent.com/curtinlv/JD-Script/main/jd_zjd.py 入会 ql raw https://raw.githubusercontent.com/curtinlv/JD-Script/main/OpenCard/jd_OpenCard.py 关注 ql raw https://raw.githubusercontent.com/curtinlv/JD-Script/main/getFollowGifts/jd_getFollowGift.py 欢迎请站长喝一杯 ","date":"2021-07-06","objectID":"/35/:3:0","tags":["linux"],"title":"JD脚本仓库合集","uri":"/35/"},{"categories":["数学建模"],"content":"7个组长分60个上机座位 ","date":"2021-07-05","objectID":"/33/:1:0","tags":["博弈论","数学建模"],"title":"海盗分金问题变种-组长分座位","uri":"/33/"},{"categories":["数学建模"],"content":"问题 1.5月3日从早晨到晚上上机，207机房有60个机位, 请7个组长分上机座位 2.按照ABCDE组顺序开始分配, 每个组长都是足够聪明,A组长制定分配方案时,剩余的组长投票, 如有一半人不同意, A组就失去上机机会,同时失 去再次分配的权利,A组也失去投票机会. 3.A组失败后就是BCDE组分配规则一样. 4.请问我们最后得到的分配方案是什么?!各组所 得上机都是多少席?! ","date":"2021-07-05","objectID":"/33/:1:1","tags":["博弈论","数学建模"],"title":"海盗分金问题变种-组长分座位","uri":"/33/"},{"categories":["数学建模"],"content":"逻辑化 该问题与海盗博弈模型较为类似，可以参考该模型解答。 A组长会要求给自己组57个座位，给C，E，G组长各一个座位，不给B，D，F组座位。 首先反过来看： 1.如果只有F和G组长，F给自己60个座位，给G组0个。 因为F有决定权，所以分配达成。 2.如果有三个组长E，F和G，E知道F下轮会给G组0个座位，所以E这轮给G组 1个座位，让G组长支持自己以使得提议通过。 因此如果有三个组长，结果是E：59，F：0，G：1。 3.如果有四个组长D，E，F，G，D知道上述推理。 所以为了避免失去座位，他只需要给F组长1个座位，因为他有决定权，只需要F的支持就足够了。 因此他会提议 D：59， E：0， F：1，G：0。 4.照此推广，当有7位组长时，A组长只需要隔一个人拉拢一个组长，给他们每人一个座位即可。 所以最后的分配方案如下： A：57， B：0， C：1，D：0，E：1， F：0，G：1。 ","date":"2021-07-05","objectID":"/33/:1:2","tags":["博弈论","数学建模"],"title":"海盗分金问题变种-组长分座位","uri":"/33/"},{"categories":["电脑技巧"],"content":"CentOS8安装VNC窗口桌面并使用 ","date":"2021-07-05","objectID":"/32/:1:0","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step1 安装vnc软件 终端窗口输入 sudo -i dnf install tigervnc tigervnc-server ","date":"2021-07-05","objectID":"/32/:1:1","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step2 修改vncserver-config-defaults ， 如果添加一行localhost ，外部不能访问 终端窗口输入 vim /etc/tigervnc/vncserver-config-defaults 按i键进入编辑模式，复制粘贴下面内容替换原来的内容 session=gnome securitytypes=vncauth,tlsvnc desktop=sandbox geometry=2000x1200 alwaysshared 按Esc键关闭编辑模式，输入 :wq 再按回车退出vim，下面编辑方式一样，不再赘述，将内容和打开文件命令变一下即可。 ","date":"2021-07-05","objectID":"/32/:1:2","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step3 编辑vncserver.users 终端窗口输入 vim /etc/tigervnc/vncserver.users 替换内容 :1=root :2=admin ","date":"2021-07-05","objectID":"/32/:1:3","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step4 配置vnc密码 终端 [root@OS-CentOS8 ~]$vncpasswd Password:你的登陆密码，输入不会显示，自己记住 Verify:你的登陆密码，输入不会显示，自己记住 Would you like to enter a view-only password (y/n)? n A view-only password is not used ","date":"2021-07-05","objectID":"/32/:1:4","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step5 复制vncserver@x.service 文件 终端输入 cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service ","date":"2021-07-05","objectID":"/32/:1:5","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step6 配置vnc开机自启服务 终端输入 systemctl enable vncserver@:1 ","date":"2021-07-05","objectID":"/32/:1:6","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step7 启动vnc服务 终端输入 systemctl start vncserver@:1 ","date":"2021-07-05","objectID":"/32/:1:7","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step8 查看状态 终端输入 systemctl status vncserver@\\:1 看到绿色和active字样就是成功安装并启动了。 ","date":"2021-07-05","objectID":"/32/:1:8","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"Step9 vncview客户端连接 文件下载链接： 太平洋下载 使用说明： 简书说明，从Step2开始看，前面安装不用看，点我跳转 ","date":"2021-07-05","objectID":"/32/:1:9","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"后言 除了不能使用exe文件，其他和win系统没啥区别，浏览器默认安装火狐的好像，不用更新，不然占用会很大。 欢迎请站长喝一杯 ","date":"2021-07-05","objectID":"/32/:1:10","tags":["VNC","linux"],"title":"CentOS8的VNC窗口桌面使用","uri":"/32/"},{"categories":["电脑技巧"],"content":"共用提取码 QLHL 蓝奏云盘 电脑Telegram 远程SSH工具,下载解压即可使用 各大文库PDF下载神器冰点文库 论文查重(需加Q群验证)(网络源) ↑↑↑需要加群后用管理员身份打开，每次打开软件需要在电脑打开那个Q群窗口检测 百度云盘提速IDM破解无需注册版软件 百度云盘不限速下载软件01(每日无限制，需要保存到自己网盘下载且易掉线) 百度网盘不限速下载软件02(每日4G限制，且有环境安装限制) 高数计算器 微星电脑性能测试软件 专业流程图制作软件 视频直播源破解软件 百度云盘 IDM破解无需注册版软件附有教程 ↑教程与配套软件 ↑↑↑看在资源的份上，麻烦点赞投币收藏我的文章—\u003ehttps://www.bilibili.com/read/cv6826074↑↑↑ 百度云盘分享链接直链解析新脚本 万分感谢！！！ 计算机等级考试模拟器 谷歌地球软件本地版 太极常用全套(含太极客户端) AI换脸软件(N卡/A卡) 天翼云盘 论文翻译器 MatlabR2018a AI人声伴奏分离器 ","date":"2021-07-05","objectID":"/shiyong/:0:0","tags":["windows","实用软件"],"title":"实用软件","uri":"/shiyong/"},{"categories":["电脑技巧"],"content":"后言 上述链接如有问题，请在-\u003e我的文章评论区\u003c-里留言，我会及时更新失效链接。 该页面的资源均由网络收集 本人不负任何法律责任，仅仅作为展出使用。 欢迎请站长喝一杯 ","date":"2021-07-05","objectID":"/shiyong/:1:0","tags":["windows","实用软件"],"title":"实用软件","uri":"/shiyong/"},{"categories":["博客建站相关"],"content":"鸣谢： 中文主题配置 ","date":"2021-07-04","objectID":"/31/:0:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"主题文档 - 基本概念 探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2021-07-04","objectID":"/31/:1:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2021-07-04","objectID":"/31/:2:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2021-07-04","objectID":"/31/:3:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2021-07-04","objectID":"/31/:3:1","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2021-07-04","objectID":"/31/:3:2","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2021-07-04","objectID":"/31/:3:3","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2021-07-04","objectID":"/31/:3:4","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \" 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2021-07-04","objectID":"/31/:3:5","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2021-07-04","objectID":"/31/:3:6","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"3 配置 ","date":"2021-07-04","objectID":"/31/:4:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2021-07-04","objectID":"/31/:4:1","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2021-07-04","objectID":"/31/:4:2","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2021-07-04","objectID":"/31/:4:3","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \" 语言切换 ","date":"2021-07-04","objectID":"/31/:5:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2021-07-04","objectID":"/31/:5:1","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2021-07-04","objectID":"/31/:5:2","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2021-07-04","objectID":"/31/:5:3","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2021-07-04","objectID":"/31/:6:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-07-04","objectID":"/31/:6:1","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2021-07-04","objectID":"/31/:6:2","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"主题文档 - 内容 了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. \r","date":"2021-07-04","objectID":"/31/:7:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2021-07-04","objectID":"/31/:8:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg ","date":"2021-07-04","objectID":"/31/:9:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览文章摘要预览 \" 文章摘要预览 ","date":"2021-07-04","objectID":"/31/:10:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2021-07-04","objectID":"/31/:10:1","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2021-07-04","objectID":"/31/:10:2","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2021-07-04","objectID":"/31/:10:3","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2021-07-04","objectID":"/31/:10:4","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2021-07-04","objectID":"/31/:10:5","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2021-07-04","objectID":"/31/:11:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2021-07-04","objectID":"/31/:12:0","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2021-07-04","objectID":"/31/:12:1","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2021-07-04","objectID":"/31/:12:2","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2021-07-04","objectID":"/31/:12:3","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2021-07-04","objectID":"/31/:12:4","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["博客建站相关"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2021-07-04","objectID":"/31/:12:5","tags":["hugo"],"title":"hugo的Lovelt主题配置","uri":"/31/"},{"categories":["电脑技巧"],"content":"官方安装教程 官方教程 ","date":"2021-07-03","objectID":"/30/:1:0","tags":["linux"],"title":"go-cqhttp搭建教程","uri":"/30/"},{"categories":["电脑技巧"],"content":"个人使用经验 压缩包里的是适配Linux环境的二进制文件 按照官方文档操作后，发现一些小问题 首先是config.yml的部分配置应该是这样子的 (我只使用http协议) uin: # 必填QQ账号 password: '' # 千万别填 只做推送用不需要数据库监控 database: # 数据库相关设置 leveldb: # 是否启用内置leveldb数据库 # 启用将会增加10-20MB的内存占用和一定的磁盘空间 # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能 enable: false 服务器这块需要改0.0.0.0 # HTTP 通信设置 - http: # 服务端得填0.0.0.0 host: 0.0.0.0 # 服务端监听端口，只要是端口开放了没被占用就行 port: 3500 下面是我使用的版本的压缩包，上传宝塔中的一个空文件夹里解压参照官方文档和我的个人经验使用即可 本人使用的go-cqhttp压缩包：博客相关资源-go-cqhttp 如果是参照官方文档搭的本地版本 本地搭建这块需要改127.0.0.1 # HTTP 通信设置 - http: # 本地搭建得填127.0.0.1 host: 127.0.0.1 # 服务端监听端口，只要是端口开放了没被占用就行 port: 3500 云服务器需要使用screen命令后台24小时运行 在go-cqhttp文件所在的文件夹终端中输入 screen -S QQ 创建会话窗口 然后输入 sudo ./go-cqhttp 运行程序 等待初始化后，QQ扫码登陆即可 登陆完成后 在当前会话窗口中按住Ctrl,a,d三个快捷键可以实现分离会话窗口，这时窗口会弹出[detached]的提示，并回到主窗口，此时可以关闭终端，已经成功挂上了。 如果想要恢复查看 终端输入 screen -ls 显示 There is a screen on: 2637.QQ (12/17/2015/10:00:32 AM) (Detached) 终端输入 screen -r 2637 进入2637线程，恢复QQ会话窗口 或 screen -r QQ 这样就能回到QQ窗口了 如果输入screen -ls后看到QQ窗口后面的(???dead)字样，说明窗口死了，但是仍在占用空间。这时需要清除窗口 输入 screen -wipe 自动清除死去的窗口 鸣谢： 参考的csdn博客 欢迎请站长喝一杯 ","date":"2021-07-03","objectID":"/30/:2:0","tags":["linux"],"title":"go-cqhttp搭建教程","uri":"/30/"},{"categories":["电脑技巧"],"content":"2.8版本青龙面板搭建教程 ","date":"2021-07-02","objectID":"/29/:0:0","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step1 需要有一个云服务器，推荐我自用的腾讯云无忧计划： 优惠渠道 优点：每月续费同价，可随时重置服务器系统。 我的配置： 1核2g内存的北京-轻量云服务器 每月续费15元 系统应用重置为Ubuntu20.0版本 学生机优惠 优点：一年98，可同价位续费三次 缺点：有资格限制，需要实名认证在25岁以下 腾讯云买完后进入轻量云服务器后台有个防火墙管理，添加端口号5700,8888，给面板开放端口。 ","date":"2021-07-02","objectID":"/29/:0:1","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step2 装宝塔页面，方便文件管理，不用到处cd开文件夹 宝塔安装页面：点我跳转 等待宝塔安装完成并进入宝塔面板，等待默认LAMP安装完成。 ","date":"2021-07-02","objectID":"/29/:0:2","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step3 在软件商店搜索docker，安装docker管理器 ","date":"2021-07-02","objectID":"/29/:0:3","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step4 在终端输入进入管理员模式 终端输入，一行一行执行 sudo -i yum update curl -sSL https://get.daocloud.io/docker | sh sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo systemctl start docker ","date":"2021-07-02","objectID":"/29/:0:4","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step5 拉取镜像 终端输入 docker pull whyour/qinglong:latest ","date":"2021-07-02","objectID":"/29/:0:5","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step6 安装青龙 终端输入 docker run -dit \\ -v $pwd/ql/config:/ql/config \\ -v $pwd/ql/log:/ql/log \\ -v $pwd/ql/db:/ql/db \\ -v $pwd/ql/scripts:/ql/scripts \\ -v $pwd/ql/jbot:/ql/jbot \\ -p 5700:5700 \\ -e ENABLE_HANGUP=true \\ -e ENABLE_WEB_PANEL=true \\ --name qinglong \\ --hostname qinglong \\ --restart always \\ whyour/qinglong:latest 等待运行完成后，终端输入 firewall-cmd --zone=public --add-port=5700/tcp --permanent ","date":"2021-07-02","objectID":"/29/:0:6","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step6 查看密码 先浏览器打开http://你服务器外网IP:5700 默认帐号密码均为admin，输入登录后提示查看密码 在宝塔面板的文件页面搜索ql，找到文件夹后在ql/config文件夹里找到auth.json,里面是账号和密码。 ","date":"2021-07-02","objectID":"/29/:0:7","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step7 更新密码 你服务器ip:5700 是你的青龙面板地址，登陆青龙面板后在设置里修改面板用户名和密码。 如果忘了用户名和密码可以自己看step6中的auth.json找回。 ","date":"2021-07-02","objectID":"/29/:0:8","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step8 新建任务 定时任务里添加任务 名称命名(命名任务保证搜索容易查找拉取库) 任务1 XXX 任务2 XXX …… 命令内容 一行一个新建定时，定时写 0 6 * * * 定时拉取脚本更新 ql repo https://github.com/passerby-b/JDDJ.git ql repo https://github.com/ZCY01/daily_scripts.git \"jd_\" ql repo https://github.com/longzhuzhu/nianyu.git \"qx\" “main” ql repo https://github.com/whyour/hundun.git \"quanx\" \"tokens|caiyun|didi|donate|fold|Env\" ql repo https://github.com/huiyi9420/monk-coder_dust.git \"i-chenzhe|normal|member|car\" \"backup\" ql repo https://github.com/zooPanda/zoo.git \"zoo\" ql repo https://github.com/star261/jd.git \"scripts\" \"code\" ql repo https://github.com/panghu999/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp\" \"^jd[^_]|USER\" 确认完后点操作列中的开始按钮执行一次，等待完成后点操作列中的禁用按钮禁用，建议禁用，避免作者删库跑路，也可以不禁用，但不建议新手如此操作。 7月6日更新的JD脚本仓库合集，拉取库点这个用最新的 ","date":"2021-07-02","objectID":"/29/:0:9","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step9 添加ck 在环境变量里 变量名 JD_COOKIE 变量值 一行一个ck 格式 pt_key=1111111111;pt_pin=111111; pt_key=2222222222;pt_pin=222222; 备注随便写，没影响 ","date":"2021-07-02","objectID":"/29/:0:10","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"step10 配置推送 在配置文件里看注释说明配置 推荐： ## Push Plus export PUSH_PLUS_TOKEN=\"\" export PUSH_PLUS_USER=\"\" 其中 PUSH_PLUS_TOKEN 是http://pushplus.plus/ 注册登录后提供的Token，必填 PUSH_PLUS_USER 选填，一对一则不填，一对多必填，填入pushplus群组编号 完事了 ","date":"2021-07-02","objectID":"/29/:0:11","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"ck获取教程 获取教程 注意：这里不推荐用扫码登陆，因为cookie有效期只有一天，用手机跟验证码登陆后，cookie可以保持很久，大概有效期1个月多。 按照教程获取到的ck，使用它的pt_key=抓到的对应值内容;,pt_pin=抓到的对应值内容;，填入step9。 ","date":"2021-07-02","objectID":"/29/:0:12","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"本地ck获取 某大佬仓库： https://github.com/scjtqs/jd_cookie ","date":"2021-07-02","objectID":"/29/:0:13","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["电脑技巧"],"content":"个人挂机项目收集 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 相关挂机项目点我跳转 欢迎请站长喝一杯 ","date":"2021-07-02","objectID":"/29/:0:14","tags":["linux"],"title":"青龙面板搭建教程","uri":"/29/"},{"categories":["数学建模"],"content":"前言 感谢组员的共同协作。 ","date":"2021-06-27","objectID":"/28/:1:0","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"问题 以人口总数、人口年度增长率为研究对象，利用并根据世界人口网搜索1959年到2018年印度国家人口统计数据进行参数估计，即数据拟合，并对2019年印度人口进行增长预测。 用数学建模预测人口增长的方法主要有差分方程、微分方程、回归分析、时间序列等，结合题目、搜索到的数据以及《常微分方程》课本中所学知识，本小组以微分方程形式表示的改进指数增长模型、logistic模型为基础，以时间序列模型为拓展课题，建立以时间为自变量的印度人口增长模型。利用历史数据带入模型求解并做出预测。 ","date":"2021-06-27","objectID":"/28/:2:0","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"代码 ","date":"2021-06-27","objectID":"/28/:3:0","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"改进指数增长模型 %改进的指数增长模型 data=csvread('data.csv',1,0); x=data(:,2)'; real_rate=data(:,3)*0.01; n=length(x); t=0:1:n-1; rk=zeros(1,n); rk(1)=(-3*x(1)+4*x(2)-x(3))/2; rk(n)=(x(n-2)-4*x(n-1)+3*x(n))/2; for i=2:n-1 rk(i)=(x(i+1)-x(i-1))/2; end rk=rk./x; p=polyfit(t,rk,2); r0=p(1); r1=p(2); r2=p(3); x0=x(1); R=r0*t.^2+r1*t+r2; X=x0*exp((r0*t.^3)/3+(r1*t.^2)/2+r2*t); figure(1) hold on; xlabel('year'); %设置横坐标名 ylabel('rate'); %设置纵坐标名 grid on %网格线 plot(t,real_rate,'r*') title('印度人口的年增长率') figure(2) hold on; xlabel('year'); %设置横坐标名 ylabel('population'); %设置纵坐标名 grid on %网格线 plot(t,x,'r*',t,X) title('改进的指数模型拟合的人口') figure(3) hold on; xlabel('year'); %设置横坐标名 ylabel('rate'); %设置纵坐标名 grid on %网格线 plot(t,real_rate,'r*',t,R') title('改进的指数模型拟合的增长率') t1=t(59)+1; y2019=x0*exp((r0*t1.^3)/3+(r1*t1.^2)/2+r2*t1) rate2019=r0*t1.^2+r1*t1+r2 ","date":"2021-06-27","objectID":"/28/:3:1","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"logistic模型 % 线性最小二乘法拟合 data=csvread('data.csv',1,0); x=data(:,2)'; real_rate=data(:,3)*0.01; n=length(x); t=0:1:n-1; rk=zeros(1,n); rk(1)=(-3*x(1)+4*x(2)-x(3))/2; rk(n)=(x(n-2)-4*x(n-1)+3*x(n))/2; for i=2:n-1 rk(i)=(x(i+1)-x(i-1))/2; end rk=rk./x; p=polyfit(t,rk,1);%一阶拟合 b=p(1); a=p(2); r=a; xm=-r/b; x0=x(1); for i=1:n X(i)=xm/(1+((xm/x0)-1)*exp(-r*t(i)));%各个年份的预测人口总数 end figure(1) hold on; xlabel('year'); %设置横坐标名 ylabel('population'); %设置纵坐标名 grid on %网格线 plot(t,x,'r*',t,X) title('线性最小二乘法模型拟合的人口') figure(2) hold on; xlabel('year'); %设置横坐标名 ylabel('rate'); %设置纵坐标名 grid on %网格线 plot(t,real_rate,'r*',t,b*t+a) title('线性最小二乘法模型拟合的增长率') %非线性最小二乘法拟合： functionf=logistic_fun(a,t)f=a(1)./(1+(a(1)/3.9-1)*exp(-a(2)*(t))); end clc; clear all; data=csvread('data.csv',1,0); x=data(:,2)'*(10^(-8)); real_rate=data(:,3)*0.01; n=length(x); t=0:1:58; a0=[100,7.6]; %初值 plot(t,x,'*',t,x); %画点，并且画一条直线把各点连起来 hold on; %最重要的函数，第1个参数是函数名(一个同名的m文件定义)，第2个参数是初值，第3、4个参数是已知数据点 a=lsqcurvefit('logistic_fun',a0,t, x); disp([' a=' num2str(a)]); %显示结果 %画图检验结果 ti=0:1:59; xi=logistic_fun(a,ti); xlabel('year'); %设置横坐标名 ylabel('population'); %设置纵坐标名 plot(ti,xi,'r'); %预测2019 t2019=59; x2019=logistic_fun(a,t2019) title('非线性最小二乘法模型拟合的人口') ","date":"2021-06-27","objectID":"/28/:3:2","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"时间序列模型 Y=[1038058156,1056575549,1075000085,1093317189,1111523144,1129623456,1147609927,1165486291,1183209472,1200669765,1217726215,1234288729,1265782790,1280846129,1295604184,1310152403,1324509589,1338658835,1352617328]; adf=adftest(Y'); kpss=kpsstest(Y'); Yd1=diff(Y'); adf1=adftest(Yd1); kpss1=kpsstest(Yd1); Yd2=diff(Yd1); adf2=adftest(Yd2); kpss2=kpsstest(Yd2); Yd3=diff(Yd2); adf3=adftest(Yd3); kpss3=kpsstest(Yd3); figure autocorr(Yd3); figure parcorr(Yd3); p=1; q=1; Mdl = arima(p, 3, q); EstMdl=estimate(Mdl,Yd3); [res,logL] = infer(EstMdl,Yd3); figure subplot(2,2,1) plot(res./sqrt(EstMdl.Variance)) title('Standardized Residuals') subplot(2,2,2),qqplot(res) subplot(2,2,3),autocorr(res) subplot(2,2,4),parcorr(res) [yF,yMSE]=forecast(EstMdl,1,'y0',Y'); UB=yF+1.96*sqrt(yMSE); LB=yF-1.96*sqrt(yMSE); data=Y';step=1; figure() plot(data,'Color',[.7,.7,.7]); hold on h1 = plot(length(data):length(data)+step,[data(end);LB],'r:','LineWidth',2); plot(length(data):length(data)+step,[data(end);UB],'r:','LineWidth',2) h2 = plot(length(data):length(data)+step,[data(end);yF],'k','LineWidth',2); legend([h1 h2],'95% ÖÃÐÅÇø¼ä','Ô¤²âÖµ',... 'Location','NorthWest') title('Forecast') hold off ","date":"2021-06-27","objectID":"/28/:3:3","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"时间序列预测 Y=[1.81,1.77,1.73,1.69,1.65,1.62,1.58,1.55,1.51,1.46,1.41,1.35,1.29,1.23,1.18,1.15,1.12,1.09,1.06,1.04]; adf=adftest(Y'); kpss=kpsstest(Y'); Yd1=diff(Y'); adf1=adftest(Yd1); kpss1=kpsstest(Yd1); Yd2=diff(Yd1); adf2=adftest(Yd2); kpss2=kpsstest(Yd2); figure autocorr(Yd2); figure parcorr(Yd2); p=1; q=1; Mdl = arima(p, 2, q); EstMdl=estimate(Mdl,Yd2); [res,logL] = infer(EstMdl,Yd2); figure subplot(2,2,1) plot(res./sqrt(EstMdl.Variance)) title('Standardized Residuals') subplot(2,2,2),qqplot(res) subplot(2,2,3),autocorr(res) subplot(2,2,4),parcorr(res) [yF,yMSE]=forecast(EstMdl,1,'y0',Y'); UB=yF+1.96*sqrt(yMSE); LB=yF-1.96*sqrt(yMSE); data=Y';step=1; figure() plot(data,'Color',[.7,.7,.7]); hold on h1 = plot(length(data):length(data)+step,[data(end);LB],'r:','LineWidth',2); plot(length(data):length(data)+step,[data(end);UB],'r:','LineWidth',2) h2 = plot(length(data):length(data)+step,[data(end);yF],'k','LineWidth',2); legend([h1 h2],'95% ÖÃÐÅÇø¼ä','Ô¤²âÖµ',... 'Location','NorthWest') title('Forecast') hold off ","date":"2021-06-27","objectID":"/28/:3:4","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["数学建模"],"content":"总结 改进的指数增长模型和时间序列的拟合效果较好。 完整文档详见：博客相关资源-常微分项目文件 ","date":"2021-06-27","objectID":"/28/:3:5","tags":["matlab","数学建模"],"title":"基于常微分及时间序列模型的印度人口增长预测","uri":"/28/"},{"categories":["C++","数据结构"],"content":"前言 感谢组员的共同协作。 ","date":"2021-06-25","objectID":"/27/:1:0","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"题目背景 迷宫问题是取自心理学的一个古典实验。在该实验中，将一只老鼠放入一个无顶大盒子的门口处，在出口处放置一块奶酪，奶酪吸引老鼠在盒子中寻找出口。对同一只老鼠进行反复实验，最终老鼠学会走通迷宫路线并不走错一步。 ","date":"2021-06-25","objectID":"/27/:1:1","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"题目重述 “迷宫求解”是指在规定的迷宫中寻找从入口到出口路径的问题。即从入口出发，顺着某一方向向前探索，若能走通，则继续向前走；否则沿原路退回，换一个方向继续探索，直到探索到所有可能连通的路径为止。 ","date":"2021-06-25","objectID":"/27/:1:2","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"题目分析 解决迷宫问题，首先需要利用一种方式，如二维数组将其存储起来。由于计算机解迷宫时，常用的是“穷举求解”的办法，即从入口出发，顺某一方向向前探索，若能走通，则继续往前走；否则沿原路返回，换一个方向继续探索，直至所有可能的通路都探索为止。为了保证在任何位置上都能按原路返回，显然需要用一个后进先出的结构来保存从入口到当前位置的路径。 ","date":"2021-06-25","objectID":"/27/:1:3","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"算法设计 （1）回溯法 （2）基于深度遍历的算法 （3）基于广度遍历的算法 （4）转换为图的图论算法 ","date":"2021-06-25","objectID":"/27/:1:4","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"整体代码 ","date":"2021-06-25","objectID":"/27/:2:0","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"回溯法-顺序栈 #include\u003cstdlib.h\u003e#include\u003cstdio.h\u003e#include\u003ciostream\u003eusing namespace std; #define RANGE 4 #define row 4 #define col 4 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVER_FLOW -2 typedef int Status; typedef int DirectiveType; //位置坐标 typedef struct { int x, y;//表示迷宫中的位置信息x行y列 }PostType; //迷宫类型 typedef struct { int map[row + 2][col + 2];//用户输入矩阵（0，1）表示迷宫的初始生成 char arr[RANGE + 2][RANGE + 2];//程序的输入矩阵，以字符“@# ”表示探索状态 }MazeType; //栈类型 typedef struct { int step;//当前位置在路径上的“序号” PostType seat;//当前位置坐标 DirectiveType di;//往下一坐标位置的方向 }ElemType;//栈元素类型 typedef struct { ElemType* base; ElemType* top; int stacksize; }Stack;//利用顺序栈实现 Status InitStack(Stack\u0026 S) { S.base = new ElemType[100]; if (!S.base) exit(OVER_FLOW); S.top = S.base; S.stacksize = 100; return OK; } Status StackEmpty(Stack S) { if (S.top == S.base) return OK; else return ERROR; } Status Push(Stack\u0026 S, ElemType e) { if (S.top - S.base \u003e= S.stacksize) { ElemType* newbase = (ElemType*)realloc(S.base, (S.stacksize + 10) * sizeof(ElemType)); if (!newbase) exit(OVER_FLOW); S.base = newbase; S.top = S.base + S.stacksize; S.stacksize += 10; } *S.top++ = e; return OK; } Status Pop(Stack\u0026 S, ElemType\u0026 e) { if (S.top == S.base) return ERROR; e = *--S.top; return OK; } void InitMaze(MazeType\u0026 maze) { for (int i = 0; i \u003c row + 2; i++) { for (int j = 0; j \u003c col + 2; j++) { if (i == 0 || j == 0 || i == row + 1 || j == col + 1) { maze.map[i][j] = 0; maze.arr[i][j] = '#'; } else { cout \u003c\u003c \"第\" \u003c\u003c i \u003c\u003c \"行\" \u003c\u003c \"第\" \u003c\u003c j \u003c\u003c \"列：\"; cin \u003e\u003e maze.map[i][j]; if (maze.map[i][j] == 1) maze.arr[i][j] = '#'; else maze.arr[i][j] = ' '; } } } } Status Pass(MazeType maze, PostType curpos) {//判断格子是否走过且能走 if (maze.arr[curpos.x][curpos.y] == ' ') return OK; return ERROR; } Status FootPrint(MazeType\u0026 maze, PostType curpos) {//记录走过的格子 if (maze.arr[curpos.x][curpos.y] == ' ') { maze.arr[curpos.x][curpos.y] = '*'; return OK; } return ERROR; } Status Same(PostType curpos, PostType end) {//判断两个格子位置是否一样 if (curpos.x == end.x \u0026\u0026 curpos.y == end.y) return OK; return ERROR; } PostType NextPos(PostType curpos, int di) { switch (di) { case 1: {curpos.y = curpos.y + 1; return curpos; break; }//向右移动一格 case 2: {curpos.x = curpos.x + 1; return curpos; break; }//向下移动一格 case 3: {curpos.y = curpos.y - 1; return curpos; break; }//向左移动一格 case 4: {curpos.x = curpos.x - 1; return curpos; break; }//向上移动一格 } } Status MarkPrint(MazeType\u0026 maze, PostType pos) { maze.arr[pos.x][pos.y] = '@'; return OK; } Status MazePath(MazeType\u0026 maze, PostType start, PostType end) { Stack S; InitStack(S); PostType curpos = start;//设定“当前位置”为“入口位置” int curstep = 1;//探索第一步,记录探索步数 bool found = ERROR;//判断是否达到终点 ElemType e;//Stack元素 do { if (Pass(maze, curpos)) { //当前位置可以通过，即是未曾走到过的通道留下足迹 FootPrint(maze, curpos); e.di = 1; e.seat = curpos; e.step = curstep; Push(S, e);//加入路径 if (Same(curpos, end)) found = OK; //到达终点（出口） else { curpos = NextPos(curpos, 1);//下一位置是当前位置的东邻（向右移动一格） //NextPos(curpos, 1); curstep++;//探索下一步 } } else {//当前位置不能通过 if (!StackEmpty(S)) { Pop(S, e);//将刚才不能前进的Stack元素出栈，相当于退回一步 while (e.di == 4 \u0026\u0026 !StackEmpty(S)) { MarkPrint(maze, e.seat);//对刚才出栈的元素的位置标记 Pop(S, e);//下一个元素出栈，与上一步的e不一样 } if (e.di \u003c 4) { e.di++; Push(S, e);//换下一个方向探索 curpos = NextPos(e.seat, e.di);//设定当前位置是该新方向向上 } } } } while (!StackEmpty(S) \u0026\u0026 !found); return found; } Status PrintMaze(MazeType maze) { for (int i = 0; i \u003c RANGE + 2; i++) { for (int j = 0; j \u003c RANGE + 2; j++) { cout \u003c\u003c maze.arr[i][j] \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return OK; } int main() { MazeType maze; InitMaze(maze); cout \u003c\u003c \"生成的迷宫为：\" \u003c\u003c endl; PrintMaze(maze); PostType start, end; cout \u003c\u003c \"请输入起点：\"; cin \u003e\u003e start.x \u003e\u003e start.y; cout \u003c\u003c \"请输入终点：\"; cin \u003e\u003e end.x \u003e\u003e end.y; if (MazePath(maze, start, end)) { cout \u003c\u003c \"路径存在，迷宫求解路径为：\" \u003c\u003c endl; PrintMaze(maze); } else { cout \u003c\u003c \"路径不存在，迷宫求解路径为：\" \u003c\u003c endl; PrintMaze(maze); } return 0; } ","date":"2021-06-25","objectID":"/27/:2:1","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"回溯法—链栈 只有结构体定义与顺序栈不同，其他程序均相同 typedef int Status; typedef int DirectiveType; //位置坐标 typedef struct { int x, y;//表示迷宫中的位置信息x行y列 }PostType; //迷宫类型 typedef struct { int map[row+2][col+2];//用户输入矩阵（0，1）表示迷宫的初始生成 char arr[RANGE+2][RANGE+2];//程序的输入矩阵，以字符“@# ”表示探索状态 }MazeType; //栈类型 typedef struct { int step;//当前位置在路径上的“序号” PostType seat;//当前位置坐标 DirectiveType di;//往下一坐标位置的方向 }ElemType;//栈元素类型 typedef struct StackNode{ ElemType data; struct StackNode * next; }StackNode, * LinkStack;//节点类型，指针类型 ### 深度优先搜索遍历法 ```C++ //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8#include\u003cstdlib.h\u003e#include\u003cstdio.h\u003e#include\u003ciostream\u003e#define M 4 #define N 4 #define MaxSize M * N #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVER_FLOW -2 using namespace std; typedef int Status; typedef struct { int map[M + 2][N + 2];//用户输入矩阵（0，1）表示迷宫的初始生成 }MazeType; //初始化迷宫 void InitMaze(MazeType\u0026maze) { for (int i = 0; i \u003c M + 2; i++) { for (int j = 0; j \u003c N + 2; j++) { if (i == 0 || j == 0 || i == M + 1 || j == N + 1) { maze.map[i][j] = 1; } else { cout \u003c\u003c \"第\" \u003c\u003c i \u003c\u003c \"行\" \u003c\u003c \"第\" \u003c\u003c j \u003c\u003c \"列：\"; cin \u003e\u003e maze.map[i][j]; } } } } //x与y的增量 typedef struct { int incX,incY; }Direction; //位置 typedef struct{ int x,y; //当前坐标 int di; //当前方向 }Box; //栈 typedef struct { Box data[MaxSize]; int top; }SqStack; //初始化栈 void InitStack(SqStack \u0026S) { S=*(SqStack *)malloc(sizeof(SqStack)); S.top=0; } //四个方向增量初始化 void Init(Direction direct[]) { //右 direct[0].incX = 0; direct[0].incY = 1; //下 direct[1].incX = 1; direct[1].incY = 0; //左 direct[2].incX = 0; direct[2].incY = -1; //上 direct[3].incX = -1; direct[3].incY = 0; } //判栈空 Status StackEmpty(SqStack \u0026S) { if(S.top==0) { return OK;//栈空返回真 } else { return ERROR; } } //入栈 void Push(SqStack \u0026S,Box e) { if(S.top==MaxSize) { printf(\"入栈失败！\\n\"); } S.data[S.top]=e; S.top++; } //出栈 Box Pop(SqStack \u0026S) { Box e; S.top--; e = S.data[S.top]; return e; } //销毁 void Destroy(SqStack \u0026S) { free(\u0026S); cout\u003c\u003c\"栈已销毁！\"\u003c\u003cendl; } //寻找路径 Status findPath(int maze[][N + 2],Direction direct[], SqStack \u0026S) { Box temp; int x, y, di; int L, C; maze[1][1] = -1; temp.x = 1; temp.y = 1; temp.di = -1; Push(S, temp);//将temp压入到堆栈 while (!StackEmpty(S))//当栈不空的时候 { temp = Pop(S); x = temp.x; y = temp.y; di = temp.di + 1; while (di \u003c 4) { L = x + direct[di].incX; C = y + direct[di].incY; if (maze[L][C] == 0) { temp.x = x; temp.y = y; temp.di = di; Push(S, temp); x = L; y = C; maze[L][C] = -1; if (x == M \u0026\u0026 y == N) { return OK; } else { di = 0; } } else { di++; } } } return ERROR; } //打印创建的迷宫 Status PrintMaze(MazeType maze) { for (int i = 0; i \u003c M + 2; i++) { for (int j = 0; j \u003c N + 2; j++) { cout \u003c\u003c maze.map[i][j] \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return OK; } //画路径 Status printPath(MazeType maze,Box path[], int count) { //描绘路径 for(int i = count-1; i \u003e= 0; i--) { int x = path[i].x; int y = path[i].y; maze.map[x][y] = 9; } maze.map[M][N] = 9; PrintMaze(maze); return OK; } int main() { //显示中文 SetConsoleOutputCP(65001); cout \u003c\u003c \"迷宫只能从左上角开始走到右下角\" \u003c\u003c endl; MazeType MAZE; InitMaze(MAZE); MazeType* result = new MazeType(MAZE); cout \u003c\u003c \"生成的迷宫为：\" \u003c\u003c endl; PrintMaze(MAZE); cout\u003c\u003cendl; cout \u003c\u003c \"找到通路的迷宫为(以9表示找到的路径)：\" \u003c\u003c endl; Direction direct[4];//初始化方向结构体 Init(direct);//初始化方向结构体 SqStack S; InitStack(S); StackEmpty(S); Box path[MaxSize]; if(findPath(MAZE.map, direct, S)) { int count = 0; for(int i = 0; !StackEmpty(S); i++) { path[i] = Pop(S); count++; } printPath(*result,path,count); Destroy(S); } else { cout\u003c\u003c\"迷宫没有通路\"\u003c\u003cendl; } system(\"pause\"); return 0; } ","date":"2021-06-25","objectID":"/27/:2:2","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++","数据结构"],"content":"广度优先搜索遍历法 解法一 #include \u003ciostream\u003eusing namespace std; #define nRow 100 #define nCol 100 struct note // 队列中的元素类型 { int x; int y; }; // 地图 int ROW_NUM, COL_NUM; int nMatrix[nRow][nCol] = { 0 }; int flag[100][100] = { 0 }; // 标记是否走过的路 int head = 0; // 队列的头部索引 int tail = 0; // 队列的尾部索引 // 方向 int direction[4][2] = { 0, 1, 1, 0, 0, -1, -1, 0 }; struct note que[10000]; // 队列 int main() { for (int i = 0; i \u003c 100; i++) for (int j = 0; j \u003c 100; j++) flag[i][j] = 1; cout \u003c\u003c \"你想要构造迷宫的长度为:\" \u003c\u003c endl; cin \u003e\u003e ROW_NUM; cout \u003c\u003c \"你想要构造迷宫的宽度为：\" \u003c\u003c endl; cin \u003e\u003e COL_NUM; cout \u003c\u003c \"以0为通路，以非零实数，如1为墙壁，构造你想要的迷宫：\" \u003c\u003c endl; int m = 1; for (int i = 0; i \u003c ROW_NUM; i++) { cout \u003c\u003c \"请输入第\" \u003c\u003c m \u003c\u003c \"行的数字\" \u003c\u003c endl; for (int j = 0; j \u003c COL_NUM; j++) { cin \u003e\u003e nMatrix[i][j]; flag[i][j] = 0; } if (m \u003c ROW_NUM) { m++; } } cout \u003c\u003c \"你构造的迷宫为：\" \u003c\u003c endl; for (int i = 0; i \u003c ROW_NUM; i++) { for (int j = 0; j \u003c COL_NUM; j++) { if (nMatrix[i][j] == 0) cout \u003c\u003c \" \"; else cout \u003c\u003c \"[ ]\"; } cout \u003c\u003c endl; }// 输出二维迷宫图 // 初始化每一个队列元素的值（开始寻找的地方） que[head].x = que[head].y = 0; tail++; // 尾部索引 + 1 flag[0][0] = 1; // 标记初始位置已经查找过了 cout \u003c\u003c \"它走过的路径为：\" \u003c\u003c endl; cout \u003c\u003c \"(0,0)\" \u003c\u003c endl; while (head \u003c tail) { int i = 0; for (; i \u003c ROW_NUM; i++) { // 每次都是以队头为单位向四个方向开始 int nx = que[head].x + direction[i][0]; int ny = que[head].y + direction[i][1]; if (nx \u003c 0 || nx \u003e ROW_NUM || ny \u003c 0 || ny \u003e COL_NUM) continue; if (nMatrix[nx][ny] == 0 \u0026\u0026 flag[nx][ny] == 0) { flag[nx][ny] = 1; que[tail].x = nx; // 加入队列 que[tail].y = ny; cout \u003c\u003c \"(\"\u003c\u003cque[tail].x \u003c\u003c\",\"\u003c\u003c que[tail].y\u003c\u003c\")\" \u003c\u003c endl; tail++; } } head++; } return 0; } 解法二 #include \u003cthread\u003e//多线程头文件#include\u003cWindows.h\u003e//用于窗口等待Sleep#include \u003ciostream\u003eusing namespace std; #define WAIT_TIME 1000//加载时间，越小越快 string* maze = NULL;//输入的迷宫 int maze_height = 0;//迷宫高度 int flag = 0;//结束标志 int aim_x = 0, aim_y = 0;//终点坐标 int** maze_road;//迷宫数组 int road_num = 0, road_num_flag = -1;//创建寻路线程次数，寻路线程次数标记 void printMap(); void findRoad(int x, int y, int direction); void continuePrintMap(); int main() { /*输入数据*/ cout \u003c\u003c \"迷宫高为：\"; cin \u003e\u003e maze_height; cout \u003c\u003c \"请输入迷宫（墙壁为#）：\" \u003c\u003c endl; maze = new string[maze_height]; for (int i = 0; i \u003c maze_height; i++) { cin \u003e\u003e maze[i]; } cout \u003c\u003c \"请输入迷宫终点(x,y)：\" \u003c\u003c endl; cin \u003e\u003e aim_x \u003e\u003e aim_y; /*构造迷宫数组*/ maze_road = new int* [maze_height]; if (maze_road) memset(maze_road, 0, sizeof(int*) * maze_height); for (int i = 0; i \u003c maze_height; i++) { maze_road[i] = new int[maze[i].size() + 1]; for (unsigned int j = 0; j \u003c maze[i].size() + 1; j++) { if (maze[i][j] != \u0026apos;#\u0026apos;) maze_road[i][j] = 0; else maze_road[i][j] = -1; } } /*打开多线程*/ system(\"cls\");//清屏 thread print_map(continuePrintMap); print_map.detach(); thread find_road(findRoad, 1, 1, 0); find_road.detach(); /*后续*/ while (1) { /*没找到路径不继续*/ if (flag == 1) break; } system(\"cls\"); printMap();//最终迷宫图 /*收尾删除*/ for (int i = 0; i \u003c maze_height; i++) { delete[] maze_road[i]; } if (maze_road) delete[] maze_road; maze_road = NULL; delete[] maze; maze = NULL; return 0; } /*多线程持续打印迷宫*/ void continuePrintMap() { while (1) { /*不再找了也停止（机器人全灭）*/ if (road_num_flag == road_num) { flag = 1; return; } /*找到位置就停止*/ if (flag == 1) return; printMap(); } } /*打印迷宫*/ void printMap() { /*光标移动到（0，0），不用cls因为会闪*/ road_num_flag = road_num; printf_s(\"\\33[0;0H\"); for (int i = 0; i \u003c maze_height; i++) { for (unsigned int j = 0; j \u003c maze[i].size(); j++) { if (maze_road[i][j] == -1) printf_s(\"%3c\", maze[i][j]);//打印墙 else printf_s(\"%3d\", maze_road[i][j]);//打印路 //if //(maze_road[i][j] == -2); //printf_s(\"Y\"); } cout \u003c\u003c endl; } Sleep(WAIT_TIME); } /* 多线程迷宫寻路机器人 x 当前x坐标 y 当前y坐标 direction: 0 没有前一个位置 1 前一个位置在↑ 2 前一个位置在↓ 3 前一个位置在← 4 前一个位置在→ */ void findRoad(int x, int y, int direction) { Sleep(WAIT_TIME); road_num++; /**/ if (flag == 1)//寻路完成提前退出 return; /*记录此地距离原点距离*/ switch (direction) { case 1: { maze_road[x][y] = maze_road[x - 1][y] + 1; break; } case 2: { maze_road[x][y] = maze_road[x + 1][y] + 1; break; } case 3: { maze_road[x][y] = maze_road[x][y - 1] + 1; break; } case 4: { maze_road[x][y] = maze_road[x][y + 1] + 1; break; } de","date":"2021-06-25","objectID":"/27/:2:3","tags":["C++","数据结构"],"title":"多重算法实现的迷宫求解问题","uri":"/27/"},{"categories":["C++"],"content":"前言 感谢组员的共同协作。 ","date":"2021-06-20","objectID":"/26/:1:0","tags":["C++","数值逼近"],"title":"几种数值算法的简单分析","uri":"/26/"},{"categories":["C++"],"content":"四阶龙格-库塔公式计算微分方程数值解 #include\u003ciostream\u003e#include\u003ciomanip\u003eusing namespace std; double f(double t, double x, double y) { double dx; dx = x + 2 * y; return(dx); } double g(double t, double x, double y) { double dy; dy = 3 * x + 2 * y; return(dy); } void LG(double(*f)(double t, double x, double y), double(*g)(double t, double x, double y), double cz[3], double rs[3], double h) { double f1, f2, f3, f4, g1, g2, g3, g4, t0, x0, y0, x1, y1; t0 = cz[0]; x0 = cz[1]; y0 = cz[2]; f1 = f(t0, x0, y0); g1 = g(t0, x0, y0); f2 = f(t0 + h / 2, x0 + h * f1 / 2, y0 + h * g1 / 2); g2 = g(t0 + h / 2, x0 + h * f1 / 2, y0 + h * g1 / 2); f3 = f(t0 + h / 2, x0 + h * f2 / 2, y0 + h * g2 / 2); g3 = g(t0 + h / 2, x0 + h * f2 / 2, y0 + h * g2 / 2); f4 = f(t0 + h, x0 + h * f3, y0 + h * g3); g4 = f(t0 + h, x0 + h * f3, y0 + h * g3); x1 = x0 + h * (f1 + 2 * f2 + 2 * g3 + g4) / 6; y1 = y0 + h * (g1 + 2 * g2 + 2 * g3 + g4) / 6; rs[0] = t0 + h; rs[1] = x1; rs[2] = y1; } int main() { double cz[3], rs[3]; double a, b, S; double t, step; int i; cout \u003c\u003c \"输入微分方程的初值:\"; cin \u003e\u003e cz[0] \u003e\u003e cz[1] \u003e\u003e cz[2]; cout \u003c\u003c \"输入所求微分方程组的微分区间[a,b]:\"; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c \"输入所求微分方程组所分解子区间的个数:\"; cin \u003e\u003e step; S = (b - a) / step; cout \u003c\u003c cz[0] \u003c\u003c setw(10) \u003c\u003c cz[1] \u003c\u003c setw(10) \u003c\u003c cz[2] \u003c\u003c endl; for (i = 0; i \u003c step; i++) { LG(f, g, cz, rs, S); cout \u003c\u003c rs[0] \u003c\u003c setw(10) \u003c\u003c rs[1] \u003c\u003c setw(10) \u003c\u003c rs[2] \u003c\u003c endl; cz[0] = rs[0]; cz[1] = rs[1]; cz[2] = rs[2]; } system(\"pause\"); return 0; } ","date":"2021-06-20","objectID":"/26/:2:0","tags":["C++","数值逼近"],"title":"几种数值算法的简单分析","uri":"/26/"},{"categories":["C++"],"content":"龙贝格公式计算积分值 #include\u003ciostream\u003e#include\u003cmath.h\u003e#define N 20 //区间等分份数 #define MAX 10 #define a 0 #define b 1 #define f(x) (sin(x)) //函数 #define epsilon 0.0001 //有效数字 using namespace std; double Romberg(double aa,double bb,long int n) { int i; double sum,h=(bb-aa)/n; sum = 0; for(i=1;i\u003cn;i++) { sum=sum+f(aa+i*h); } sum = sum + (f(aa)+f(bb))/2; return (h*sum); } int main() { int i; long int n=N, m=0; double T[2][MAX+1]; T[1][0]=Romberg (a, b,n) ; n=n*2; for (m=1;m\u003cMAX;m++) { for(i=0;i\u003c=m;i++) { T [0][i]=T[1][i]; } T[1][0]=Romberg(a, b, n) ; n=n*2; for(i=1;i\u003c=m;i++) { T[1][i]=T[1][i-1]+(T[1][i-1]-T[0] [i-1])/(pow (2, 2*m)-1); } if ((T[0][m-1]-T[1] [m]) \u003cepsilon) { cout\u003c\u003c\"T=\"\u003c\u003cT[1] [m]\u003c\u003cendl; } system(\"pause\"); return 0; } } ","date":"2021-06-20","objectID":"/26/:3:0","tags":["C++","数值逼近"],"title":"几种数值算法的简单分析","uri":"/26/"},{"categories":["C++"],"content":"利用二分法寻找函数 #define _CRT_SECURE_NO_WARNINGS #include\u003ciostream\u003e#include\u003cmath.h\u003e#define eps 0.001 using namespace std; double fun(double x) { return x * sin(x) - 1; } double dichotomy(double a, double b) { double c = 0.0; if ((fun(a) \u003c 0) \u0026\u0026 (fun(b) \u003e 0)) { while (true) { c = (a + b) / 2; if (fun(c) \u003c 0) { a = c; if (fabs((a - b)) \u003c eps) { return (a + b) / 2; } } else if (fun(c) == 0) { return c; } else { b = c; if (fabs((a - b)) \u003c eps) { return (a + b) / 2; } } } } else { cout \u003c\u003c \"你输入的a和b不正确\" \u003c\u003c endl; return -1; } } int main() { double a = 0; double b = 2; double result = dichotomy(a, b); cout \u003c\u003c \"求解的结果是：\" \u003c\u003c result \u003c\u003c endl; system ( \"pause \"); return 0; } ","date":"2021-06-20","objectID":"/26/:4:0","tags":["C++","数值逼近"],"title":"几种数值算法的简单分析","uri":"/26/"},{"categories":["C++"],"content":"定期年金方程问题求解 #include\u003ciostream\u003e#include \u003cmath.h\u003eusing namespace std; int main() { int k = 1; long double p,p1,f,f1; cout\u003c\u003c\"输入初值p0=\"; cin\u003e\u003ep1; cout\u003c\u003cendl; while(true) { f = 500.0 - (pow(1.0+p1,20)-1.0)/p1; cout\u003c\u003c\"p=\"\u003c\u003cf\u003c\u003cendl; f1 = -(20.0*pow(1.0+p1,19)-pow(1.0+p1,20))/(p1*p1); cout\u003c\u003c\"p=\"\u003c\u003cf1\u003c\u003cendl; p=p1-f/f1; if(fabs(p-p1)\u003c1e-2) { break; } p1=p; k++; } cout\u003c\u003c\"p=\"\u003c\u003cp\u003c\u003cendl; cout\u003c\u003c\"k=\"\u003c\u003ck\u003c\u003cendl; system(\"pause\"); return 0; } 完整文档详见：博客相关资源-数值逼近课设文件 ","date":"2021-06-20","objectID":"/26/:5:0","tags":["C++","数值逼近"],"title":"几种数值算法的简单分析","uri":"/26/"},{"categories":["C++","数据结构"],"content":"题目 中序线索二叉链表的建立及遍历(数据结构严蔚敏C语言版的C++实现) 输入：字符串序列 输出：结点的相关信息，中序序列 处理方法: 1)在中序遍历过程中修改结点的左、右指针域，以保存当前访问结点的“前驱”和“后继”信息。 2)遍历过程中，附设指针pre, 并始终保持指针pre指向当前访问的指针p所指结点的前驱。 3)中序线索二叉树结构对称。其中：第一个结点是最左下的结点，最后一个结点是最右下的结点。 4)在中序线索二叉树上找结点的(直接)后继/前驱方法： a)若该结点有右孩子，其后继为其右子树中最左下的结点； b)若该结点无右孩子，其后继由rchild指向：其后继为满足以下条件的最小子树的根r：该结点为r的左子树中最右下的结点。 一、问题分析 线性链表中指向结点前驱和后继的指针，叫做线索，在线索二叉树上进行遍历，只要先找到序列的第一个结点，然后依次找结点的后继直到结点的后继为空时为止。 二、代码 对于问题三进行求解，设计了InThreaded函数，代码如下 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8#include \u003ciostream\u003eusing namespace std; typedef char dataType; typedef struct node { dataType data; //根节点的值 struct node* left; //左孩子 struct node* right; //右孩子 int ltag; //左标记，“ltag=0”表示当前节点有左孩子，“ltag=1”表示当前节点没有左孩子 int rtag; //右标记，“rtag=0”表示当前节点有右孩子，“rtag=1”表示当前节点没有右孩子 }BiTree; BiTree* creat() //二叉树的创建及初始化(初始化左右标记为0) { dataType value; BiTree* t; cin \u003e\u003e value; if (value == '#') { t = NULL; } else { t = new BiTree; t-\u003edata = value; t-\u003eltag = 0;//初始化左标记为0 t-\u003ertag = 0;//初始化右标记为0 cout\u003c\u003c\"请输入\"\u003c\u003ct-\u003edata\u003c\u003c\"的左子树: \"; t-\u003eleft = creat(); cout\u003c\u003c\"请输入\"\u003c\u003ct-\u003edata\u003c\u003c\"的右子树: \"; t-\u003eright = creat(); } return t; } //BiTree *pre=NULL; //1.定义全局变量pre void InThreaded(BiTree* p) { static BiTree* pre = NULL;//2.定义静态变量 if (p) { InThreaded(p-\u003eleft); if (!p-\u003eleft) { p-\u003eltag = 1; p-\u003eleft = pre; } if (pre \u0026\u0026 !pre-\u003eright) { pre-\u003ertag = 1; pre-\u003eright = p; } pre = p; InThreaded(p-\u003eright); } } BiTree* Next(BiTree* t) //已知节点t找t的\"后继\"结点位置 { if (t-\u003ertag == 1) //右标志为1，可以直接得到\"后继\"结点 { t = t-\u003eright; } else /*右标志为0，不能直接的到\"后继\"结点， 则需要找到右子树最左下角的节点*/ { t = t-\u003eright; while (t-\u003eltag == 0) { t = t-\u003eleft; } } return t; } BiTree* Prior(BiTree* t)//已知节点t找t的\"前驱\"结点位置 { if (t-\u003eltag == 1)//左标志为1，可以直接找到\"前驱\"结点的位置 { t = t-\u003eleft; } else /*右标志为0，不能直接的到\"前驱\"结点， 则需要找到左子树最右下角的节点*/ { t = t-\u003eleft; while (t-\u003ertag == 0) { t = t-\u003eright; } //while } //else return t; } void InorderTraverse(BiTree* t) { if (!t) { return; } while (t-\u003eltag == 0) { t = t-\u003eleft; } printf(\"%c \", t-\u003edata); while (t-\u003eright) { t = Next(t); printf(\"%c \", t-\u003edata); } } int main() { //显示中文 SetConsoleOutputCP(65001); BiTree* root; cout\u003c\u003c\"请以先序序列输入该树的根节点(以#替代空缺)：\"; root = creat(); cout \u003c\u003c endl; InThreaded(root); cout \u003c\u003c endl; printf(\"中序遍历:\"); InorderTraverse(root); cout \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2021-05-19","objectID":"/25/:0:0","tags":["C++","数据结构"],"title":"C++中序线索二叉链表的建立及遍历","uri":"/25/"},{"categories":["C++","数据结构"],"content":"题目 统计二叉树中叶子结点的个数，计算二叉树的深度(数据结构严蔚敏C语言版的C++实现) 输入：字符串序列 输出：叶子结点的个数，二叉树的深度 处理方法： 1)先序遍历二叉树。在遍历过程中查找叶子结点，并计数。由此，需在遍历算法中增添一个“计数”的参数，并将算法中“访问结点”的操作改为：若是叶子，则计数器增1。 2)后序遍历二叉树。从二叉树深度的定义可知，二叉树的深度应为其左、右子树深度的最大值加1。由此，先分别求得左、右子树的深度，算法中“访问结点”的操作为：求得左、右子树深度的最大值，然后加 1 。 一、问题分析 统计叶子结点的个数需要先序遍历二叉树，增加计数器和判断语句统计叶子节点数。 统计二叉树的深度需要后序遍历二叉树，求得左右两子树深度，判断最大值并加一输出。 二、代码 问题进行求解，分别设计了CountLeaf函数和 BiTreeDepth函数，代码如下 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8//函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //定义节点数 #define MAX_TREE_SIZE 100 #include\u003ciostream\u003eusing namespace std; typedef int Status; typedef char TElemType; //定义二叉树结构体 typedef struct BiTNode { TElemType data; struct BiTNode *lchild,*rchild; }BiTNode,*BiTree; //初始化二叉树 Status InitBiTree(BiTree T) { //含有头结点，头结点的左孩子指向树的根结点, //T为指向头结点的指针 if (!(T=new BiTNode)) { return ERROR; } T-\u003elchild=NULL; T-\u003erchild=NULL; return OK; } //销毁 Status DestroyBiTree(BiTree \u0026T) { if(!T) { return FALSE; } else { if (T-\u003elchild!=NULL) { DestroyBiTree(T-\u003elchild); } if (T-\u003erchild!=NULL ) { DestroyBiTree(T-\u003erchild); } delete T; return OK; } } //找根节点 BiTree Root(BiTree T) { if (T-\u003elchild==NULL) { return NULL; } return T-\u003elchild; } //清空 Status ClearBiTree (BiTree \u0026T) { BiTNode *p; p=T-\u003elchild; if (p) { DestroyBiTree(p); T-\u003elchild=NULL; T-\u003erchild=NULL; } return OK; } //查深度 int BiTreeDepth(BiTree T) { if(!T) { return 0; } else { int deepth = max(BiTreeDepth(T-\u003elchild),BiTreeDepth(T-\u003erchild))+1; return deepth;//空树会返回深度1 } } //打印函数 void visit(TElemType e) { cout\u003c\u003ce; } //先序遍历 void PreOrderTraverse(BiTree T, void(*visit)(TElemType)) { if (T) { visit(T-\u003edata); PreOrderTraverse(T-\u003elchild, visit); PreOrderTraverse(T-\u003erchild, visit); } } //中序遍历 void InOrderTraverse (BiTree T, void(*visit)(TElemType)) { if (T) { InOrderTraverse(T-\u003elchild, visit); visit(T-\u003edata); InOrderTraverse(T-\u003erchild, visit); } } //后序遍历 void PostOrderTraverse (BiTree T, void(*visit)(TElemType)) { if (T) { PostOrderTraverse(T-\u003elchild, visit); PostOrderTraverse(T-\u003erchild, visit); visit(T-\u003edata); } } //按先序创建二叉树 Status CreateBiTree(BiTree \u0026T) { char ch; char kg; scanf(\"%c\",\u0026ch); // 输入数据 kg=getchar(); // 空格 if(ch == '#') { //输入#代表此节点下子树不存数据，不继续递归创建 T = NULL; } else { if(!(T = (BiTNode *)malloc(sizeof(BiTNode)))) exit(OVERFLOW); T-\u003edata = ch; //把当前输入的数据存入当前节点指针的data中 cout\u003c\u003c\"请输入\"\u003c\u003cch\u003c\u003c\"的左子树: \"; CreateBiTree(T-\u003elchild); //递归创建左子树 cout\u003c\u003c\"请输入\"\u003c\u003cch\u003c\u003c\"的右子树: \"; CreateBiTree(T-\u003erchild); //到上一级节点的右边递归创建左右子树 } return OK; } //求叶子节点个数 void CountLeaf (BiTree T, int \u0026count) { if (T) { if ((!T-\u003elchild)\u0026\u0026(!T-\u003erchild)) count++; //对叶子结点计数 CountLeaf( T-\u003elchild, count); CountLeaf( T-\u003erchild, count); } } //查深度 //返回二叉树的深度, T为树根的指针 int BiTreeDepth(BiTree T) { int depthval; int depthLeft; int depthRight; if(!T) { depthval=0; } else { depthLeft = BiTreeDepth(T-\u003elchild); depthRight= BiTreeDepth(T-\u003erchild); depthval= 1+(depthLeft\u003edepthRight?depthLeft:depthRight); } return depthval; } //实验2 void test() { cout\u003c\u003c\"请以先序序列输入该树的树根节点(以#替代空缺)：\"; BiTree T; CreateBiTree(T); cout\u003c\u003c\"树的深度是\"\u003c\u003cBiTreeDepth(T)\u003c\u003cendl; int l = 0; CountLeaf(T,l); cout\u003c\u003c\"树的叶子节点个数为\"\u003c\u003cl\u003c\u003cendl; } int main() { //显示中文 SetConsoleOutputCP(65001); test(); system(\"pause\"); return 0; } ","date":"2021-05-17","objectID":"/24/:0:0","tags":["C++","数据结构"],"title":"C++二叉树中叶子结点的个数与深度的统计","uri":"/24/"},{"categories":["C++","数据结构"],"content":"题目 二叉链表的建立，先（中、后）序遍历(数据结构严蔚敏C语言版的C++实现) 输入：字符串序列 输出：先（中、后）序序列 处理方法：通过补虚结点，使二叉树中各实际结点均具有左右孩子，再对该二叉树按先序遍历进行输入。以字符串的形式:根、左子树、右子树定义一棵二叉树： 1)空树以空白字符‘#’表示 2)只含一个根结点的二叉树（图1示）以字符串‘A##’表示 3)一般的二叉树，以图2为例，以下列字符串表示：AB#C##D## 4)无论先序、中序、后序遍历二叉树，遍历时的搜索路线是相同的：从根节点出发，逆时针沿二叉树外缘移动，对每个节点均途经三次。 先序遍历：第一次经过节点时访问。 中序遍历：第二次经过节点时访问。 后序遍历：第三次经过节点时访问 一、问题分析 输入一个以#号补全虚节点，以先序序列输入，使用二叉链表结构创建二叉树，然后分别以先（中、后）序序列遍历输出，判断识别到#号递归遍历停止在虚节点处。 二、代码 对于问题进行求解，设计了CreateBiTree函数以及各序列的遍历函数，代码如下 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8//函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //定义节点数 #define MAX_TREE_SIZE 100 #include\u003ciostream\u003eusing namespace std; typedef int Status; typedef char TElemType; //定义二叉树结构体 typedef struct BiTNode { TElemType data; struct BiTNode *lchild,*rchild; }BiTNode,*BiTree; //初始化二叉树 Status InitBiTree(BiTree T) { //含有头结点，头结点的左孩子指向树的根结点, //T为指向头结点的指针 if (!(T=new BiTNode)) { return ERROR; } T-\u003elchild=NULL; T-\u003erchild=NULL; return OK; } //销毁 Status DestroyBiTree(BiTree \u0026T) { if(!T) { return FALSE; } else { if (T-\u003elchild!=NULL) { DestroyBiTree(T-\u003elchild); } if (T-\u003erchild!=NULL ) { DestroyBiTree(T-\u003erchild); } delete T; return OK; } } //找根节点 BiTree Root(BiTree T) { if (T-\u003elchild==NULL) { return NULL; } return T-\u003elchild; } //清空 Status ClearBiTree (BiTree \u0026T) { BiTNode *p; p=T-\u003elchild; if (p) { DestroyBiTree(p); T-\u003elchild=NULL; T-\u003erchild=NULL; } return OK; } //查深度 int BiTreeDepth(BiTree T) { if(!T) { return 0; } else { int deepth = max(BiTreeDepth(T-\u003elchild),BiTreeDepth(T-\u003erchild))+1; return deepth;//空树会返回深度1 } } //打印函数 void visit(TElemType e) { cout\u003c\u003ce; } //先序遍历 void PreOrderTraverse(BiTree T, void(*visit)(TElemType)) { if (T) { visit(T-\u003edata); PreOrderTraverse(T-\u003elchild, visit); PreOrderTraverse(T-\u003erchild, visit); } } //中序遍历 void InOrderTraverse (BiTree T, void(*visit)(TElemType)) { if (T) { InOrderTraverse(T-\u003elchild, visit); visit(T-\u003edata); InOrderTraverse(T-\u003erchild, visit); } } //后序遍历 void PostOrderTraverse (BiTree T, void(*visit)(TElemType)) { if (T) { PostOrderTraverse(T-\u003elchild, visit); PostOrderTraverse(T-\u003erchild, visit); visit(T-\u003edata); } } Status CreateBiTree(BiTree \u0026T) { char ch; char kg; scanf(\"%c\",\u0026ch); // 输入数据 kg=getchar(); // 空格 if(ch == '#') { //输入#代表此节点下子树不存数据，不继续递归创建 T = NULL; } else { if(!(T = (BiTNode *)malloc(sizeof(BiTNode)))) exit(OVERFLOW); T-\u003edata = ch; //把当前输入的数据存入当前节点指针的data中 cout\u003c\u003c\"请输入\"\u003c\u003cch\u003c\u003c\"的左子树: \"; CreateBiTree(T-\u003elchild); //递归创建左子树 cout\u003c\u003c\"请输入\"\u003c\u003cch\u003c\u003c\"的右子树: \"; CreateBiTree(T-\u003erchild); //到上一级节点的右边递归创建左右子树 } return OK; } //实验1 void test() { cout\u003c\u003c\"请以先序序列输入该树的树根节点(以#替代空缺)：\"; BiTree T; CreateBiTree(T); cout\u003c\u003c\"先序输出：\"\u003c\u003cendl; PreOrderTraverse(T,*visit); cout\u003c\u003cendl; cout\u003c\u003c\"中序输出：\"\u003c\u003cendl; InOrderTraverse(T,*visit); cout\u003c\u003cendl; cout\u003c\u003c\"后序输出：\"\u003c\u003cendl; PostOrderTraverse(T,*visit); cout\u003c\u003cendl; } int main() { //显示中文 SetConsoleOutputCP(65001); //AB#C##D## test(); system(\"pause\"); return 0; } ","date":"2021-05-16","objectID":"/23/:0:0","tags":["C++","数据结构"],"title":"C++二叉树的建立","uri":"/23/"},{"categories":["C++"],"content":"数值逼近 公元 1225 年，比萨的数学家 Leonardo（即 Fibonacci（斐波那契）），1170-1250）研究了方程 x^3+2*x^2+10*x-20=0 得到一个根 x* = 1.368 808 107，没有人知道他用什么方法得到这个值。对于这个方程，分别用下列方法： （1）迭代法式1 ； （2）迭代法式2 ； （3）对（1）的 Aitken 加速方法； （4）对（2）的 Aitken 加速方法； （5）Newton 法 。 求方程的根（可取 x0 = 1 ），计算到 Leonardo 所得到的准确度。 #include\u003cstdio.h\u003e#include\u003cmath.h\u003e//显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8#include\u003ciostream\u003eusing namespace std; #define phi01(x) 20/((x)*(x)+2*(x)+10)//迭代函数 #define phi02(x) (20-2*((x)*(x))-((x)*(x)*(x)))/10 #define f(x) ((x)*(x)*(x))+2*((x)*(x))+10*(x)-20 #define f1(x) 3*((x)*(x))+4*(x)+10 void test01() { int n=1,N; double x,x0,del; printf(\"x0 = 1\"); //scanf(\"%f\",\u0026x0); x0 = 1; printf(\"\\ndel = 0.000000001\"); //scanf(\"%f\",\u0026del); del = 0.000000001; printf(\"\\nN = 100\"); //scanf(\"%d\",\u0026N); N = 100; printf(\"\\nk x(k)\"); printf(\"\\n%2d %f\",0,x0); while (n\u003cN) { x = phi01(x0); if(fabs(x-x0)\u003cdel) { printf(\"\\n\\n迭代法式1的近似解 = %.9lf \\n\",x); return; } printf(\"\\n%2d %.9lf\",n,x0); n = n+1; x0 = x; } printf(\"\\n\\n%d次迭代后未达到精度要求.\\n\",N); } void test02() { int n=1,N; double x,x0,del; printf(\"x0 = 1\"); //scanf(\"%f\",\u0026x0); x0 = 1; printf(\"\\ndel = 0.000000001\"); //scanf(\"%f\",\u0026del); del = 0.000000001; printf(\"\\nN = 20\"); //scanf(\"%d\",\u0026N); N = 20; printf(\"\\nk x(k)\"); printf(\"\\n%2d %f\",0,x0); while (n\u003cN) { x = phi02(x0); if(fabs(x-x0)\u003cdel) { printf(\"\\n\\n迭代法式2的近似解 = %.9lf \\n\",x); return; } printf(\"\\n%2d %.9lf\",n,x0); n = n+1; x0 = x; } printf(\"\\n\\n%d次迭代后未达到精度要求.\\n\",N); } void Aitken01() { int n=1,N; double x0,x1,x2,x3,del; printf(\"x0 = 1\"); //scanf(\"%f\",\u0026x0); x0 = 1; printf(\"\\ndel = 0.000000001\"); //scanf(\"%f\",\u0026del); del = 0.000000001; printf(\"\\nN = 100\"); //scanf(\"%d\",\u0026N); N = 100; printf(\"\\nk x(k)\"); printf(\"\\n%2d %f\",0,x0); while (n\u003cN) { x1 = phi01(x0); x2 = phi01(x1); x3 = x2-(((x2-x1)*(x2-x1))/(x2-2*x1+x0)); if(fabs(x3-x0)\u003cdel) { printf(\"\\n\\n迭代法式1的Aitken近似解 = %.9lf \\n\",x3); return; } printf(\"\\nn = %2d x1 = %.9lf\",n,x3); n = n+1; x0 = x3; } printf(\"\\n\\n%d次迭代后未达到精度要求.\\n\",N); } void Aitken02() { int n=1,N; double x0,x1,x2,x3,del; printf(\"x0 = 1\"); //scanf(\"%f\",\u0026x0); x0 = 1; printf(\"\\ndel = 0.000000001\"); //scanf(\"%f\",\u0026del); del = 0.000000001; printf(\"\\nN = 100\"); //scanf(\"%d\",\u0026N); N = 100; printf(\"\\nk x(k)\"); printf(\"\\n%2d %f\",0,x0); while (n\u003cN) { x1 = phi02(x0); x2 = phi02(x1); x3 = x2-(((x2-x1)*(x2-x1))/(x2-2*x1+x0)); if(fabs(x3-x0)\u003cdel) { printf(\"\\n\\n迭代法式2的Aitken近似解 = %.9lf \\n\",x3); return; } printf(\"\\nn = %2d x1 = %.9lf\",n,x3); n = n+1; x0 = x3; } printf(\"\\n\\n%d次迭代后未达到精度要求.\\n\",N); } void Newton() { int n=1,N; double x,x0,del; printf(\"x0 = 1\"); //scanf(\"%f\",\u0026x0); x0 = 1; printf(\"\\ndel = 0.000000001\"); //scanf(\"%f\",\u0026del); del = 0.000000001; printf(\"\\nN = 100\"); //scanf(\"%d\",\u0026N); N = 100; printf(\"\\nk x(k)\"); printf(\"\\n%2d %f\",0,x0); while (n\u003cN) { float f_1 = f(x0); float f_2 = f1(x0); float d = f_1/f_2; x =x0 - d; if(fabs(x-x0)\u003cdel) { printf(\"\\n\\nNewton迭代法的近似解 = %.9lf \\n\",x); return; } printf(\"\\n%2d %.9lf\",n,x); n = n+1; x0 = x; } printf(\"\\n\\n%d次迭代后未达到精度要求.\\n\",N); } int main() { //显示中文 SetConsoleOutputCP(65001); test01(); cout\u003c\u003cendl; test02(); cout\u003c\u003cendl; Aitken01(); cout\u003c\u003cendl; Aitken02(); cout\u003c\u003cendl; Newton(); cout\u003c\u003cendl; system(\"pause\"); return 0; } ","date":"2021-05-15","objectID":"/22/:0:0","tags":["C++","数值逼近"],"title":"C++数值逼近-迭代法Aikten法以及牛顿法求解线性方程根通用程序","uri":"/22/"},{"categories":["python","数学建模"],"content":"新型冠状病毒（COVID-19/2019-nCoV）疫情分析 spiritLHL ","date":"2021-05-12","objectID":"/34/:0:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"重要说明 帮同一个选修课的学妹码的结课作业，这是我个人完善后的版本(她的还有很多错漏) 分析文档：完成度：代码质量 3:5:2 其中分析文档是指你数据分析的过程中，对各问题分析的思路、对结果的解释、说明(要求言简意赅，不要为写而写) ps:你自己写的代码远胜一切之代笔，无关美丑，只问今日比昨日更长进！加油！ ","date":"2021-05-12","objectID":"/34/:1:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"源文档 源文档详见：博客相关资源-新冠疫情数据分析文件 温馨提示： 疫情尚肆虐，请积极防护，保护自己 由于数据过多，查看数据尽量使用head()或tail()，以免程序长时间无响应 ======================= 本项目数据来源于丁香园。本项目主要目的是通过对疫情历史数据的分析研究，以更好的了解疫情与疫情的发展态势，为抗击疫情之决策提供数据支持。 ","date":"2021-05-12","objectID":"/34/:2:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"一. 提出问题 从全国范围，你所在省市，国外疫情等三个方面主要研究以下几个问题： （一）全国累计确诊/疑似/治愈/死亡情况随时间变化趋势如何？ （二）你所在的省市情况如何？ （三）全球疫情总体态势如何？ （四）结合你的分析结果，对未来半年的疫情趋势给出你的判断，对个人和社会在抗击疫情方面有何建议？ ","date":"2021-05-12","objectID":"/34/:3:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"二. 理解数据 原始数据集：AreaInfo.csv，导入相关包及读取数据，并赋值为 areas #导入需要的数据库和文件 import numpy as np import pandas as pd import matplotlib.pyplot as plt from matplotlib.pyplot import MultipleLocator areas=pd.read_csv(r'data/AreaInfo.csv') plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False r_hex = '#dc2624' # red, RGB = 220,38,36 dt_hex = '#2b4750' # dark teal, RGB = 43,71,80 tl_hex = '#45a0a2' # teal, RGB = 69,160,162 r1_hex = '#e87a59' # red, RGB = 232,122,89 tl1_hex = '#7dcaa9' # teal, RGB = 125,202,169 g_hex = '#649E7D' # green, RGB = 100,158,125 o_hex = '#dc8018' # orange, RGB = 220,128,24 tn_hex = '#C89F91' # tan, RGB = 200,159,145 g50_hex = '#6c6d6c' # grey-50, RGB = 108,109,108 bg_hex = '#4f6268' # blue grey, RGB = 79,98,104 g25_hex = '#c7cccf' # grey-25, RGB = 199,204,207 查看与统计数据，以对数据有一个大致了解 #数据过多，查看前几行 areas.head() \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rcontinentName\rcontinentEnglishName\rcountryName\rcountryEnglishName\rprovinceName\rprovinceEnglishName\rprovince_zipCode\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\rupdateTime\rcityName\rcityEnglishName\rcity_zipCode\rcity_confirmedCount\rcity_suspectedCount\rcity_curedCount\rcity_deadCount\r\r\r\r\r0\r亚洲\rAsia\r中国\rChina\r澳门\rMacau\r820000\r47\r9.0\r46\r0\r2021-01-22 23:40:08\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r1\r北美洲\rNorth America\r美国\rUnited States of America\r美国\rUnited States of America\r971002\r24632468\r0.0\r10845438\r410378\r2021-01-22 23:40:08\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r2\r南美洲\rSouth America\r巴西\rBrazil\r巴西\rBrazil\r973003\r8699814\r0.0\r7580741\r214228\r2021-01-22 23:40:08\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r3\r欧洲\rEurope\r比利时\rBelgium\r比利时\rBelgium\r961001\r686827\r0.0\r19239\r20620\r2021-01-22 23:40:08\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r4\r欧洲\rEurope\r俄罗斯\rRussia\r俄罗斯\rRussia\r964006\r3677352\r0.0\r3081536\r68412\r2021-01-22 23:40:08\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r\r\r相关字段含义介绍： 小提示： 国外数据的provinceName并非是省名，而是用其国家名标注，即数据不再细分到省。 中国数据的provinceName中也有’中国’这样的记录，代表当日全国各省之合计。善用之，对全国情况进行分析时就方便多了。 continentName介绍了哪些大洲参与统计；中国数据中有的给出了省名，有的是用“中国”标注，代表当日全国各省之合计；国外数据的provinceName并非是省名，而是用其国家名标注，即数据不再细分到省 province_suspectedCount一栏中有过多的缺失值，需填补或舍弃；数据中没有详细给到城市数据。 ","date":"2021-05-12","objectID":"/34/:4:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"三. 数据清洗 ","date":"2021-05-12","objectID":"/34/:5:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"（一）基本数据处理 数据清洗主要包括：选取子集，缺失数据处理、数据格式转换、异常值数据处理等。 提示：因数据皆赖各国上报，情势危杂之际，难免瞒报漏报，故存在较多缺失值，可以将其补全或舍弃，参见\"Pandas之缺失值的处理.ipynb\" 国内疫情数据选取（最终选取的数据命名为china） 选取国内疫情数据 对于更新时间(updateTime)列，需将其转换为日期类型并提取出年-月-日，并查看处理结果。(提示：dt.date) 因数据每天按小时更新，一天之内有很多重复数据，请去重并只保留一天之内最新的数据。 提示：df.drop_duplicates(subset=[‘provinceName’, ‘updateTime’], keep=‘first’, inplace=False) 其中df是你选择的国内疫情数据的DataFrame 去除不在此次研究范围内的列,只留下[‘continentName’,‘countryName’,‘provinceName’,‘province_confirmedCount’,‘province_suspectedCount’,‘province_curedCount’,‘province_deadCount’,‘updateTime’]这几列，并以’updateTime’为行索引。 提示：两种方法都可以：(1)选取这几列 或 (2)去除其余的列 # 此处给出代码，后面省市数据和全球数据的获取与此大同小异 china = areas.loc[areas.countryName=='中国',:].copy() china['updateTime'] = pd.to_datetime(china.updateTime,format=\"%Y-%m-%d\",errors='coerce').dt.date china = china.drop_duplicates(subset=['provinceName', 'updateTime'], keep='first', inplace=False) # 将\"字符类型的日期列(Index)\"转为\"时间戳索引(DatetimeIndex)\" china['updateTime'] = pd.to_datetime(china['updateTime']) china.set_index('updateTime',inplace=True) china = china[['continentName','countryName','provinceName','province_confirmedCount','province_suspectedCount','province_curedCount','province_deadCount']] china = china[china.provinceName=='中国'] china.head(2) \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rcontinentName\rcountryName\rprovinceName\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\r\r\rupdateTime\r\r\r\r\r\r\r\r\r\r\r\r2021-01-22\r亚洲\r中国\r中国\r99667\r0.0\r92275\r4810\r\r\r2021-01-21\r亚洲\r中国\r中国\r99513\r0.0\r92198\r4809\r\r\r\r\r china.index 查看数据信息，是否有缺失数据/数据类型是否正确。若有缺失值，可以将其补全或舍弃，参见**“Pandas之缺失值的处理.ipynb”** #有些城市不是每天上报，如果只统计那天上报的，那些不上报的就会被忽略，数据就会有错误,查看缺失值 #china.info() china.province_suspectedCount[china.province_suspectedCount.isnull()] = china.province_suspectedCount.dropna().mode().values china.head() \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rcontinentName\rcountryName\rprovinceName\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\r\r\rupdateTime\r\r\r\r\r\r\r\r\r\r\r\r2021-01-22\r亚洲\r中国\r中国\r99667\r0.0\r92275\r4810\r\r\r2021-01-21\r亚洲\r中国\r中国\r99513\r0.0\r92198\r4809\r\r\r2021-01-20\r亚洲\r中国\r中国\r99285\r0.0\r92130\r4808\r\r\r2021-01-19\r亚洲\r中国\r中国\r99094\r0.0\r92071\r4806\r\r\r2021-01-18\r亚洲\r中国\r中国\r98922\r0.0\r91994\r4805\r\r\r\r\r你所在省市疫情数据选取（最终选取的数据命名为myhome） 此步也可在后面用到的再做 选取所在省市疫情数据(细化到市；若是直辖市，细化到区) 对于更新时间(updateTime)列，需将其转换为日期类型并提取出年-月-日，并查看处理结果。(提示：dt.date) 因数据每天按小时更新，一天之内有很多重复数据，请去重并只保留一天之内最新的数据，并以’updateTime’为行索引。 提示：df.drop_duplicates(subset=[‘cityName’, ‘updateTime’], keep=‘first’, inplace=False) 去除不在此次研究范围内的列 提示：df.drop([‘continentName’,‘continentEnglishName’,‘countryName’,‘countryEnglishName’,‘provinceEnglishName’, ‘province_zipCode’,‘cityEnglishName’,‘updateTime’,‘city_zipCode’],axis=1,inplace=True) 其中df是你选择的省市疫情数据的DataFrame #首先选取相应内容，后转换为日期类型并提取出年-月-日，去重 myhome=areas.loc[areas.provinceName=='河北省',:].copy() myhome['updateTime'] = pd.to_datetime(myhome.updateTime,format=\"%Y-%m-%d\",errors='coerce').dt.date myhome.drop_duplicates(subset=['provinceName', 'updateTime'], keep='first', inplace=True) # 将\"字符类型的日期列(Index)\"转为\"时间戳索引(DatetimeIndex)\" myhome['updateTime']=pd.to_datetime(myhome['updateTime']) myhome.set_index('updateTime',inplace=True) #去除不在此次研究范围内的列 myhome.drop(['continentName','continentEnglishName','countryName','countryEnglishName','provinceEnglishName','province_zipCode','cityEnglishName','city_zipCode'],axis=1,inplace=True) myhome.head(2) \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rprovinceName\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\rcityName\rcity_confirmedCount\rcity_suspectedCount\rcity_curedCount\rcity_deadCount\r\r\rupdateTime\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r2021-01-22\r河北省\r1252\r0.0\r405\r7\r石家庄\r843.0\r0.0\r54.0\r1","date":"2021-05-12","objectID":"/34/:5:1","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"四. 数据分析及可视化 在进行数据分析及可视化时，依据每个问题选取所需变量并新建DataFrame再进行分析和可视化展示，这样数据不易乱且条理更清晰。 ","date":"2021-05-12","objectID":"/34/:6:0","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["python","数学建模"],"content":"基础分析 基础分析，只允许使用numpy、pandas和matplotlib库。 可以在一张图上多个坐标系展示也可以在多张图上展示 请根据分析目的选择图形的类型(折线图、饼图、直方图和散点图等等)，实在没有主意可以到百度疫情地图或其他疫情分析的站点激发激发灵感。 （一）全国累计确诊/治愈/死亡情况随时间变化趋势如何？ china.index #首先整合每天全国累计确诊/治愈/死亡情况做成新的列表 list_a=china['province_confirmedCount'] #遍历时间将其改为字符串形式 list_updatetime=[] for i in china.index: list_updatetime.append(str(i)[0:11]) updatetime_a=pd.DataFrame(list_a,index=list_updatetime) updatetime_a.index.name='updatetime' updatetime_a.columns=['province_confirmedCount'] updatetime_a.head() \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rprovince_confirmedCount\r\r\rupdatetime\r\r\r\r\r\r2021-01-22\r99667\r\r\r2021-01-21\r99513\r\r\r2021-01-20\r99285\r\r\r2021-01-19\r99094\r\r\r2021-01-18\r98922\r\r\r\r\r #画折线图表示 fig, axes = plt.subplots(1,1,figsize=(16, 4)) x=updatetime_a.index y=updatetime_a.values plot=axes.plot(x,y,color=dt_hex,linewidth=2,linestyle='-',label='province_confirmedCount') axes.set_xticks(range(0,len(x),25)) plt.xlabel('日期',fontsize=10) plt.ylabel('人数',fontsize=10) axes.legend(loc=0,frameon=True) plt.show() #重复以上步骤，绘制治愈/死亡的折线图 list_b=china['province_curedCount'] #遍历时间将其改为字符串形式 list_updatetime=[] for i in china.index: list_updatetime.append(str(i)[0:11]) updatetime_b=pd.DataFrame(list_b,index=list_updatetime) updatetime_b.index.name='updatetime' updatetime_b.columns=['province_curedCount'] updatetime_b.head() #画折线图表示 fig, axes = plt.subplots(1,1,figsize=(16, 4)) x=updatetime_b.index y=updatetime_b.values plot=axes.plot(x,y,color=dt_hex,linewidth=2,linestyle='-',label='province_curedCount') axes.set_xticks(range(0,len(x),25)) plt.xlabel('日期',fontsize=10) plt.ylabel('人数',fontsize=10) axes.legend(loc=0,frameon=True) plt.show() #绘制死亡人数图 list_c=china['province_deadCount'] #遍历时间将其改为字符串形式 list_updatetime=[] for i in china.index: list_updatetime.append(str(i)[0:11]) updatetime_c=pd.DataFrame(list_a,index=list_updatetime) updatetime_c.index.name='updatetime' updatetime_c.columns=['province_deadCount'] updatetime_c.head() #画折线图表示 fig, axes = plt.subplots(1,1,figsize=(16, 4)) x=updatetime_c.index y=updatetime_c.values plot=axes.plot(x,y,color=dt_hex,linewidth=2,linestyle='-',label='province_deadCount') axes.set_xticks(range(0,len(x),25)) plt.xlabel('日期',fontsize=10) plt.ylabel('人数',fontsize=10) axes.legend(loc=0,frameon=True) plt.show() #分析：确诊与死亡人数的折线图显示出人数在逐渐增加，增速有加快的趋势；治愈人数虽然也是再增加，但是增速逐渐变慢 第二幅图为 第三幅图为 （二）你所在的省市情况如何？ myhome \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rprovinceName\rprovince_confirmedCount\rprovince_suspectedCount\rprovince_curedCount\rprovince_deadCount\rcityName\rcity_confirmedCount\rcity_suspectedCount\rcity_curedCount\rcity_deadCount\r\r\rupdateTime\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r2021-01-22\r河北省\r1252\r0.0\r405\r7\r石家庄\r843.0\r0.0\r54.0\r1.0\r\r\r2021-01-21\r河北省\r1245\r0.0\r395\r7\r石家庄\r842.0\r0.0\r54.0\r1.0\r\r\r2021-01-20\r河北省\r1222\r0.0\r384\r7\r石家庄\r813.0\r0.0\r45.0\r1.0\r\r\r2021-01-19\r河北省\r1198\r0.0\r383\r7\r石家庄\r801.0\r0.0\r45.0\r1.0\r\r\r2021-01-18\r河北省\r1171\r0.0\r379\r7\r石家庄\r774.0\r0.0\r41.0\r1.0\r\r\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r...\r\r\r2020-01-27\r河北省\r18\r0.0\r0\r1\r石家庄\r7.0\r0.0\r0.0\r0.0\r\r\r2020-01-26\r河北省\r13\r0.0\r0\r1\r石家庄\r5.0\r0.0\r0.0\r0.0\r\r\r2020-01-25\r河北省\r8\r0.0\r0\r1\r石家庄\r4.0\r0.0\r0.0\r0.0\r\r\r2020-01-24\r河北省\r2\r0.0\r0\r1\r石家庄\r1.0\r0.0\r0.0\r0.0\r\r\r2020-01-22\r河北省\r1\r0.0\r0\r0\rNaN\rNaN\rNaN\rNaN\rNaN\r\r\r\r134 rows × 10 columns \r plt.figure( figsize=(20,10), dpi=80) list_updatetime=[] for i in myhome.index: list_updatetime.append(str(i)[0:11]) x = list_updatetime y1=myhome['province_confirmedCount'] y2=myhome['province_curedCount'] y3=myhome['province_deadCount'] plt.plot(x,y1,color=r_hex,label='province_confirmedCount') plt.plot(x,y2,color=tl_hex,label='province_curedCount') plt.plot(x,y3,color=g_hex,label='province_deadCount') x_major_locator = MultipleLocator(12) ax = plt.gca() ax.xaxis.set_major_locator(x_major_locator) plt.legend(loc=0,frameon=True) plt.show() （三）全球疫情态势如何？ 全球 TOP10 国家的疫情情况如何？ 各大洲情况对比？ 选一个你感兴趣的大洲，分","date":"2021-05-12","objectID":"/34/:6:1","tags":["python","数学建模"],"title":"2021新型冠状病毒（COVID-19/2019-nCoV）疫情分析","uri":"/34/"},{"categories":["C++"],"content":"数值逼近 用迭代法求非线性方程(x+1)^2-sinx-3=0的根。 取迭代函数0.5*(3+sin((x))-1-(x)*(x))，精度要求为1*10^-2，最多迭代 100 次。 #include\u003cstdio.h\u003e#include\u003cmath.h\u003e#define phi(x) 0.5*(3+sin((x))-1-(x)*(x)) //迭代函数 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8#include\u003ciostream\u003eusing namespace std; int main() { //显示中文 SetConsoleOutputCP(65001); int n=1,N; float x,x0,del; printf(\"x0 = \"); scanf(\"%f\",\u0026x0); printf(\"\\ndel = \"); scanf(\"%f\",\u0026del); printf(\"\\nN = \"); scanf(\"%d\",\u0026N); printf(\"\\nk x(k)\"); printf(\"\\n%2d %f\",0,x0); while (n\u003cN) { x = phi(x0); if(fabs(x-x0)\u003cdel) { printf(\"\\n\\n近似解 = %f \\n\",x); return 0; } printf(\"\\n%2d %f\",n,x0); n = n+1; x0 = x; } printf(\"\\n\\n%d次迭代后未达到精度要求.\\n\",N); system(\"pause\"); } ","date":"2021-04-26","objectID":"/21/:0:0","tags":["C++","数值逼近"],"title":"C++数值逼近-迭代法求非线性方程的根","uri":"/21/"},{"categories":["C++"],"content":"数值积分 取步长 h = 0.1 ，分别用 Euler 方法、改进 Euler 方法和经典四阶 Runge-Kutta 方法求解初值问题 f(x,y) = ((y)-2*(x)/(y)) f(0) = 0 并将计算结果与sqrt(1+2*(x))精确解相比较。 #include\u003cstdio.h\u003e#include\u003cmath.h\u003e#include\u003ciostream\u003e#define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8using namespace std; #define f(x,y) ((y)-2*(x)/(y)) #define y(x) sqrt(1+2*(x)) int main() { //显示中文 SetConsoleOutputCP(65001); float a = 0,b = 1.0f,h=0.1f,y0=1.0f,x,ye,yp,ym,k1,k2,k3,k4,yr,yx; printf(\"\\n精确解 Euler方法\"); printf(\" 改进Euler方法 4阶Runge-Kutta方法\"); printf(\"\\nx y ye[k] |ye[k]-y| \"); printf(\"ym[k] |ym[k]-y| yr[k] |yr[k]-y|\\n\"); printf(\"%3.1f %8.6f %8.6f %8.6f \",a,y0,y0,0); printf(\"%8.6f %8.6f %8.6f %8.6f \\n\",y0,0,y0,0.0); x=a; ye=y0; //Euler方法的初值 ym=y0; //改进的Euler方法的初值 yr=y0; //4阶Runge-Kutta方法的初值 while(x\u003cb) { ye = ye + h*f(x,ye); yp = ym + h*f(x,ym); ym = ym + h/2*(f(x,ym)+f(x+h,yp)); k1 = f(x,yr); k2 = f(x+h/2,yr+h/2*k1); k3 = f(x+h/2,yr+h/2*k2); k4 = f(x+h,yr+h*k3); yr = yr + h/6*(k1+2*k2+2*k3+k4); x = x + h; yx = y(x); printf(\"%3.1f %8.6f %8.6f %8.6f %8.6f %8.6f %8.6f %8.6f\\n\",x,yx,ye,fabs(ye-yx),ym,fabs(ym-yx),yr,fabs(yr-yx)); } system(\"pause\"); return 0; } ","date":"2021-04-25","objectID":"/20/:0:0","tags":["C++","数值逼近"],"title":"C++数值逼近-Euler方法、改进Euler方法和经典四阶Runge-Kutta方法求解初值问题","uri":"/20/"},{"categories":["C++"],"content":"数值逼近 将区间[0,1]四等分，分别用复化梯形公式和复化 Simpson 公式计算定积分 f(x) 4.0 / (1 + (x) * (x)) 的近似值。 #include\u003ciostream\u003eusing namespace std; #include\u003cstdio.h\u003e//显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8 #define f(x) 4.0 / (1 + (x) * (x)) void test() { float h = (1.0 - 0) / 4, temp, xk, yk, xkh, ykh, xk1, yk1; int i; temp = f(0); xk = 0; for (i = 1; i \u003c 4; i++) { xk = xk + h; temp = temp + 2 * f(xk); } temp = temp + f(1); temp = temp * h / 2; cout \u003c\u003c endl; cout \u003c\u003c \"复化梯形公式计算的结果：\" \u003c\u003c temp \u003c\u003c endl; temp = 0; h = (1.0 - 0) / 2; xk = 0; yk = f(0); for (i = 0; i \u003c 2; i++) { xkh = xk + h / 2; ykh = f(xkh); xk1 = xk + h; yk1 = f(xk1); temp = temp + h * (yk + 4 * ykh + yk1) / 6; xk = xk1; yk = yk1; } cout \u003c\u003c endl; cout \u003c\u003c \"复化 Simpson 公式计算的结果：\" \u003c\u003c temp \u003c\u003c endl; cout \u003c\u003c endl; } int main() { //显示中文 SetConsoleOutputCP(65001); test(); system(\"pause\"); return 0; } ","date":"2021-04-24","objectID":"/19/:0:0","tags":["C++","数值逼近"],"title":"C++数值逼近-复化梯形公式和复化 Simpson 公式计算定积分的近似值","uri":"/19/"},{"categories":["C++"],"content":"数值逼近 天安门广场升旗的时间是日出的时刻，而降旗的时间是日落时分。根据天安门广场管理委员会的公告，某年 10 月份升降旗的时间如下： 日期 1 15 22 升旗 6:09 6:23 6:31 降旗 17:58 17:36 17:26 请根据上述数据构造 Newton 插值多项式，并计算当年 10 月 8 日北京市的日照时长。 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8 #include\u003ciostream\u003e#include\u003cstdio.h\u003e#include\u003cmath.h\u003e#define n 3 //节点个数 #define f(x) 4.0/(1+(x)*(x)) using namespace std; //Newton插值多项式 void test01() { int i,j,xx,x[3] = {1,15,22}; float y[3] = {17-6+(58-9)/60.0,17-6+(36-23)/60.0,17-6+(26-31)/60.0}; float N[3][3],yy,temp; for(i=0;i\u003cn;i++) { N[i][0] = y[i]; //0阶差商 } for(j=1;j\u003cn;j++) { for(i=j;i\u003cn;i++) { N[i][j] = (N[i][j-1]-N[i-1][j-1])/(x[i]-x[i-j]); //构造差商 } } xx = 8; yy = 0.0; temp = 1.0; for(i=0;i\u003cn;i++) { yy = yy + N[i][i]*temp; temp = temp*(xx-x[i]); } printf(\"\\n这年10月%d日北京日照时长为%7.4f小时.\\n\",xx,yy); printf(\"即%d小时%3.0f分.\\n\",(int)floor(yy),60*fmod(yy,1.0)); } int main() { //显示中文 SetConsoleOutputCP(65001); test01(); system(\"pause\"); return 0; } ","date":"2021-04-23","objectID":"/18newton/:0:0","tags":["C++","数值逼近"],"title":"C++数值逼近-Newton插值法","uri":"/18newton/"},{"categories":["C++"],"content":"数值逼近 参考matlab程序：https://www.ilovematlab.cn/thread-450391-1-1.html 个人编写的c++版本如下 #include\u003ciostream\u003e#include\u003cstdio.h\u003e#include\u003cmath.h\u003e#include\u003ccmath\u003eusing namespace std; float X[10] = {0.10,0.15,0.30,0.45,0.55,0.60,0.70,0.85,0.90,1.00}; float Y[10] = {0.904837,0.860708,0.740818,0.637628,0.576950,0.548812,0.496585,0.427415,0.406570,0.367879}; float YY[10] = {-0.904837,-0.860708,-0.740818,-0.637628,-0.576950,-0.548812,-0.496585,-0.427415,-0.406570,-0.367879}; //#define f(x) e^(-x); float f(float x) { return exp(-x); } float Hermite(float *x, float *y, float *dy, int n, float t) { float result[10]; for(int i = 0;i\u003cn;i++) { float h = 1.0; float a = 0.0; for(int j = 0;j\u003cn;j++) { if(j!=i) { h = h*(pow(t-x[j],2))/(pow(x[i]-x[j],2)); a = a + 1/(x[i]-x[j]); } } result[i] = h*((x[i]-t)*(2*a*y[i]-dy[i])+y[i]); } float r = 0; for(int k = 0;k\u003cn;k++) { r = r + result[k]; } return r; } int main() { float t = 0.356; cout\u003c\u003cHermite(X, Y, YY, 10, t)\u003c\u003cendl; cout\u003c\u003cf(t)\u003c\u003cendl; return 0; } ","date":"2021-04-22","objectID":"/17hermit/:0:0","tags":["C++","数值逼近"],"title":"C++数值逼近-Hermite插值法通用程序","uri":"/17hermit/"},{"categories":["C++","数据结构"],"content":"题目 行编辑(数据结构严蔚敏C语言版的C++实现) 输入：一行有误的数据 输出：一行正确的数据 处理方法： 允许用户输入出差错，并在发现有误时及时更正。例如：可用一个退格符“#”表示前一个字符无效；可用一个退行符“@”表示当前行中的字符均无效。 步骤： 1）初始化栈S 2）读入字符ch 3）ch!=EOF 3.1) ch!=EOF \u0026\u0026 ch!=‘\\n’ 3.1.1)ch为‘#’：Pop(S, c),转3.1.4) 3.1.2)ch为‘@’：ClearStack (S),转3.1.4) 3.1.3)ch为其它： Push (S, ch),转3.1.4) 3.1.4)再读入字符ch,继续3.1) 3.2) 处理完一行,清空栈 3.3) 如ch!=EOF,读入字符ch,继续3) ","date":"2021-04-17","objectID":"/16/:0:0","tags":["C++","数据结构"],"title":"C++栈结构实现行编辑","uri":"/16/"},{"categories":["C++","数据结构"],"content":"一、问题分析 需要使用由char类型元素组成的栈，写一个LinkEdit函数对输入进行检索判断，遇到字符类型时判断一下需要进行的对应操作。 ","date":"2021-04-17","objectID":"/16/:1:0","tags":["C++","数据结构"],"title":"C++栈结构实现行编辑","uri":"/16/"},{"categories":["C++","数据结构"],"content":"二、代码 对于问题三进行求解，设计了LinkEdit函数，代码如下 //识别 void LinkEdit(SqStack\u0026 S) { char ch; SElemType e; ch = getchar(); while (ch != EOF \u0026\u0026 ch != '\\n') { switch (ch) { case '@': ClearStack(S); break; case '#': Pop(S, e); break; default: Push(S, ch); } ch = getchar(); } } ","date":"2021-04-17","objectID":"/16/:2:0","tags":["C++","数据结构"],"title":"C++栈结构实现行编辑","uri":"/16/"},{"categories":["C++","数据结构"],"content":"三、分析 这里使用一个新栈对输入后的结果进行输出，避免栈的“先进后出”的结构特点导致直接输出逆序。 ","date":"2021-04-17","objectID":"/16/:3:0","tags":["C++","数据结构"],"title":"C++栈结构实现行编辑","uri":"/16/"},{"categories":["C++","数据结构"],"content":"四、实验过程记录 这个程序我写了一个打印函数，上一个实验直接进行输出了，这个进行了遍历再输出。这个程序我使用了switch结构进行多次判断，这里的判断比较简单，判断后再进行入栈操作。 完整代码 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8#define OK 1 #define ERROR -1 #define OVERFLOW -2 #define TRUE 1 #define FALSE 0 #define STACK_INIT_SIZE 100 #define STACKINCREMENT 10 #define EOF -1 //C++中需要声明 #include \u003ccstdio\u003e#include \u003ccstdlib\u003e#include \u003ciostream\u003eusing namespace std; //定义数据类型 typedef char SElemType; typedef int status; //定义栈 typedef struct { SElemType* base; SElemType* top; int stacksize; }SqStack; //初始化 status InitStack(SqStack\u0026 S) { S.base = new SElemType[STACK_INIT_SIZE]; if (!S.base) return(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK; } //判栈空 status StackEmpty(SqStack S) { if (S.top == S.base) return TRUE; } //求栈长 status StackLength(SqStack S) { return S.top - S.base; } //求栈顶 status GetTop(SqStack S, SElemType\u0026 e) { if (S.top == S.base) return ERROR; e = *(S.top - 1); return OK; } //入栈 status Push(SqStack\u0026 S, SElemType e) { if (S.top - S.base \u003e= S.stacksize) { SElemType* newbase = (SElemType*)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType)); if (!newbase) return(OVERFLOW); S.base = newbase; S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } *S.top++ = e; return OK; } //出栈 status Pop(SqStack\u0026 S, SElemType\u0026 e) { if (S.top == S.base) return ERROR; e = *--S.top; return OK; } //清空栈 status ClearStack(SqStack\u0026 S) { S.top = S.base; S.stacksize = 0; return OK; } //销毁栈 status DestroyStack(SqStack\u0026 S) { S.top = S.base; free(S.base); S.base = NULL; S.top = NULL; return OK; } //遍历输出 status PrintStack(SqStack S) { SElemType* p = new SElemType[sizeof(SElemType)]; p = S.top; if (p == S.base) cout \u003c\u003c \"栈空\" \u003c\u003c endl; else { cout \u003c\u003c \"有效字符为：\" \u003c\u003c endl; p--; while (p != S.base - 1) { cout \u003c\u003c *p; p--; } } cout\u003c\u003cendl; return OK; } //识别判断 void LinkEdit(SqStack\u0026 S) { char ch; SElemType e; ch = getchar();//读取字符，读错误返回EOF while (ch != EOF \u0026\u0026 ch != '\\n')//EOF为全文结束符 { switch (ch) { case '@':// 重置S为空栈 ClearStack(S); break; case '#'://栈不空，退栈 Pop(S, e); break; default: Push(S, ch); } ch = getchar();//读取下一个字符 } } //实验6 void test() { SqStack S, Q; SElemType e;//中间变量 InitStack(S); InitStack(Q); while (true) { cout\u003c\u003c\"输入：\"\u003c\u003cendl; LinkEdit(S);//识别 while (StackLength(S))//如果识别判断后不空 { //正序输出转换 Pop(S, e); Push(Q, e); } PrintStack(Q); ClearStack(Q); } DestroyStack(S); DestroyStack(Q); } int main() { //显示中文 SetConsoleOutputCP(65001); //实验6 test(); system(\"pause\"); return 0; } ","date":"2021-04-17","objectID":"/16/:4:0","tags":["C++","数据结构"],"title":"C++栈结构实现行编辑","uri":"/16/"},{"categories":["C++","数据结构"],"content":"题目 括号匹配检验(数据结构严蔚敏C语言版的C++实现) 输入：一串括号 输出：检验结果（缺左括号、有多余左括号、左右不匹配、匹配成功） 处理方法： 检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述： 后出现的“左括弧”，它等待与其匹配的“右括弧”出现的“急迫”心情要比先出现的左括弧高。对“左括弧”来说，后出现的比先出现的“优先”等待检验。 对“右括弧”来说，每个出现的右括弧要去找在它之前“最后”出现的那个左括弧去匹配。显然，必须将先后出现的左括弧依次保存，为了反映这个优先程度，保存左括弧的结构用栈最合适。 对出现的右括弧来说，只要“栈顶元素”相匹配即可。如果在栈顶的那个左括弧正好和它匹配，就可将左括弧从栈顶删除。 步骤： 1）凡出现左括弧，则进栈； 2）凡出现右括弧，首先检查栈是否空 若栈空，则表明该“右括弧”多余， 否则和栈顶元素比较， 若相匹配，则“左括弧出栈”， 否则，表明不匹配。 3）表达式检验结束时， 若栈空，表明表达式中匹配正确， 否则，表明“左括弧”有余 ","date":"2021-04-15","objectID":"/15/:0:0","tags":["C++","数据结构"],"title":"C++栈结构实现括号匹配","uri":"/15/"},{"categories":["C++","数据结构"],"content":"一、问题分析 先对输入字符串进行遍历提取，将左括号入栈，遇到右括号，出栈一个左括号，判断是否出栈的是左括号，如果不是，缺一个左括号，如果是，判断左括号与右括号是否匹配。最后如果栈中还剩余括号，则证明有多余括号，不匹配。 ","date":"2021-04-15","objectID":"/15/:1:0","tags":["C++","数据结构"],"title":"C++栈结构实现括号匹配","uri":"/15/"},{"categories":["C++","数据结构"],"content":"二、代码 对于问题三进行求解，设计了match函数，代码如下 Status match(char *exp) { //检验表达式中所含括弧是否正确嵌套，若是则返回OK,否则返回ERROR SElemType left; SqStack S; InitStack(S); //初始化栈S char *p=exp; char ch = *p; //当字符串exp未扫描 while (ch != '#' ) { if(is_left(ch)) { Push(S,ch);//左括号进栈 } if(is_right(ch)) { Pop(S,left); if(!is_left(left) || left == *\"$\") { return FALSE; //缺左括号 } else if(!peidui(left,ch)) { return FALSE; //左右不匹配 } } p++; ch = *p; } if(!StackEmpty(S)) { return FALSE; //有多余的左括号 } else { return TRUE; } } ","date":"2021-04-15","objectID":"/15/:2:0","tags":["C++","数据结构"],"title":"C++栈结构实现括号匹配","uri":"/15/"},{"categories":["C++","数据结构"],"content":"三、分析 分析：缺一个左括号和缺一个右括号的情况都可以正常识别，这得益于先对左括号和右括号的分类，最后再进行匹配的检验的程序结构。 ","date":"2021-04-15","objectID":"/15/:3:0","tags":["C++","数据结构"],"title":"C++栈结构实现括号匹配","uri":"/15/"},{"categories":["C++","数据结构"],"content":"四、实验过程记录 刚看到题目的时候，我想着是使用switch对输入进行匹配检验，后来发现这需要嵌套比对，比较麻烦。后来看到老师对括号进行左括号右括号分类，找到了不需要嵌套比较的方法。最后有发现缺左括号情况栈已经空了，但是仍然匹配的情况，这里栈空后pop函数没有更新left值，修改这种情况以￥标识空栈，完善了匹配识别函数 完整代码 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8//函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 #define STACK_INIT_SIZE 100 //存储空间初始分配量 #define STACKINCREMENT 10 //存储空间分配增量 #include\u003ciostream\u003eusing namespace std; //设置状态码和数据类型 typedef int Status; typedef char SElemType; typedef struct { SElemType *base; //数组首地址,在栈构造之前和销毁之后，base的值为NULL SElemType *top; //栈顶指针 int stacksize;//当前已分配的存储空间，以元素为单位 }SqStack; //初始化 Status InitStack(SqStack \u0026S ) { // 构造一个空的顺序栈 S.base=new SElemType[STACK_INIT_SIZE]; if (!S.base) { exit(OVERFLOW); } //存储分配失败 S.top = S.base; //长度为0 S.stacksize = STACK_INIT_SIZE;//初始存储容量 return OK; } //销毁 Status DestroyStack(SqStack \u0026S) { free(S.base); S.top == S.base == NULL; S.stacksize = 0; return OK; } //判栈空 Status StackEmpty(SqStack S) { //若栈空，返回TRUE；否则返回FALSE。 if(S.top==S.base) { return TRUE; //栈空 } else { return FALSE; } } //求栈长 Status LengthStack(SqStack \u0026S) { return (S.top-S.base);//栈顶指针减去栈底指针 } //清空栈 Status ClearStack(SqStack \u0026S) { S.top=S.base;//让栈顶指针指向栈底位置 return OK; } //读栈顶 Status GetTop(SqStack S, SElemType \u0026e) { //若栈不空，则用e返回S的栈顶元素，并返OK， //否则返回ERROR if(S.top==S.base) { return ERROR; //栈空 } e=*(S.top-1); return OK; } //进栈 //int Status Push(SqStack \u0026S, SElemType e) { //插入元素e为新的栈顶元素 if(S.top-S.base \u003e= S.stacksize) {//栈满，追加空间 SElemType *newbase=(SElemType *)realloc(S.base, (S.stacksize+STACKINCREMENT)*sizeof(SElemType)); if(!newbase) exit(OVERFLOW); S.base=newbase; S.top=S.base+S.stacksize; S.stacksize+=STACKINCREMENT; } //if *S.top++=e; return OK; } //出栈 //int Status Pop(SqStack \u0026S, SElemType \u0026e) { //若栈不空，则删除栈顶元素，用e返回其值，并返回OK； //否则返回ERROR if(S.top==S.base) { e = *\"$\"; return ERROR; //栈空 } e=*--S.top; return OK; } //括号匹配 //判断左括号函数 Status is_left(char ch) { if(ch == '(' || ch=='[' || ch=='{' ) { return TRUE; } else { return FALSE; } } //判断右括号函数 Status is_right(char ch) { if(ch == ')' || ch==']' || ch=='}') { return TRUE; } else { return FALSE; } } //判断是否配对 Status peidui(char a, char b) { if(a == '(' \u0026\u0026 b == ')') { return TRUE; } else if(a == '[' \u0026\u0026 b == ']') { return TRUE; } else if(a == '{' \u0026\u0026 b == '}') { return TRUE; } else { return FALSE; } } Status match(char *exp) { //检验表达式中所含括弧是否正确嵌套，若是则返回OK,否则返回ERROR SElemType left; SqStack S; InitStack(S); //初始化栈S char *p=exp; char ch = *p; //当字符串exp未扫描 while (ch != '#' ) { if(is_left(ch)) { Push(S,ch);//左括号进栈 } if(is_right(ch)) { Pop(S,left); if(!is_left(left) || left == *\"$\") { return FALSE; //缺左括号 } else if(!peidui(left,ch)) { return FALSE; //左右不匹配 } } p++; ch = *p; } if(!StackEmpty(S)) { return FALSE; //有多余的左括号 } else { return TRUE; } } //实验5 void test() { char str[20]; cout\u003c\u003c\"输入括号(#结束):\"; cin\u003e\u003estr; bool result = match(str); if(result != true) { cout\u003c\u003c\"不匹配\"; } else { cout\u003c\u003c\"匹配\"; } cout\u003c\u003cendl; } int main() { //显示中文 SetConsoleOutputCP(65001); //实验5 test(); system(\"pause\"); } ","date":"2021-04-15","objectID":"/15/:4:0","tags":["C++","数据结构"],"title":"C++栈结构实现括号匹配","uri":"/15/"},{"categories":["C++","数据结构"],"content":"题目 数制转换(数据结构严蔚敏C语言版的C++实现) 输入：十进制整数 输出：八进制整数 处理方法：基于下列原理： N = (N div d)×d + N mod d (其中：div为整除运算，mod为求余运算) 步骤：（举例说明）（1348)10 = (2504)8 ","date":"2021-04-14","objectID":"/14/:0:0","tags":["C++","数据结构"],"title":"C++栈结构实现进制转换","uri":"/14/"},{"categories":["C++","数据结构"],"content":"一、问题分析 需要对一个输入变量进行除模运算，将余数压入栈中，将商再赋值给输入变量，再将栈中的元素出栈并输出，这个倒序输出的结果正好是进制转换的结果。 ","date":"2021-04-14","objectID":"/14/:1:0","tags":["C++","数据结构"],"title":"C++栈结构实现进制转换","uri":"/14/"},{"categories":["C++","数据结构"],"content":"二、代码 对于问题三进行求解，设计了translate函数，代码如下 void translate(SqStack \u0026S,int a,int \u0026result) { while (a!=0)//取余数N = (N div d)×d + N mod d { result = a%8; a = a/8; Push(S,result); } while (!StackEmpty(S))//从栈中取出结果，先进后出 { Pop(S,result); cout\u003c\u003cresult; } cout\u003c\u003cendl; } ","date":"2021-04-14","objectID":"/14/:2:0","tags":["C++","数据结构"],"title":"C++栈结构实现进制转换","uri":"/14/"},{"categories":["C++","数据结构"],"content":"三、分析 分析：这里的结果是栈“先进后出”结构的一个运用。 ","date":"2021-04-14","objectID":"/14/:3:0","tags":["C++","数据结构"],"title":"C++栈结构实现进制转换","uri":"/14/"},{"categories":["C++","数据结构"],"content":"四、实验过程记录 在完成这个程序时我遇到的苦难在于操作函数的编写，这耗费了我很长时间，后面的进制转换函数比较简单，将数学公式转化为代码即可。 完整代码 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8//函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 #define STACK_INIT_SIZE 100 //存储空间初始分配量 #define STACKINCREMENT 10 //存储空间分配增量 #include\u003ciostream\u003eusing namespace std; //设置状态码和数据类型 typedef int Status; typedef int SElemType; typedef struct { SElemType *base; //数组首地址,在栈构造之前和销毁之后，base的值为NULL SElemType *top; //栈顶指针 int stacksize;//当前已分配的存储空间，以元素为单位 }SqStack; //初始化 Status InitStack(SqStack \u0026S ) { // 构造一个空的顺序栈 S.base=new SElemType[STACK_INIT_SIZE]; if (!S.base) { exit(OVERFLOW); } //存储分配失败 S.top = S.base; //长度为0 S.stacksize = STACK_INIT_SIZE;//初始存储容量 return OK; } //销毁 Status DestroyStack(SqStack \u0026S) { free(S.base); S.top == S.base == NULL; S.stacksize = 0; return OK; } //判栈空 Status StackEmpty(SqStack S) { //若栈空，返回TRUE；否则返回FALSE。 if(S.top==S.base) { return TRUE; //栈空 } else { return FALSE; } } //求栈长 Status LengthStack(SqStack \u0026S) { return (S.top-S.base);//栈顶指针减去栈底指针 } //清空栈 Status ClearStack(SqStack \u0026S) { S.top=S.base;//让栈顶指针指向栈底位置 return OK; } //读栈顶 Status GetTop(SqStack S, SElemType \u0026e) { //若栈不空，则用e返回S的栈顶元素，并返OK， //否则返回ERROR if(S.top==S.base) { return ERROR; //栈空 } e=*(S.top-1); return OK; } //进栈 //int Status Push(SqStack \u0026S, SElemType e) { //插入元素e为新的栈顶元素 if(S.top-S.base \u003e= S.stacksize) {//栈满，追加空间 SElemType *newbase=(SElemType *)realloc(S.base, (S.stacksize+STACKINCREMENT)*sizeof(SElemType)); if(!newbase) exit(OVERFLOW); S.base=newbase; S.top=S.base+S.stacksize; S.stacksize+=STACKINCREMENT; } //if *S.top++=e; return OK; } //出栈 //int Status Pop(SqStack \u0026S, SElemType \u0026e) { //若栈不空，则删除栈顶元素，用e返回其值，并返回OK； //否则返回ERROR if(S.top==S.base) return ERROR; //栈空 e=*--S.top; return OK; } //进制转换 void translate(SqStack \u0026S,int a,int \u0026result) { while (a!=0)//取余数N = (N div d)×d + N mod d { result = a%8; a = a/8; Push(S,result); } while (!StackEmpty(S))//从栈中取出结果，先进后出 { Pop(S,result); cout\u003c\u003cresult; } cout\u003c\u003cendl; } //实验4 void test() { int input_num; int result; cout\u003c\u003c\"输入十进制数\"\u003c\u003cendl; cin\u003e\u003einput_num; SqStack S; InitStack(S); cout\u003c\u003c\"十进制数\"\u003c\u003cinput_num\u003c\u003c\"转换八进制数为：\"; translate(S,input_num,result); } int main() { //显示中文 SetConsoleOutputCP(65001); //实验4 test(); system(\"pause\"); return 0; } ","date":"2021-04-14","objectID":"/14/:4:0","tags":["C++","数据结构"],"title":"C++栈结构实现进制转换","uri":"/14/"},{"categories":["C++","数据结构"],"content":"题目 尾插法(数据结构严蔚敏C语言版的C++实现) 输入：键盘输入 输出：带头结点的单链表L 处理方法：待插结点*s插入到最后一个结点之后。 步骤： 1)获得最后一个结点的位置,使p指向该结点 2)p-\u003enext = new LNode; 3)p = p-\u003enext; 4)cin\u003e\u003ep-\u003edata; 5)p-\u003enext = NULL; 分析：要想获取最后一个结点的位置，必须从头指针开始顺着next链搜索链表的全部结点，该过程的时间复杂度是O( )。如果每次插入都按此方法获取最后一个结点的位置，则整个创建算法的时间复杂度为O( )。 ","date":"2021-04-13","objectID":"/13/:0:0","tags":["C++","数据结构"],"title":"C++单链表尾插法","uri":"/13/"},{"categories":["C++","数据结构"],"content":"一、问题分析 创建一个单链表，在尾插函数中添加尾指针，将输入获的int类型数据元素一个个尾插到单链表最后一个。 ","date":"2021-04-13","objectID":"/13/:1:0","tags":["C++","数据结构"],"title":"C++单链表尾插法","uri":"/13/"},{"categories":["C++","数据结构"],"content":"二、代码 对于问题三进行求解，设计了Tail_Insert函数，代码如下 void Tail_Insert(LinkList \u0026L) { int e; LNode *p, *s; L = new LNode; L-\u003enext = NULL;//定义头结点 p = L; //p是L的尾指针 cout\u003c\u003c\"请输入节点(输入0结束并输出结果)：\"\u003c\u003cendl; cin \u003e\u003e e; //从键盘输入一个结点 while (e != 0) { s = new LNode; s-\u003edata = e; s-\u003enext = NULL; p-\u003enext = s; p = s; //插入链表 cin \u003e\u003e e; //继续读 } } ","date":"2021-04-13","objectID":"/13/:2:0","tags":["C++","数据结构"],"title":"C++单链表尾插法","uri":"/13/"},{"categories":["C++","数据结构"],"content":"三、分析 通过尾插法插入后，输入的数字是按照倒序在栈S中存储的，如果使用S进行输出，输出结果会是倒叙，需要再创建一个栈Q，将栈S中的元素顺序倒置，再由打印函数输出。 ","date":"2021-04-13","objectID":"/13/:3:0","tags":["C++","数据结构"],"title":"C++单链表尾插法","uri":"/13/"},{"categories":["C++","数据结构"],"content":"四、实验过程记录 我在码这个程序时碰到的困难是对指针节点的使用，试过在链接各节点时顺序弄反了，导致数据丢失了，后面经过一段排查后程序正常运行了。 完整代码 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8#define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 #include\u003ciostream\u003eusing namespace std; typedef int ElemType; typedef int status; //创建节点结构体 typedef struct LNode { ElemType data; struct LNode *next; }LNode, *LinkList; //初始化 status InitList(LinkList\u0026L) { L = new LNode; if (!L) exit(OVERFLOW); L-\u003enext = NULL; return OK; } // status Getelem(LinkList L, int i, ElemType\u0026e) { LNode *p; int j; p = L-\u003enext; j = 1; while (p\u0026\u0026j \u003c 1) { p = p-\u003enext; j++; } if (!p || j \u003e i)return ERROR; e = p-\u003edata; return OK; } void Tail_Insert(LinkList \u0026L) { int e; LNode *p, *s; L = new LNode; L-\u003enext = NULL;//定义头结点 p = L; //p是L的尾指针 cout\u003c\u003c\"请输入节点(输入0结束并输出结果)：\"\u003c\u003cendl; cin \u003e\u003e e; //从键盘输入一个结点 while (e != 0) { s = new LNode; s-\u003edata = e; s-\u003enext = NULL; p-\u003enext = s;//插入链表 p = s; //更新尾指针 cin \u003e\u003e e; //继续读 } } //打印 void PrintList(LinkList L) { LinkList tem = L; while (tem-\u003enext != NULL) { tem = tem-\u003enext; cout \u003c\u003c tem-\u003edata \u003c\u003c \" \"; } } //实验3 void test() { LinkList L; Tail_Insert(L); cout \u003c\u003c \"输出：\"; PrintList(L); cout\u003c\u003cendl; } int main() { //显示中文 SetConsoleOutputCP(65001); //实验3 test(); system(\"pause\"); return 0; } ","date":"2021-04-13","objectID":"/13/:4:0","tags":["C++","数据结构"],"title":"C++单链表尾插法","uri":"/13/"},{"categories":["C++","数据结构"],"content":"题目 按值非递减有序排列表合并(数据结构严蔚敏C语言版的C++实现) 已知线性表La和Lb中的数据元素按值非递减有序排列，要求将La和Lb归并成一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。（用顺序表实现） 输入：线性表La、线性表Lb(均按值非递减有序排列) 输出：Lc(按值非递减有序排列)，使用函数merge(La, Lb, \u0026Lc) 处理方法： 由La和Lb均按值非递减有序排列，可设置两个位置指示器i和j，分别指向La和Lb中的当前元素，初始均指向第1个。 比较i和j所指向的元素ai和bj，选取值小的插入到Lc的尾部，并使相应的位置指示器向后移。 ","date":"2021-04-12","objectID":"/12/:0:0","tags":["C++","数据结构"],"title":"C++非递减有序顺序表合并","uri":"/12/"},{"categories":["C++","数据结构"],"content":"一、问题分析 需要创建三个表La，Lb，Lc，创建与之对应的位置指示器i，j，k，然后在La与Lb中各取一个元素进行比较，较小的插入Lc中，相应的位置指示器往后移一位。 如果La插入完毕，将Lc中剩余元素全部插入Lc中，如果Lb插入完毕，将La中剩余元素全部插入Lc尾部。 ","date":"2021-04-12","objectID":"/12/:1:0","tags":["C++","数据结构"],"title":"C++非递减有序顺序表合并","uri":"/12/"},{"categories":["C++","数据结构"],"content":"二、代码 对于问题二进行求解，设计了merge函数，代码如下 void merge(SqList La, SqList Lb,SqList \u0026Lc) { //求表长 int la_len = ListLength(La); int lb_len = ListLength(Lb); //初始化存储索引的a，b和位置i，j，k ElemType a,b; int i = 1; int j = 1; int k = 0; //比较入表 while(i \u003c= la_len \u0026\u0026 j \u003c= lb_len) { GetElem(La,i,a); GetElem(Lb,j,b); if(a\u003cb) { ListInsert(Lc, ++k, a); ++i; } if(b\u003ca) { ListInsert(Lc, ++k, b); ++j; } } //比较入表后将剩余元素入表 while(i \u003c= la_len) //LB已到达表尾，依次将LA的剩余元素插入LC的后面 { GetElem(La,i,a); i++; ListInsert(Lc, ++k, a); } while(j \u003c= lb_len) //LA已到达表尾，依次将LB的剩余元素插入LC的后面 { GetElem(Lb,j,b); j++; ListInsert(Lc, ++k, b); } } ","date":"2021-04-12","objectID":"/12/:2:0","tags":["C++","数据结构"],"title":"C++非递减有序顺序表合并","uri":"/12/"},{"categories":["C++","数据结构"],"content":"三、分析 通过读表元函数将La和Lb中的一个元素读取出来，再对两元素进行大小比较，如果找到较小的一个元素，在Lc表的最后面插入该元素；如果La插入完毕，将Lc中剩余元素全部插入Lc中；如果Lb插入完毕，将La中剩余元素全部插入Lc尾部。 ","date":"2021-04-12","objectID":"/12/:3:0","tags":["C++","数据结构"],"title":"C++非递减有序顺序表合并","uri":"/12/"},{"categories":["C++","数据结构"],"content":"四、实验过程记录 这个程序我在实际码的过程中碰到的困难在于和前一个实验使用了同一个文件里的表结构，一个文件写了两个小实验程序。我一开始忘记在使用表后得销毁表，导致后面使用同名表时报错，后来我注释掉前一个实验程序的调用就正常运行了。 完整代码 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8//函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //初始空间参数 #define LIST_INIT_SIZE 100 //线性表的初始存储空间 #define LISTINCREMENT 10 //线性表的增量空间 #include\u003ciostream\u003e#include \u003cstdlib.h\u003e using namespace std; //设置状态码和数据类型 typedef int Status; typedef int ElemType; //定义顺序表 typedef struct SqList{ ElemType *elem; //头指针指向数组首元素 int Length; //线性表的当前长度 int Listsize; //线性表的当前容量 }; //初始化 Status InitList(SqList \u0026L) { //给表分配空间 L.elem = new ElemType(LIST_INIT_SIZE); //判断是否生成 if(!L.elem) { return OVERFLOW; } else { L.Listsize = LIST_INIT_SIZE; //表长度为初始值 L.Length = 0; //表默认长度0 return OK; } }; //销毁 Status DestroyList(SqList \u0026L) { if(L.elem != NULL)//判断表是否已存在 { free(L.elem); L.elem = NULL; L.Length = 0; L.Listsize = 0; return OK; } else { return ERROR; } } //判空 bool ListEmpty(SqList L) { if(L.Listsize == 0)//如果顺序表的长度为0，则表为空 { return true; } else { return false; } } //求表长 int ListLength(SqList L) { return L.Length;//返回顺序表表长 } //查找返回下标 int LocateElem(SqList L,ElemType e) //bool compare(int p,int e) { int *p,i; p = L.elem; i = 1; while (i \u003c= L.Length \u0026\u0026 *p++ != e)//后置++高于* i++; if (i \u003e L.Length) i = 0; return i; } //读表元(已经自动转换下标了) Status GetElem(SqList L,int i,ElemType \u0026e) { if(i\u003c1 || i\u003eListLength(L)) return OVERFLOW; int *p; p = \u0026(L.elem[i-1]); e = *p; return OK; } //打印函数 void Print(SqList L) { for (int i = 0; i \u003c L.Length; i++) { cout \u003c\u003c L.elem[i] \u003c\u003c \"\"; } cout \u003c\u003c endl; } //求前驱 ElemType PriorElem(SqList L,ElemType cur_e,ElemType \u0026pre_e) { if(L.elem != NULL) { int i = LocateElem(L,cur_e); if(i==0 || i ==1) { pre_e = NULL; } else { pre_e = L.elem[i-2]; } return pre_e; } } //求后继 ElemType NextElem(SqList L,ElemType cur_e,ElemType \u0026next_e) { if(L.elem != NULL) { int i = LocateElem(L,cur_e); if(i==0 || i ==1) { next_e = NULL; } else { next_e = L.elem[i]; } return next_e; } } //线性表置空 Status ClearList(SqList \u0026L) { if(L.elem != NULL) { L.Length = 0; return OK; } else { return ERROR; } } //赋值 Status PutElem(SqList \u0026L,int i,ElemType \u0026e) { if(L.elem != NULL \u0026\u0026 !i\u003c1 \u0026\u0026 !i\u003eListLength(L)) { L.elem[i] = e; return OK; } else { return ERROR; } } //插入元素 Status ListInsert(SqList \u0026L,int i,ElemType e) { //判断是否非法 if(i\u003c1||i\u003eL.Length+1) { return OVERFLOW; } //判断是否满了，如果满动态扩展 if (L.Length \u003e= L.Listsize) { //计算新表大小 int newsize = L.Listsize + LISTINCREMENT; //分配新空间 int *newbase = (ElemType *)realloc(L.elem,newsize*sizeof(ElemType));//已经自动释放原L，并拷贝数据到新空间 //判断是否成功分配 if(!newbase) exit(OVERFLOW); //更新新空间指向 L.elem = newbase; //更新容量 L.Listsize += LISTINCREMENT; } int *q,*p; q = \u0026L.elem[i-1];//令q指向ai，静态 for(p = L.elem+L.Length-1; p\u003e=q ;--p)//下标从0开始，第几个元素得减1 { //从后往前检索，逐个元素后移 *(p+1) = *p; } *q = e; ++L.Length; return OK; } //删除元素 Status ListDelete(SqList \u0026L,int i,ElemType \u0026e) { if(i\u003c1||i\u003eL.Length) { return ERROR; //i非法 } ElemType *p=L.elem+i-1;//p为被删除元素的位置 e=*p;//被删除元素的值赋给e ElemType *q=L.elem+L.Length-1;//表尾元素的位置 for(++p;p\u003c=q;++p) { *(p-1)=*p; //左移一位 } L.Length--; //表长减1 return OK; } //非递减有序排列表合并 void merge(SqList La, SqList Lb,SqList \u0026Lc) { //求表长 int la_len = ListLength(La); int lb_len = ListLength(Lb); //初始化存储索引的a，b和位置i，j，k ElemType a,b; int i = 1; int j = 1; int k = 0; //比较入表 while(i \u003c= la_len \u0026\u0026 j \u003c= lb_len) { GetElem(La,i,a); GetElem(Lb,j,b); if(a\u003cb) { ListInsert(Lc, ++k, a); ++i; } if(b\u003ca) { ListInsert(Lc, ++k, b); ++j; } } //比较入表后将剩余元素入表 while(i \u003c= la_len) //LB已到达表尾，依次将LA的剩余元素插入LC的后面 { GetElem(La,i,a); i++; ListInsert(Lc, ++k, a); } while(j \u003c= lb_len) //LA已到达表尾，依次将LB的剩余元素插入LC的后面 { GetElem(Lb,j,b); j++; ListInsert(Lc, ++k, b); } } //实验2 void test02() { SqList La; InitList(La); int a; cout \u003c\u003c \"顺序表La的5个元素：\" \u003c\u003c endl; for (int j = 0; j \u003c 5; j++) { cin \u003e\u003e a; ListInsert(La,j+1, a); } SqList Lb; InitList(Lb); int b; cout \u003c\u003c \"顺序表Lb的5个元素：\" \u003c\u003c endl; for (int k = 0; k \u003c 5; k++) { cin \u003e\u003e b; ListInsert(Lb, k+1, b); } SqLi","date":"2021-04-12","objectID":"/12/:4:0","tags":["C++","数据结构"],"title":"C++非递减有序顺序表合并","uri":"/12/"},{"categories":["C++","数据结构"],"content":"题目 C++顺序表合并(数据结构严蔚敏C语言版的C++实现) 求两个线性表La和Lb的并集La = La U Lb （用顺序表实现） ( 要求：“就地运算”，运算结果仍然存放在La中 ) 输入：线性表La、线性表Lb 输出：变化了的La 处理方法：扩大线性表La，将存在于线性表Lb 而不存在于线性表La中的数据元素插入到线性表La中去 ","date":"2021-04-11","objectID":"/11/:0:0","tags":["C++","数据结构"],"title":"C++顺序表合并","uri":"/11/"},{"categories":["C++","数据结构"],"content":"一、问题分析 需要创建两个线性顺序表La和Lb，先从线性表Lb中依次取得每个数据元素，依值在线性表La中进行遍历比较查访，若La中该元素不存在，则在La的表尾插入。 ","date":"2021-04-11","objectID":"/11/:1:0","tags":["C++","数据结构"],"title":"C++顺序表合并","uri":"/11/"},{"categories":["C++","数据结构"],"content":"二、代码 对于问题一进行求解，设计了unionL函数，代码如下 Status unionL(SqList \u0026La,SqList Lb) { // 求各表的长度 int La_len = ListLength(La); int Lb_len = ListLength(Lb); int e; //初始化e for (int i = 1; i \u003c= Lb_len; i++) { GetElem(Lb,i,e); if (!LocateElem(La, e)) { ListInsert(La, ++La_len, e); } } return OK; } ","date":"2021-04-11","objectID":"/11/:2:0","tags":["C++","数据结构"],"title":"C++顺序表合并","uri":"/11/"},{"categories":["C++","数据结构"],"content":"三、分析 通过读表元函数将Lb中的元素读取出来，再对该元素对La进行下标查找，如果查找不到，在表的最后面插入该元素。 ","date":"2021-04-11","objectID":"/11/:3:0","tags":["C++","数据结构"],"title":"C++顺序表合并","uri":"/11/"},{"categories":["C++","数据结构"],"content":"四、实验过程记录 这个程序我在码的过程中难点是操作函数的编写，特别是一些自增自减符，写着写着就忘记是先运算再使用还是先使用再运算了，这给我后面写实际解决方案时带来了很大的困难，没有报错却又找不到哪里有错误使得结果有误。 完整代码 //显示中文 #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8//函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //初始空间参数 #define LIST_INIT_SIZE 100 //线性表的初始存储空间 #define LISTINCREMENT 10 //线性表的增量空间 #include\u003ciostream\u003e#include\u003cstdlib.h\u003eusing namespace std; //设置状态码和数据类型 typedef int Status; typedef int ElemType; //定义顺序表 typedef struct SqList{ ElemType *elem; //头指针指向数组首元素 int Length; //线性表的当前长度 int Listsize; //线性表的当前容量 }; //初始化 Status InitList(SqList \u0026L) { //给表分配空间 L.elem = new ElemType(LIST_INIT_SIZE); //判断是否生成 if(!L.elem) { return OVERFLOW; } else { L.Listsize = LIST_INIT_SIZE; //表长度为初始值 L.Length = 0; //表默认长度0 return OK; } }; //销毁 Status DestroyList(SqList \u0026L) { if(L.elem != NULL)//判断表是否已存在 { free(L.elem); L.elem = NULL; L.Length = 0; L.Listsize = 0; return OK; } else { return ERROR; } } //判空 bool ListEmpty(SqList L) { if(L.Listsize == 0)//如果顺序表的长度为0，则表为空 { return true; } else { return false; } } //求表长 int ListLength(SqList L) { return L.Length;//返回顺序表表长 } //查找返回下标 int LocateElem(SqList L,ElemType e) //bool compare(int p,int e) { int *p,i; p = L.elem; i = 1; while (i \u003c= L.Length \u0026\u0026 *p++ != e)//后置++高于* i++; if (i \u003e L.Length) i = 0; return i; } //读表元(已经自动转换下标了) Status GetElem(SqList L,int i,ElemType \u0026e) { if(i\u003c1 || i\u003eListLength(L)) return OVERFLOW; int *p; p = \u0026(L.elem[i-1]); e = *p; return OK; } //打印函数 void Print(SqList L) { for (int i = 0; i \u003c L.Length; i++) { cout \u003c\u003c L.elem[i] \u003c\u003c \"\"; } cout \u003c\u003c endl; } //求前驱 ElemType PriorElem(SqList L,ElemType cur_e,ElemType \u0026pre_e) { if(L.elem != NULL) { int i = LocateElem(L,cur_e); if(i==0 || i ==1) { pre_e = NULL; } else { pre_e = L.elem[i-2]; } return pre_e; } } //求后继 ElemType NextElem(SqList L,ElemType cur_e,ElemType \u0026next_e) { if(L.elem != NULL) { int i = LocateElem(L,cur_e); if(i==0 || i ==1) { next_e = NULL; } else { next_e = L.elem[i]; } return next_e; } } //线性表置空 Status ClearList(SqList \u0026L) { if(L.elem != NULL) { L.Length = 0; return OK; } else { return ERROR; } } //赋值 Status PutElem(SqList \u0026L,int i,ElemType \u0026e) { if(L.elem != NULL \u0026\u0026 !i\u003c1 \u0026\u0026 !i\u003eListLength(L)) { L.elem[i] = e; return OK; } else { return ERROR; } } //插入元素 Status ListInsert(SqList \u0026L,int i,ElemType e) { //判断是否非法 if(i\u003c1||i\u003eL.Length+1) { return OVERFLOW; } //判断是否满了，如果满动态扩展 if (L.Length \u003e= L.Listsize) { //计算新表大小 int newsize = L.Listsize + LISTINCREMENT; //分配新空间 int *newbase = (ElemType *)realloc(L.elem,newsize*sizeof(ElemType));//已经自动释放原L，并拷贝数据到新空间 //判断是否成功分配 if(!newbase) exit(OVERFLOW); //更新新空间指向 L.elem = newbase; //更新容量 L.Listsize += LISTINCREMENT; } int *q,*p; q = \u0026L.elem[i-1];//令q指向ai，静态 for(p = L.elem+L.Length-1; p\u003e=q ;--p)//下标从0开始，第几个元素得减1 { //从后往前检索，逐个元素后移 *(p+1) = *p; } *q = e; ++L.Length; return OK; } //删除元素 Status ListDelete(SqList \u0026L,int i,ElemType \u0026e) { if(i\u003c1||i\u003eL.Length) { return ERROR; //i非法 } ElemType *p=L.elem+i-1;//p为被删除元素的位置 e=*p;//被删除元素的值赋给e ElemType *q=L.elem+L.Length-1;//表尾元素的位置 for(++p;p\u003c=q;++p) { *(p-1)=*p; //左移一位 } L.Length--; //表长减1 return OK; } //合并两表 Status unionL(SqList \u0026La,SqList Lb) { int La_len = ListLength(La); // 求各表的长度 int Lb_len = ListLength(Lb); int e; //初始化e for (int i = 1; i \u003c= Lb_len; i++) { GetElem(Lb,i,e); // 取Lb中第i个数据元素赋给e if (!LocateElem(La, e)) { ListInsert(La, ++La_len, e); // La中不存在和 e 相同的数据元素，则插入 } } return OK; } //实验1 void test01() { SqList La; InitList(La); int a; cout \u003c\u003c \"顺序表La的5个元素：\" \u003c\u003c endl; for (int j = 0; j \u003c 5; j++) { cin \u003e\u003e a; ListInsert(La, j+1, a); } SqList Lb; InitList(Lb); int b; cout \u003c\u003c \"顺序表Lb的5个元素：\" \u003c\u003c endl; for (int k = 0; k \u003c 5; k++) { cin \u003e\u003e b; ListInsert(Lb, k+1, b); } unionL(La,Lb); cout \u003c\u003c \"La与Lb的并集为：\" \u003c\u003c endl; int l = 0; while(l\u003cLa.Length) { cout\u003c\u003cLa.elem[l]\u003c\u003cendl; l++; } cout\u003c\u003cendl; DestroyList(La); DestroyList(Lb); } int main() { //显示中文 SetConsoleOutputCP(65001); //实验1 test01(); system(\"pause\"); return 0; } ","date":"2021-04-11","objectID":"/11/:4:0","tags":["C++","数据结构"],"title":"C++顺序表合并","uri":"/11/"},{"categories":["C++"],"content":"vscode2021新版的C++函数分文件编写配置 如图所示，需要下载这个插件 C/C++ Project Generator 安装并启用后，使用方法如下 创建工程文件后目录结构如下 main.cpp文件使用自定义的swap函数，swap函数的头文件放include文件夹，源文件放src文件夹 下面是运行c++程序生成可执行exe文件的步骤，如图 在终端运行，得到结果 ","date":"2021-03-08","objectID":"/10/:0:0","tags":["C++"],"title":"C++函数分文件编写(VScode2021配置教程)","uri":"/10/"},{"categories":["C++"],"content":"注意，千万不要用右上角的run code执行！ ↓↓↓我在我的博客首发这篇文章，欢迎在我的自建博客查看 我的博客文章 如果运行后显示中文乱码可以试试下面的代码 #include\u003ciostream\u003e#include \u003cwindows.h\u003e//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8using namespace std; int main() { SetConsoleOutputCP(65001); cout\u003c\u003c\"中文正常显示\"\u003c\u003cendl; system(\"pause\"); return 0; } ","date":"2021-03-08","objectID":"/10/:1:0","tags":["C++"],"title":"C++函数分文件编写(VScode2021配置教程)","uri":"/10/"},{"categories":["C++"],"content":"指针的概念 内存地址 内存空间的编排是以字节为单位的，每一个字节（也称单元）都有一个编号，这就是地址。内存地址通常是一个大小为4个字节的整数（这与具体的计算机有关），一般用十六进制数表示。 指针 指针变量是一种用来存放地址的特殊变量，简称为指针。例如： int * iPointer; 编译时，系统将为指针变量iPointer分配另一个内存空间，用于存放某个变量的起始地址。 例如： iPointer = \u0026i; 则：指针变量iPointer里存放的就是变量i的起始地址 直接访问和间接访问 1.直接访问：按变量存取值。 根据变量的地址直接访问变量的内容。 变量名经编译后自动转换为变量的地址，直接访问时对变量的存取都是直接通过变量地址进行的。 例如，运算式k=i+j。 2.间接访问： 将变量a的地址存放在变量b中，先访问变量b得到变量b的值（即变量a的地址）后，再访问变量a。 对变量内容的访问要经过两次：先访问地址，后访问内容。 例如，先访问iPointer，即找到存放“i的地址”的单元，从中获得i的起始地址0x20000000，然后到0x20000000起始的4个字节中取出i的值。 指针的变量 指针变量简称指针，指针变量保存的是另一个变量b的地址； 实际上，这个地址就是一个有特殊意义的32位整数，它是系统为变量b分配的存储空间的起始地址，简称首地址。 在C++中，可以通过指针操作直接访问存储器中的单元。 ","date":"2021-02-06","objectID":"/09/:0:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针变量的声明 指针变量声明的一般形式为： \u003c类型标识符\u003e *指针变量名 注意： (1)申明指针变量时的 * ,只是一个标志，不表示取内容运算。 (2)指针变量名必须符合标识符的命名规则； (3)申明指针变量时的数据类型是指针变量所指的变量的数据类型； (4)申明指针变量时,””前后可以加空格，也可以不加； 比如：int *p1; 或者int* p1; 都可以 注意： int p1, p2; //p1是int变量，p2是指向int的指针 int p1, p2; //p2是int变量，p1是指向int的指针 建议紧跟指针变量名。 指针声明时需要特别注意： （1）指针变量具有数据类型 虽然指针存放的都是内存地址，但一个指针变量只能存放声明中指定类型数据的地址，否则编译时会出错。 例如：````int ip; float * fp; ``` 则：ip只能指向int型变量、fp只能指向float型变量。 （2）void型指针 void型指针是一个类型不确定的指针。根据需要可以将void型指针强制转换成int或其它类型的指针。 （3）空指针NULL C++语言中定义了一个符号常数NULL用来代表空指针，用来表示“无效”的指针值，其值为0。 ","date":"2021-02-06","objectID":"/09/:1:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针的基本操作 \u0026变量名 \u0026为取地址运算符，用来获取变量的首地址。 指针变量名 这里的星号“”为指向运算符（也称之为：取内容运算符、间接访问运算符），用来获取指针变量所指向的变量的值。 “\u0026”和“*”运算符都是一元运算符，其优先级高于所有二元运算符，采用从右到左的结合性。 例如： int i=5,j=3, *pInt; pInt = \u0026i; j=*pInt; 注意其中的差别： 第1句话中pInt是申明指针变量，只是一个标志； 第2句话取i的地址为已经申明过的指针变量赋值，pInt前不再加 第3句话中pInt表示取出指针pInt所指内存中的值，*表示取内容运算 体会差别： int *pInt = \u0026i; pInt = \u0026i; *pInt = j; ","date":"2021-02-06","objectID":"/09/:2:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针变量的初始化 指针变量也可以在声明时赋初值，完成指针变量的初始化。 注意： （1）对指针变量所赋的初始值必须是同类型变量的地址； 如： int i=5,j, *pInt=\u0026i; //可以 double f=0.3; int *pInt=\u0026f; //不可以 （2）指针变量使用之前必须做初始化（赋初值），即把某个普通变量的地址赋给它。否则指针变量的值就是不确定的，也称之为指针的指向不定，那么贸然使用，就会导致运行错误！ 例如： int a=0; int *x; *x=a; //错误！指向不定时无法为x所指的变量赋值！ a=*x; //错误！指向不定时无法读取x所指的变量！（即无法获取指针变量所指向的变量的值） //指针变量的定义和使用 #include\u003ciostream\u003eusing namespace std; int main() { int m,n,\u0026k=m,*p1=\u0026m,*p2=\u0026n,*pInt=NULL; k=n=6; cout\u003c\u003c\"m=\"\u003c\u003cm\u003c\u003c\" ， n=\"\u003c\u003cn\u003c\u003c\" ， k=\"\u003c\u003ck\u003c\u003cendl; cout\u003c\u003c\"\u0026m=\"\u003c\u003c\u0026m\u003c\u003c\" ， \u0026n=\"\u003c\u003c\u0026n\u003c\u003c\" ， \u0026k=\"\u003c\u003c\u0026k\u003c\u003cendl; cout\u003c\u003c\"p1=\"\u003c\u003cp1\u003c\u003c\" ， p2=\"\u003c\u003cp2\u003c\u003c\" , pInt=\"\u003c\u003cpInt\u003c\u003cendl; cout\u003c\u003c\"*p1=\"\u003c\u003c*p1\u003c\u003c\" ， *p2=\"\u003c\u003c*p2\u003c\u003cendl; *p1+=3; p2=p1; *p2*=4; pInt=p2; cout\u003c\u003c\"*p1=\"\u003c\u003c*p1\u003c\u003c\" ， *p2=\"\u003c\u003c*p2\u003c\u003cendl; cout\u003c\u003c\"p1=\"\u003c\u003cp1\u003c\u003c\" ， p2=\"\u003c\u003cp2\u003c\u003cendl; cout\u003c\u003c\"m=\"\u003c\u003cm\u003c\u003c\" ， n=\"\u003c\u003cn\u003c\u003cendl; cout\u003c\u003c\"pInt=\"\u003c\u003cpInt\u003c\u003cendl; return 0; } ","date":"2021-02-06","objectID":"/09/:3:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针的赋值运算 （1）指针变量在赋值时，不允许直接将与指针变量类型不同的指针值赋予指针变量。 例如： int *iPointer, iValue;char ch='A'; iPointer= \u0026ch; //不允许 iValue = ch; //允许,将字符变量ch对应的ASCII码（整型数据）赋值给iValue （2）用数据类型不兼容的指针指向该数据类型的变量，可以使用强制类型转换。 如上例中，可以： iPointer=(int *)\u0026ch;//允许 注意：iPointer被强制指向了ch的起始地址，但ch是字符变量，因此若取指针iPointer所指的内容，则只有最低一个字节内有值（65），高位的三个字节都是随机值（调试显示：*iPointer=-858993599）。 （3）将其他的任何一种指针值赋予void*型指针变量都必须通过强制类型转换。 如： void *vPointer = (void *)iPointer; （4）通过强制类型转换，也可以将指针变量赋值给一个整型变量，或将一个整型常量赋予一个指针变量。例如： iValue = (int)iPointer; iPointer=(int *)0x98980000;//但这样的地址通常不能做取内容运算！ 但下面两种做法是错误的： int *iPointer = \u0026100; int *iPointer = \u0026(100*20+iValue); ","date":"2021-02-06","objectID":"/09/:4:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针的算数运算 对于非void*型的指针变量，只能进行加一个整数、减一个整数和两个指针变量相减3种运算。void*型指针变量不能做任何算术运算。 对非void* 型的指针变量做加减整数的运算，实际上就是对地址进行加法或减法运算，但这种加减是按照指针所指变量的类型所占的字节数为单位进行的。 例如： int iValue; int* iPointer1=\u0026iValue，*iPointer2; iPointer2=iPointer1+1; 假设iValue的初始地址是0x20000000，即iPointer1的值为0x20000000，则iPointer2=iPointer1+1后，iPointer2的值为0x20000004（注意不是0x20000001） 指针的自加（++）与自减（–）运算，即： iPointer2++; --iPointer1; 分别等价于： iPointer2 = iPointer2+1； iPointer1 = iPointer1-1； ","date":"2021-02-06","objectID":"/09/:5:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针的关系运算 指针间的关系运算结果就是两个指针所指的地址值的大小的关系运算结果。两个进行关系运算的指针一般要求是同一类型的指针。 #include\u003ciostream\u003eusing namespace std; int main(){ int n=3,*p1=\u0026n,*p2=NULL; cout\u003c\u003c\"p1=\"\u003c\u003cp1\u003c\u003c\" ， p2=\"\u003c\u003cp2\u003c\u003cendl; p1=p2+4; //以int所占字节数为单位进行加减，注意地址采用16进制表示。 p2++; cout\u003c\u003c\"p1=\"\u003c\u003cp1\u003c\u003c\" ，p2=\"\u003c\u003cp2\u003c\u003cendl; p2=p1-2; cout\u003c\u003c\"p1=\"\u003c\u003cp1\u003c\u003c\" ， p2=\"\u003c\u003cp2\u003c\u003cendl; return 0; ","date":"2021-02-06","objectID":"/09/:6:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针与数组 在声明一个数组时，C++语言将在内存中开辟两个空间，一个用于保存数组元素，另一个用于保存数组的第1个元素的地址，称为数组的首地址，数组名就是保存了数组首地址的指针。 因此对数组元素的访问除了常用的下标法外，还可以用指针操作代替。 例如，如果定义： int iArray[10],*iPointer=iArray; //或者int *iPointer=\u0026iArray[0]; 这样通过指针iPointer也可以访问数组中的任意一个元素，即： iArray[n]等同于*(iPointer+n) 同样，也可以把指针作为数组名使用，使用下标法访问数组元素，以下4句是等价的： iValue = iArray[5]; iValue = iPointer[5]; iValue = *(iPointer+5); iValue = *(iArray+5); 尽管指针和数组名都是指针，但它们也有区别： 指针变量是变量，是可以不断赋值的；而数组名则是指针型常量，只能指向固定的内存地址（即系统为数组所分配的内存空间的首地址），因此不能给数组名赋值，如： char cArray[10],ch; cArray = \u0026ch; //错误，不允许将一个指针值赋给数组名！ ","date":"2021-02-06","objectID":"/09/:7:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"使用指针访问数组元素 如果定义一维数组int a[10];则一维数组a中的任何一个元素a[i]等同于*(a+i) //如何将中间的while循环，改为for循环 for(int i=0;i\u003cn;i++,iPointer++) iSum+=*iPointer; //或者： for(int i=0;i\u003cn;i++) iSum+=*iPointer++; 使用指针求一维数组中所有元素之和。 int sum(int *iPointer,int n) { int iSum=0; while(n\u003e0) { iSum+=*iPointer; iPointer++; n--; } return iSum; } int main() { int iArray[10]={6,7,8,9,5,4,3,2,10,1}; cout\u003c\u003c\"数组各元素和: sum=\"\u003c\u003csum(iArray,10)\u003c\u003cendl; return 0; } 使用指针对数组中各元素进行排序。 void order(int *iPointer,int n) { int i,j,t,p; for(i=0;i\u003cn-1;i++) { p=i; for(j=i+1;j\u003cn;j++) { if(*(iPointer+p)\u003c=*(iPointer+j)) p=j; } if(p!=i) { t=*(iPointer+i); *(iPointer+i)=*(iPointer+p); *(iPointer+p)=t; } } } int main(){ int iArray[10]={6,7,8,9,5,4,3,2,10,1}; order(iArray,10); cout\u003c\u003c\"排序后的数组为：\"\u003c\u003cendl; for(int i=0;i\u003c10;i++) cout\u003c\u003ciArray[i]\u003c\u003c\" \"; cout\u003c\u003cendl; return 0; } order函数的其它实现方法：下标法访问数组元素 void order(int iPointer[],int n) { int i,j,t,p; for(i=0;i\u003cn-1;i++) { p=i; for(j=i+1;j\u003cn;j++) { if(iPointer[p]\u003c=iPointer[j]) p=j; } if(p!=i) { t=iPointer[i]; iPointer[i]=iPointer[p]; iPointer[p]=t; } } } ","date":"2021-02-06","objectID":"/09/:8:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指向多维数组的指针 多维数组的元素在计算机中也是线性存储的(C++采用按行顺序保存的原则)，只要知道保存某个多维数组的内存区域的首地址，就可以通过指针访问多维数组中的任何一个元素。例如，声明以下二维数组： int iMatrix [3][4]; 现在定义一个指针变量，并将该二维数组的首地址赋予它： int *iPointer=\u0026iMatrix[0][0]; 则二维数组iMatrix中的任何一个元素使用iPointer这个指针来访问的规则是： *(iPointer+m*4+n) //等同于iMatrix [m][n] 多维数组的数组名同样也是指针，但它不指向多维数组的第一个元素，而是指向存放第一个数组元素地址的指针，即多维数组的数组名是指向（指向第一个数组元素的）指针的指针。 比如：将二维数组iMatrix[3][4]看成由3个一维数组iMatrix[i] (0\u003ci\u003c3)组成的数组，其中： iMatrix[0]等同于\u0026iMatrix[0][0] iMatrix[1]等同于\u0026iMatrix[1][0] iMatrix[2]等同于\u0026iMatrix[2][0] 因而，有二维数组iMatrix就是指向这3个一维数组iMatrix[i]组成的数组的第一个元素iMatrix[0]的指针，而iMatrix[0]是指向iMatrix[0][0]的指针。 故：iMatrix的数据类型是int**，即指向int指针变量的指针，也称二级指针 从地址值的角度看，iMatrix、iMatrix[0]和\u0026iMatrix[0][0]所代表的值是相同的，但其本质含义却不同。 //使用指针实现二维数组转置（行列互换），并输出结果。 #include\u003ciostream\u003e #include\u003ciomanip\u003e using namespace std; int main(){ int iMatrix[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; int i,j,*iP; cout\u003c\u003c\"转置前的矩阵：\"\u003c\u003cendl; for(i=0;i\u003c3;i++) { iP=iMatrix[i]; //iP存放各行的起始地址(在内循环外) for(j=0;j\u003c4;j++) cout\u003c\u003csetw(6)\u003c\u003c*(iP+j); cout\u003c\u003cendl; } cout\u003c\u003c\"转置后的矩阵：\"\u003c\u003cendl; for(j=0;j\u003c4;j++) { for(i=0;i\u003c3;i++) { iP=iMatrix[i]; //iP存放各行的起始地址(在内循环中) cout\u003c\u003csetw(6)\u003c\u003c*(iP+j); } cout\u003c\u003cendl; } return 0; } ","date":"2021-02-06","objectID":"/09/:9:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"多级指针 多级指针一般又称为指针的指针。如果指针变量保存的是另一个指针变量的地址，则这个指针变量就是指针的指针。定义二级指针变量的一般形式是： \u003c类型标识符\u003e **二级指针变量名 例如： int i=5,*p=\u0026i,**pp=\u0026p; 使用指针操作二维数组，并输出相应的指针值（地址）。 注意：比较各级指针加1后，地址实际增加的量。 ","date":"2021-02-06","objectID":"/09/:10:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针数组 如果数组的每一个元素都是类型相同的指针变量，则该数组称为指针数组。声明指针变量数组的形式如下： \u003c类型标识符\u003e *指针数组名[数组长度] 例如： char *pString[6]; //声明一个保存6个char *型元素的指针数组 //今天星期几？ int i; char *pDay[]={\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\", \"Friday\",\"Saturday\",\"Sunday\"}; char **ppDay; cout\u003c\u003c\"输入整数1~7:\"; cin\u003e\u003ei; ppDay=pDay+i-1; cout\u003c\u003c\"Today is \"\u003c\u003c*ppDay\u003c\u003cendl; ","date":"2021-02-06","objectID":"/09/:11:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针变量作为函数参数 普通变量作为函数参数实现的是数值传递，而指针变量作为函数参数实现的是地址传递。 数值传递 数值传递是普通变量作为函数形参，主调函数中的实参内容是一个数值确定的表达式，适合少量数据的传递。 void change(int,int); //函数声明语句 int main(){ int a=5,b=10; cout\u003c\u003c\"函数调用前：a=\"\u003c\u003ca\u003c\u003c\" ,b=\"\u003c\u003cb\u003c\u003cendl; change(a,b); //以a、b的值为实参调用函数 cout\u003c\u003c\"函数调用后：a=\"\u003c\u003ca\u003c\u003c\" ,b=\"\u003c\u003cb\u003c\u003cendl; return 0; } void change(int m,int n){ int temp; temp=m; m=n; n=temp; cout\u003c\u003c\"函数中参数：m=\"\u003c\u003cm\u003c\u003c\",n=\"\u003c\u003cn\u003c\u003cendl; } 地址传递 地址传递是指针变量作为函数参数,这时主调函数中的实参是某个变量的内存地址，被调函数的形参则必须是与实参类型相同的指针变量，用以接受由实参传过来的地址。函数调用时，通过地址传递的实参与形参指向相同的内存单元，即形参所指内容与实参所指内容为同一段内存空间，因此形参所指内容发生更改，实参也会发生相应的更改。 从键盘输入两个整数，使用地址传递实现两数的真正交换。 void change(int *,int *); //函数声明语句 int main() { int a=5,b=10; cout\u003c\u003c\"函数调用前：a=\"\u003c\u003ca\u003c\u003c\" ,b=\"\u003c\u003cb\u003c\u003cendl; change(\u0026a,\u0026b); //以a、b值的地址为实参调用函数 cout\u003c\u003c\"函数调用后：a=\"\u003c\u003ca\u003c\u003c\" ,b=\"\u003c\u003cb\u003c\u003cendl; return 0; } void change(int *m,int *n) { int temp; temp=*m; *m=*n; *n=temp; cout\u003c\u003c\"函数中参数：m=\"\u003c\u003c*m\u003c\u003c\",n=\"\u003c\u003c*n\u003c\u003cendl; } 在C++中，需要返回多个变量值时，也可以采用地址传递的方式，将变量地址传给函数形参，在函数内通过指针直接修改位于函数外部的变量的值，从而实现返回多个值的目的。 ","date":"2021-02-06","objectID":"/09/:12:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指向函数的指针 要调用一个函数，只要知道被调用函数的入口地址即可。函数名实际上就是一个指针，它指向函数的入口地址。因此可以定义一个指针变量，并赋予它函数名，这样的指针变量就指向该函数的入口地址。称这样的指针变量为指向函数的指针变量，简称函数指针变量，通过函数指针变量就可以实现调用它所指函数的目的。 1．函数指针变量的声明与使用 函数指针变量声明的一般形式为： \u003c类型标识符\u003e (*函数指针变量名)(参数表) 注意： 类型标识符说明函数指针变量所指函数返回值的数据类型； 定义中的(*函数指针变量名)的两对圆括号都不能遗漏，否则就成了返回指针的函数； 参数表中形参的类型、个数都必须与所指的函数一致。 若定义函数：void func(int m,int n); 则指向该函数的函数指针变量可定义为： void (*pFpointer) (int,int); 使用已经定义的函数指针变量来调用函数，分以下两步： （1）将函数名赋予己定义的函数指针变量，其形式为： 函数指针变量名=函数名 如：pFpointer = func; （2）使用函数指针变量调用它所指的函数，可用的形式有： (*函数指针变量名)(实参表) 或： 函数指针变量名(实参表) 如，下面三个函数调用语句的功能是相同的： func(3,4); (* pFpointer)(3,4); pFpointer(3,4); 注意：函数的指针不能进行算术运算,因此不能： pFpointer++ //错误！ pFpointer-1 //错误！ 函数指针变量作为函数的参数 函数指针的用处在于可以作为函数参数传递给被调函数，使得被调函数可以根据情况，调用不同的的函数，增强其通用性。 将函数指针变量作为函数参数。 int add(int x,int y) { return x+y; } int sub(int x,int y) { return x-y; } int funct(int (*pFunc)(int,int),int x,int y) { int result; result=(*pFunc)(x,y); //等价于result=pFunc(x,y); return result; } int main() { int a,b; cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003c\"a+b=\"\u003c\u003cfunct(add,a,b)\u003c\u003cendl; cout\u003c\u003c\"a-b=\"\u003c\u003cfunct(sub,a,b)\u003c\u003cendl; return 0; } ","date":"2021-02-06","objectID":"/09/:13:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"用梯形积分公式求两个函数的积分 #include\u003ciostream\u003e#include\u003ciomanip\u003eusing namespace std; float f1(float x);//函数声明 float f2(float x);//函数声明 float integral(float (*p)(float),float a,float b);//函数声明 int main() { float s1,s2; s1=integral(f1,1,1.1);//函数调用 s2=integral(f2,1,1.1);//函数调用 cout\u003c\u003c\"s1=\"\u003c\u003csetprecision(5)\u003c\u003cs1\u003c\u003cendl; cout\u003c\u003c\"s2=\"\u003c\u003csetprecision(5)\u003c\u003cs2\u003c\u003cendl; system(\"pause\"); return(0); } float integral(float (*p)(float),float a,float b) { float sum; sum=0.5*(b-a)*(p(a)+p(b));//利用函数指针间接调用函数 return(sum); } float f1(float x) { float s; s=2*x+3; return(s); } float f2(float x) { float s; s=x*x-3*x+5; return(s); } ","date":"2021-02-06","objectID":"/09/:14:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"指针作为函数的返回类型 返回值是地址的函数称为指针函数，其定义的一般形式为： \u003c类型标识符\u003e*函数名(形参表) { 函数体 } //函数的返回值是指针类型。 #include\u003ciostream\u003eusing namespace std; int *pfun(int *p){ if(*p!=0) { cout\u003c\u003cp+1\u003c\u003cendl; return p+1; } else return p; } int main(){ int s[]={1,2,3}; cout\u003c\u003c*pfun(\u0026s[1])\u003c\u003cendl; // cout\u003c\u003cpfun(\u0026s[1])\u003c\u003cendl; system(\"pause\"); return 0; } 注意：作为函数的返回的指针，不能是在函数体内定义的局部变量。 ","date":"2021-02-06","objectID":"/09/:15:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"字符型指针与字符串 对字符串的再认识: 字符串由一系列字符组成，每一个字符在内存中按顺序存放，最后一个字符后面一定是结束符’\\0’ 。 在内存中识别字符串关键有以下两点： ①字符串的首地址。 ②字符串结束符’\\0’。 对字符串的处理通常是采用循环语句，从字符串的首地址开始，依次取出指针所指内存里的各个字符，直至遇到’\\0’为止。 ","date":"2021-02-06","objectID":"/09/:16:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"使用字符型指针定义字符串 使用字符型指针定义字符串的形式如下： char *指针变量名=\"字符串\" 注意：字符型指针比字符型数组更灵活（因为字符型数组只能初始化，不能再次赋值，而字符型指针定义字符串却可以！）。 char pString1[]=\"I love China!\"; char *pString2=\"This is a string2.\"; pString2=\"This is a new string2.\"; //允许，且新字符串更长！ pString1=\"This is a new string1.\"; //不允许，数组名不能再赋值pString2=pString1; //允许 pString1=pString2; //不允许，数组名不能被赋值 但是： *pString1 = 'a';//允许, pString1[0]= 'a' *pString2 = 'a';//不允许，使用字符型指针定义字符串后，指针所指单个内存的内容只允许读，不允许写！ *pString1 = *pString2;//允许, pString1[0]= pString2[0]=‘T' 使用字符型指针实现字符串的复制。 void copy_string(char *to,char *from)//复制函数 { for(;*from!='\\0';from++,to++) *to=*from; *to='\\0'; //赋值字符串结束标识 } int main() { char pSource[]=\"I am a teacher.\";//可以用char *pSource替换 char pDestination[]=\"you are a student.\"; //不能用char *pDestination替换（使用字符型指针定义字符串后，指针所指单个内存的内容只允许读，不允许写！ ） //pDestination字符数组长度\u003e=pSource字符数组长度 copy_string(pDestination,pSource); cout\u003c\u003c\"pSource:\"\u003c\u003cpSource\u003c\u003cendl; cout\u003c\u003c\"pDestination:\"\u003c\u003cpDestination\u003c\u003cendl; return 0; } ","date":"2021-02-06","objectID":"/09/:17:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"字符串标准库函数 C++提供了许多操作字符串的标准库函数，这些函数使用时，必须在应用程序的开头添加包含头文件string.h的预处理命令： #include \u003cstring\u003e //使用C++的标准库函数strcpy( )实现字符串的复制。 #include\u003ciostream\u003e #include \u003cstring\u003eusing namespace std; int main() { char pSource[]=\"I am a teacher.\"; //15个字符 char pDestination[]=\"you are a student.\"; //18个字符 //若char pDestination[]=“student.”; 后面拷贝时会错误！ //pDestination字符串长度\u003e=pSource字符串长度 strcpy(pDestination,pSource); //等价于strncpy(pDestination,pSource,16); cout\u003c\u003c\"pSource:\"\u003c\u003cpSource\u003c\u003cendl; cout\u003c\u003c\"pDestination:\"\u003c\u003cpDestination\u003c\u003cendl; return 0; } ","date":"2021-02-06","objectID":"/09/:18:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"动态内存分配与new和delete运算符 静态内存分配是指在编译阶段就分配好存储空间，其空间大小在程序运行过程中不可更改；动态内存分配则是在程序中通过调用内存分配函数malloc或内存分配运算符new取得存储空间； 区别：静态内存分配的变量空间，在其生存期结束后自动收回；而动态内存分配的存储空间，必须由程序员通过语句显式地将其归还给系统。 ","date":"2021-02-06","objectID":"/09/:19:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"new运算符 new运算符用于在内存中动态分配一块存储空间。new运算符的使用形式为： 指针变量=new \u003c类型标识符\u003e[长度] 例如： char *cBuffer=new char [256]; //分配256个char型数据的存储空间 注意： ①如果分配的存储空间长度为1个单位，则可以省略new运算符格式中的中括号和中括号中的整数。 如：int *pInt=new int; //等价于int *pInt=new int[1]; ②使用new运算符分配存储空间时，其空间长度可以是变量，也可以是数值表达式，但无论是什么，其类型必须是整型。 int nSize=5; int *pInt=new int[nSize+5]; ③由new所分配的存储空间是连续的，且通常将存储空间的首地址赋予一个指针变量，所以可以通过该指针的变化访问所分配存储空间的每一个元素。 ④如果当前内存无足够的存储空间可分配，则new运算符返回NULL。 由new运算符分配的内存空间在使用完毕之后必须使用delete运算符释放。 delete运算符的使用有两种形式： 形式一： delete指针 //释放空间长度为1个单位（与指针类型有关）的内存空间 形式二： delete [ ]指针 //释放空间长度大于1的内存空间 delete后面的是使用new运算符分配内存空间时返回的指针 ，也可以是NULL，若是NULL，则delete运算符什么也不做。 例如： int *pInt=new int; delete pInt; int *pManyInt = new int[10]; delete []pManyInt; 注意： ①用new运算符获得的内存空间，只许使用一次delete，不允许多次对同一块空间进行多次释放，否则将会产生严重错误。 ②delete只能用来释放由new运算符分配的动态内存空间，对于程序中的变量、数组的存储空间，不得使用delete运算符释放。 复制字符串，依据源字符串的长度动态分配目的字符串的存储空间。 #include \u003ciostream\u003eusing namespace std; void copy_string(char *to, char *from)//复制字符串函数 { char * tt=to; while(*from!='\\0’) *tt++=*from++; *tt='\\0';//赋值字符串结束标识 } int main() { char pSource[]=\"I am a teacher.\"; int nSize=0; while(pSource[nSize]!=0) nSize++; //定义目的字符串并申请分配内存空间(源字符串长度并加1) char *pDestination=new char[nSize+1]; if(pDestination!=NULL) { copy_string(pDestination,pSource); cout\u003c\u003c\"pSource:\"\u003c\u003cpSource\u003c\u003cendl; cout\u003c\u003c\"pDestination:\"\u003c\u003cpDestination\u003c\u003cendl; } else cout\u003c\u003c\"No memory space to copy operation!\"\u003c\u003cendl; delete []pDestination; system(\"pause\"); return 0; } ","date":"2021-02-06","objectID":"/09/:20:0","tags":["C++"],"title":"C++指针","uri":"/09/"},{"categories":["C++"],"content":"结构体 C++里数组是由相同数据类型的一组元素构成的集合，但实际问题中，经常会遇到由相互关联的，但类型不同的数据组成的数据结构。比如：描述一个学生的数据实体应该包括其学号、姓名、性别、年龄、成绩等数据。如果用多个独立的简单数据类型表示的话，就无法体现其整体性，也不便于数据的整体操作。 C++语言提供了结构体类型对这样的数据结构进行描述。 这里类似Python中的字典嵌套其他类型的键值对。 形式 struct \u003c结构体类型名\u003e { \u003c类型标识符\u003e 成员名l; \u003c类型标识符\u003e 成员名2; ………… \u003c类型标识符\u003e 成员名n; }; 例如： struct Student //定义学生结构体类型 { unsigned int no; //学号 char name[20]; //姓名 bool sex; //性别 int math; //高数成绩 int english; //英语成绩 int computer; //计算机成绩 float aver; //平均成绩 }; 注意： 1.结构体定义时，使用关键字struct,结构体类型的命名应符合C++标识符命名的规则，之后就可以用定义好的结构体类型的名字，与C++中的基本数据类型一样，也可以用来申明该结构体类型的变量。 2.花括号内是对该结构体各个成员的类型声明，成员声明的形式与变量定义的形式类似，成员可以是基本数据类型，也可以是另一个诸如结构体这样的复杂数据类型； 3.C++语言规定，结构体类型成员列表中不能包含自身,即不能递归定义，但可以包括其他结构体类型，或者是同类型的结构体指针。 4.结尾处的分号不能省略。 5.若同一个结构体类型要被多个源文件使用，则通常将这些结构体类型的定义集中存放在一个头文件中，使用该结构体的源文件只要用#include命令包含此头文件即可，不必再每个源文件中重复同样的结构体定义。 6.结构体类型定义只是说明了一个数据结构的模型，并没有定义实例，也不要求分配实际的存储空间。只有在定义结构体变量时，C++才为其分配内存。 ","date":"2021-02-01","objectID":"/08/:1:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"声明结构体变量 通常使用形式一，形式二是C语言形式。 形式： 形式一：\u003c结构体类型名\u003e 变量名 形式二：struct \u003c结构体类型名\u003e 变量名 声明结构体变量也可在定义结构体类型的同时进行： struct 结构体类型名 { \u003c类型标识符\u003e 成员名l; \u003c类型标识符\u003e 成员名2; ………… \u003c类型标识符\u003e 成员名n; }变量1,变量2,…… ,变量n; 实例： struct date { int year; int month; int day; }d1,d2; date d3,d4; 若省略结构体类型名，即成为无名结构体类型,无法再次使用该无名结构体类型再定义新的变量。 ","date":"2021-02-01","objectID":"/08/:2:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"结构体长度 结构体的长度是各个成员在内存中所占字节数之和。例如： Student stu; 则stu将在内存中占用41个字节，其中： unsigned int no; //4个字节 char name[20]; //20个字节 bool sex; //1个字节 int math; //4个字节 int english; //4个字节 int computer; //4个字节 float aver; //4个字节 ","date":"2021-02-01","objectID":"/08/:3:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"结构体变量的初始化 结构体变量的初始化形式为： \u003c结构体类型\u003e 变量名={表达式1,表达式2,…,表达式n} 注意： 1.表达式各类型要与结构体成员的类型对应一致。 2.只可在声明结构体变量时对其进行初始化，不可在定义结构体类型时，对结构体变量初始化。 //错误写法如下 struct date { int year; int month; int day; }d1; d1 ={2000,1,1}; //结构体的变量定义和初始化也不能分开 //错误写法如下 struct date { int year=2000; int month=1; int day=1; }; ","date":"2021-02-01","objectID":"/08/:4:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"结构体变量引用其成员的形式 访问一个结构体变量的成员的形式是： \u003c结构体变量名\u003e.\u003c成员名\u003e 其中，“.”称为成员运算符，它的优先级高于所有的算术运算符、条件运算符和逻辑运算符。 例子： Student stu={20130101,”XuXin”,false,86,90,98}; stu.ave=(stu.math+stu.english+stu.computer)/3; 如果一个结构体中包含另一个结构体作为其成员，则访问该成员中的成员时，要使用如下形式： \u003c结构体变量名\u003e.\u003c结构体成员名\u003e.\u003c成员名\u003e 例如在学生结构体Student中有一个成员表示学生的出生日期birthday，其类型是如下Date结构体: struct Date { int year; int month; int day; }; struct Student //定义新的学生结构体类型 { unsigned int no; //学号 char name[20]; //姓名 bool sex; //性别 Date birthday; //出生日期 int math; //高数成绩 int english; //英语成绩 int computer; //计算机成绩 float aver; //平均成绩 }stu1; 结构体变量本身不代表一个特定的值，因此无法直接对结构体变量进行算术运算、比较运算和逻辑运算，但作为一个整体结构体可以作为函数参数，同类型的结构体之间也可以相互赋值，其赋值规则是按成员依次进行赋值，如： date d1,d2={2001,1,15}; d1 = d2; ","date":"2021-02-01","objectID":"/08/:5:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"结构体数组 多个同一类型的结构体变量也可以用数组的形式来处理，称为结构体数组。 ","date":"2021-02-01","objectID":"/08/:6:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"共用体 C++允许同一段内存空间中存储不同类型的数据，用于节省内存空间或数据共享。这就需要使用共用体类型。 共用体在同一段内存空间存储不同类型的数据。共用体类型的定义： union [共用体类型名] { \u003c类型标识符\u003e 成员名1； \u003c类型标识符\u003e 成员名2； ………… \u003c类型标识符\u003e 成员名n； }[变量1,变量2,……,变量n]; 例如： union UnionDate { int nIntData; char cCharData; float fRealData; }; ","date":"2021-02-01","objectID":"/08/:7:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"共用体类型的定义和结构体类型定义很相似，不同之处在于结构体中的成员所占有的存储空间是各自分开，且整体连续的，而共用体的成员所占用的空间是共享的，即共用体的各个成员拥有同样的起始地址。因此对共用体中一个成员的赋值会影响到其他所有成员，且共用体所占空间的长度由其中所占空间的长度最长的成员决定。 声明共用体变量的形式为： \u003c共用体类型名\u003e 变量名 注意：共用体变量不允许赋初始值。 共用体变量中成员的访问形式为： \u003c共用体变量名\u003e.\u003c成员名\u003e ","date":"2021-02-01","objectID":"/08/:7:1","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"共用体与结构体的区别 struct Student { int no; char name[15]; int score[3]; float aver; } stu; union Utest { char a; int b; char c[15]; } uni; cout\u003c\u003c\"结构体变量stu的长度：\"\u003c\u003csizeof(stu)\u003c\u003cendl; cout\u003c\u003c\"共用体变量uni的长度：\"\u003c\u003csizeof(uni)\u003c\u003cendl; 注意：由于cpu的对界问题，sizeof返回的和实际长度不一致。这里采用4对齐。 struct S { int c1; int c2; }; union U { int a; int b; S d; }; int main() { U g; g.b=10; g.b=g.a+20; g.d.c1=g.a+g.b; cout\u003c\u003cg.a\u003c\u003c\", \" \u003c\u003cg.b\u003c\u003c\", \"\u003c\u003cg.d.c1\u003c\u003cendl; return(0); } 说明： 结构体类型S的长度为4+4=8字节，又由于结构体变量d是共用体类型U中占空间最长的成员，所以共用体变量g的长度为8个字节。其中a、b以及结构体变量d的成员c1占据同一段内存空间。因此：当g的成员b被赋值10后，g的成员a和d的成员c1也均为10，所以经过运算后，g.a、g.b、g.d.c1均为60. ","date":"2021-02-01","objectID":"/08/:8:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"枚举类型 枚举类型是一系列有标识名的整型常量的集合。枚举类型也是唯一允许用符号代表数据的数据类型，定义形式如下： enum \u003c枚举类型名\u003e{〈枚举常量表〉}[枚举变量] 例如： enum Days{Sun ,Mon,Tue,Wed,Thu,Fri,Sat} today; 说明：缺省时，系统为每一个枚举常量都对应一个整数，并从0开始，逐个增1，这些缺省的值也可重新指定，例如： enum Days{Sun ,Mon,Tue=4,Wed,Thu=8,Fri,Sat}today; 则各枚举常量对应的整数依次为0,1,4,5,8,9,10。 注意：枚举变量的取值只能是枚举常量表中的某个枚举常量，而不能用一个整型数据或其它类型数据直接赋值。例如： today=Mon; //合法，值为1 today=3; //不合法，不能直接赋值, today=(enum Days)3;//可以,也可以today=(Days)3;即强制类型转换！ int i=today; // 枚举变量直接赋值给整型变量，合法，值为3 注意：不要在定义枚举类型的同时，再对枚举常量、枚举变量或枚举类型名重新定义，例如下列定义均不合法： int today; int Sun; ","date":"2021-02-01","objectID":"/08/:9:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"实例 五色球中取三种不同颜色球的组合 #include\u003ciostream\u003eusing namespace std; int main() { enum color{red,yellow,blue,white,black}; int count=0; int i,j,k,t,temp; for(i=red;i\u003c=blue;++i) for(j=i+1;j\u003c=white;++j) { for(k=j+1;k\u003c=black;k++) { ++count; for(t=0;t\u003c3;++t) { switch(t) { case 0: temp=i;break; case 1: temp=j;break; case 2: temp=k;break; default: cout\u003c\u003c\"Impossible\\n\"; } switch((enum color)temp) { case red: cout\u003c\u003c\"red\\t\";break; case yellow: cout\u003c\u003c\"yellow\\t\";break; case blue: cout\u003c\u003c\"blue\\t\";break; case white: cout\u003c\u003c\"white\\t\";break; case black: cout\u003c\u003c\"black\\t\";break; default: cout\u003c\u003c\"Impossible\\n\"; } }//for t cout\u003c\u003cendl; } //for k } //for j cout\u003c\u003c\"共有\"\u003c\u003ccount\u003c\u003c\"种组合\\n\"; return(0); } ","date":"2021-02-01","objectID":"/08/:10:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"类型自定义语句 用户使用typedef语句可以将一个标识符定义为数据类型标识符。typedef语句的形式是： typedef\u003c已有的类型名\u003e\u003c类型别名\u003e 注意：typedef语句只可以将一个已有的类型名用一个新的类型名来代替； 例如： typedef float FLOAT; typedef char CH10[10]; //注意写法，不能用typedef char[10] CH10; 则可以： FLOAT x,y; CH10 str; //str是具有10个元素的字符型数组 它们等价于： float x,y; char[10] str; 又例如： struct complex { int real; int imag; }; typedef complex comp; comp cc ={1,2}; 或： typedef struct complex { int real; int imag; }comp; comp cc ={1,2}; ","date":"2021-02-01","objectID":"/08/:11:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"类和对象 类是面向对象程序设计的基础和核心，也是实现数据抽象的工具。 类实际上是一种特殊的用户自定义数据类型，但与一般的数据类型不同的是，类中不仅包含有一组数据，还有一组函数。 定义好的类，就可以用来声明变量，类的变量习惯称之为类的对象。 ","date":"2021-02-01","objectID":"/08/:12:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"类的定义 类定义的一般形式为： class \u003c类名\u003e { Private: \u003c私有成员函数和数据成员的声明\u003e Public: \u003c公有成员函数和数据成员的声明\u003e }; \u003c各个成员函数的定义\u003e 一般类中成员函数的原型声明写在类定义体内，而成员函数的定义一般写在类定义之外。通常采用下面的形式定义成员函数： \u003c类型标识符\u003e\u003c类名\u003e::\u003c成员函数名\u003e(形参表) { \u003c函数体\u003e } 作用域运算符（::）指出该成员函数所属的类 class CRectangle { private: int length,width; public: CRectangle(int l,int w) { length=l;width=w; } int get_area(); }; int CRectangle::get_area() { return length*width; } 说明： C++定义类时，可以将类的各个成员划分为不同的访问级别，即可以设置三种访问控制属性：public表示成员是公有的；private表示成员是私有的；protected表示成员是受保护的； 公有成员可以在程序中任何地方访问；而私有成员和保护成员都只有在类的内部能够访问（提高数据的安全性！） 设置三种访问控制属性的关键字： public,private,protected在类内出现的先后次序无关，并可以多次出现，但一个成员只能有一种访问控制属性。 ","date":"2021-02-01","objectID":"/08/:13:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"对象的使用 类与对象的关系，相当于普通数据类型与其变量的关系。类是一种抽象概念，一个类只是定义了一种新的数据类型，而只有申明对象时才真正创建了这种数据类型的物理实体。如： class CRectangle { private: int length = 0; //错误 int width = 0; //错误 }; 对象声明的一般形式为：\u003c类名\u003e \u003c对象名\u003e(实参表) 如： CRectangle c1(10,20); 可以用成员访问运算符“.”来引用类的成员，其一般形式为： \u003c对象名\u003e.\u003c数据成员名\u003e 或： \u003c对象名\u003e.\u003c成员函数名(实参表)\u003e 如： c1.get_area(); 注意：一般只有类的公有成员才能使用类成员访问运算符“.”，类的保护或私有成员不允许在类的外部被直接访问，只能通过类的公有成员函数来间接访问它们。 get、set函数 也可以通过设置友元（friend）,在类中为友元函数或友元类设置后门，允许它们访问类的保护或私有成员。 //通过长方形类的成员函数求长方形的面积。 class CRectangle { private: int length,width; public: //直接定义在类主体中的成员函数将自动成为内联函数（Inline Function） CRectangle(int l,int w) { length=l;width=w; } int get_area(); }; int CRectangle::get_area() { return length*width; } int main() { CRectangle c1(10,20); cout\u003c\u003c\"The area of rectangle:\"\u003c\u003cc1.get_area()\u003c\u003cendl; return 0; } ","date":"2021-02-01","objectID":"/08/:14:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"构造函数与析构函数 1.构造函数 构造函数的作用是在对象创建时使用特定的值构造对象，将对象初始化为一个特定的状态。构造函数的名字与它所属的类名相同，被声明为公有函数，且没有任何类型的返回值，在创建对象时被自动调用。例如： CRectangle(int l,int w) { length=l;width=w; } 每个类都必须有构造函数，若类定义时没有定义任何构造函数，编译器也会自动生成一个不带参数的缺省构造函数。当创建一个对象时，系统将自动调用该缺省构造函数来初始化对象，缺省的构造函数将对象的所有数据成员分配内存空间，但不进行初始化(数据成员的值为内存的随机值，所以必须提供公有set函数，设置私有数据的值）。 不建议这样使用！ 构造函数可以有默认的参数值,如： CRectangle(int l=1,int w=1){length=l;width=w;} CRectangle c1; 则 c1.length=c1. width=1; 构造函数可以有多个重载版本,例如： 若已经在类外定义了结构体： struct rect{int ll;int ww;}; 则可以： CRectangle(rect rc) {length=rc.ll;width=rc.ww;} 拷贝构造函数是构造函数的特例，它的作用是自动用一个已经存在的同类对象，去初始化另一个新的对象。 语法形式为：类名(类名 \u0026对象名); 拷贝构造函数是构造函数的重载形式，它的形参是本类对象的一个引用，实参为一个已存在的本类对象。 C++自动为每个类提供一个缺省的拷贝构造函数； 例如： CRectangle c1(10,20),c2(c1); 2.析构函数 析构函数的功能是用来释放一个对象的，析构函数本身并不删除对象，而是进行系统放弃对象之前的清理工作，它与构造函数的功能正好相反。 注意： 析构函数的名字是在类名前加字符“～”。 析构函数没有参数，也没有返回值。 析构函数不能重载，也就是说，一个类中只可能定义一个析构函数。 例如： ~CRectangle(); ","date":"2021-02-01","objectID":"/08/:15:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["C++"],"content":"最后一个实例 //CRectangle类的完整代码 #include\u003ciostream\u003eusing namespace std; struct rect { int ll; int ww; }; class CRectangle { private: int length,width; public: CRectangle(int l=1,int w=1){length=l;width=w;} CRectangle(rect rc); CRectangle(CRectangle \u0026rc); ~CRectangle(){ } int get_area(); void set(int l,int w); void get(int \u0026l,int \u0026w); }; CRectangle::CRectangle(rect rc) { length=rc.ll; width=rc.ww; } CRectangle::CRectangle(CRectangle \u0026rc) { length=rc.length; width=rc.width; } int CRectangle::get_area() { return length*width; } void CRectangle::set(int l,int w) {length = l; width = w; } void CRectangle::get(int \u0026l,int \u0026w) {l = length; w = width; } int main() { rect rr={1,2}; CRectangle c2(rr); CRectangle c1(c2); //c1.length=2; //无法存取类中的私有数据成员 //c1.width=3; //无法存取类中的私有数据成员 c1.set(2,3); cout\u003c\u003c\"The area of rectangle:\"\u003c\u003cc1.get_area()\u003c\u003cendl; int ll,ww; c1.get(ll,ww); cout\u003c\u003c\"length=\"\u003c\u003cll\u003c\u003c“,width=\"\u003c\u003cww\u003c\u003cendl; //cout\u003c\u003cc1.length\u003c\u003cendl; //无法存取类中的私有数据成员 return 0; } ","date":"2021-02-01","objectID":"/08/:16:0","tags":["C++"],"title":"C++自定义数据类型","uri":"/08/"},{"categories":["matlab","数学建模"],"content":"代码 clc;close all; %% 获取数据 day_i=3/10000 %日息 number_of_periods_i=day_i*30 %月利率 P=10000 %借款金额 N = 12 %还款期数 %% 模型选取及计算 Amount=P %借款金额 rate=number_of_periods_i %月利率 number_of_periods=N %贷款期数 command=input(‘输入0为等额本金还款，输入1为等额本息还款，输入2为等本等息还款，输入3为先息后本还款： ‘) if command==0 %等额本金还款方式 M=Amount/number_of_periods %每月偿还本金 for j=1:number_of_periods-1 Amount(j+1)=Amount(j)-M %月初余额 end R=Amount*rate %月底的利息 debt=Amount+R %月底欠款 M1=M+Amount*rate %月还款额 sum_R=sum(R) %总利息 sum_Amount=sum(M1) %还款总额 M=M-zeros(1,number_of_periods) data=[Amount’,R’,debt’,M’,M1’]%月初所欠金额 利息额 月末所欠金额 偿还本金 月末付款 [n,m]=size(data) result= cell(n+1,m) result(1,:)={‘月初所欠金额’,’利息额’,’月末所欠金额’,’偿还本金’,’月末付款’} result(2:end,:) = num2cell(data) xlswrite(‘data.xlsx’,result,’等额本金还款方式’)%输出excel fprintf(‘sum_R=%f’,sum_R) fprintf(‘sum_Amount=%f’,sum_Amount) elseif command==1 %等额本息还款方式 M=Amount*(rate*(1+rate)^number_of_periods)/((1+rate)^number_of_periods-1)%月还款额 for i=1:number_of_periods-1 Amount(i+1)=Amount(i)*(1+rate)-M %月初金额 end R=Amount*rate %月底的利息 mon=M-R %每月偿还本金 debt=Amount+R %月底欠款 sum_R=sum(R) %总利息 sum_Amount=M*number_of_periods %还款总额 M=M-zeros(1,number_of_periods) data=[Amount’,R’,debt’,M’-R’,M’]%月初所欠金额 利息额 月末所欠金额 偿还本金 月末付款 [n,m]=size(data) result= cell(n+1,m) result(1,:)={‘月初所欠金额’,’利息额’,’月末所欠金额’,’偿还本金’,’月末付款’} result(2:end,:) = num2cell(data) xlswrite(‘data.xlsx’,result,’等额本息还款方式’)%输出excel fprintf(‘sum_R=%f’,sum_R) fprintf(‘sum_Amount=%f’,sum_Amount) elseif command==2 %等本等息还款方式 M=Amount/number_of_periods %月还本金 for i=1:number_of_periods-1 Amount(i+1)=Amount(i)-M %月初金额 end R=[P*rate,P*rate,P*rate,P*rate,P*rate,P*rate,P*rate,P*rate,P*rate,P*rate,P*rate,P*rate] %月底的利息 debt=Amount+R %月底欠款 M2=M+R %月还款额 sum_R=sum(R) %总利息 sum_Amount=M*number_of_periods+P*rate*number_of_periods %还款总额 M=M-zeros(1,number_of_periods) data=[Amount’,R’,debt’,M’-R’,M2’]%月初所欠金额 利息额 月末所欠金额 偿还本金 月末付款 [n,m]=size(data) result= cell(n+1,m) result(1,:)={‘月初所欠金额’,’利息额’,’月末所欠金额’,’偿还本金’,’月末付款’} result(2:end,:) = num2cell(data) xlswrite(‘data.xlsx’,result,’等本等息还款方式’)%输出excel fprintf(‘sum_R=%f’,sum_R) fprintf(‘sum_Amount=%f’,sum_Amount) elseif command==3 %先息后本还款方式 M=0 %月还本金 for i=1:number_of_periods-1 Amount(i+1)=Amount(i)-M %月初金额 end R=Amount*rate %月底的利息 debt=Amount+R %月底欠款 M3=R %月还款额 sum_R=sum(R) %总利息 M4=debt sum_Amount=P+sum_R %还款总额 last_number_of_periods_debt=P+P*rate %最后一个月还款金额 M=M-zeros(1,number_of_periods) data=[Amount’,R’,debt’,M’,M3’]%月初所欠金额 利息额 月末所欠金额 偿还利息 月末付款 [n,m]=size(data) result= cell(n+1,m) result(1,:)={‘月初所欠金额’,’利息额’,’月末所欠金额’,’偿还本金’,’月末付款利息’} result(2:end,:) = num2cell(data) xlswrite(‘data.xlsx’,result,’先息后本还款方式’)%输出excel fprintf(‘sum_R=%f’,sum_R) fprintf(‘sum_Amount=%f’,sum_Amount) end ","date":"2021-02-01","objectID":"/41/:1:0","tags":["matlab","数学建模"],"title":"小额贷款的划算问题(matlab数学建模)","uri":"/41/"},{"categories":["matlab","数学建模"],"content":"源文档 完整文档详见：博客相关资源-小额贷款的划算问题 ","date":"2021-02-01","objectID":"/41/:2:0","tags":["matlab","数学建模"],"title":"小额贷款的划算问题(matlab数学建模)","uri":"/41/"},{"categories":["C++"],"content":"前言 这部分类同于Python，比如从0开始，都用[]来表示第几个元素。 ","date":"2021-01-28","objectID":"/07/:1:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"一维数组(score) 形式如下 \u003c类型标识符\u003e\u003c数组名\u003e[数组长度] 实例 int score[10]; int const N = 10; int n,m; int a[N]; //合法，N为常量 double[n],c[m*2]; //非法，n和m是变量 如果要访问一维数组的元素，形式如下： \u003c数组名\u003e[下标] 这里类似Python，不过下标不能从后往前检索使用负数，这里不同于Python。 实例： //声明一个数组，每个元素按顺序赋予从50到70以1递增的数。 int nDate[20]; for(int i=0;i\u003c20;i++) nDate[i]=i+50 //生成长度10的连续偶数序列，从2开始，保存在数组中，并输出此数组每个元素的值 #include\u003ciostream\u003eusing namespace std; int main() { int nEven(10); //定义用于存放的数组 int i; for(i=0;i\u003c10;i++) nEven[i]=i*2+2; //将生成偶数值赋给数组元素 for(i=0;i\u003c10;i++) { cout\u003c\u003cnEven[i]\u003c\u003c\"\"; //输出数组元素 } cout\u003c\u003cendl; return 0; } ","date":"2021-01-28","objectID":"/07/:2:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"一维数组的初始化(赋值元素) 形式： \u003c类型标识符\u003e\u003c数组名\u003e[数组长度]={元素值按顺序排列用,分开} 或 \u003c类型标识符\u003e\u003c数组名\u003e[]={第0个元素值,第1个元素值,……,第n个元素值} 注意： 第一种形式不给满元素值，剩下元素默认赋值0，赋值多于数组长度会报错；第二种形式不给定数组长度，赋值多少个就是有几个元素。 赋值时元素值不能为空。 ","date":"2021-01-28","objectID":"/07/:3:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"多维数组 多维数组不同在于下标的数目，这里以二维数组为主要方向学习。 二维数组命名形式： \u003c类型标识符\u003e\u003c数组名\u003e[第1维长度][第2维长度] 这里的存储方式是先存储第1维下标为0的元素，再存第1维下标为1的元素。等同于先存第一行，再存第二行。(行为第1维，列维第2维) 访问二维数组形式： \u003c数组名\u003e[第1维下标][第2维下标] 二维数组的初始化形式： \u003c类型标识符\u003e\u003c数组名\u003e[第1维长度][第2维长度]={ {第0个第2维数组}, {第1个第2维数组}, ……, {第n个第2维数组} } 另一种形式： \u003c类型标识符\u003e\u003c数组名\u003e[第1维长度][第2维长度]={第0个元素值,第1个元素值,……,第n个元素值} 这里的注意事项与1维数组相同。 实例： #include\u003ciostream\u003eint main() { int nRow; //控制行变量 int nCol; //控制列变量 int nMatrix[6][6]={0}; //二维数组声明，且数组元素被赋值为0 //生成5×5方阵 for(nRow=0;nRow\u003c5;nRow++) { for(nCol=0;nCol\u003c5;nCol++) { if(nRow%2==0) nMatrix[nRow][nCol]=nRow*5+nCol+1; else nMatrix[nRow][4-nCol]=nRow*5+nCol+1; } } //输出方阵 cout\u003c\u003c\"生成方阵：\\n\"; for(nRow=0;nRow\u003c5;nRow++) { for(nCol=0;nCol\u003c5;nCol++) { cout\u003c\u003cnMatrix[nRow][nCol]; if(nMatrix[nRow][nCol]\u003c10) //控制输出1位数与2位数时的不同间隔 cout\u003c\u003c\"\"; else cout\u003c\u003c\"\"; } cout\u003c\u003cendl; //没输出一行后换行 } cout\u003c\u003cendl; //计算5×5方阵各行及左上右下对角线之和 for(nRow=0;nRow\u003c5;nRow++) { for(nCol=0;nCol\u003c5;nCol++) { nMatrix[nRow][5]+=nMatrix[nRow][nCol]; //计算各行之和 nMatrix[5][nRow]+=nMatrix[nCol][nRow]; //计算各列之和 } nMatrix[5][5]+=nMatrix[nRow][nRow]; cout\u003c\u003c\"第\"\u003c\u003cnRow+1\u003c\u003c\"行之和：\"\u003c\u003cnMatrix[nRow][5]\u003c\u003c\"\\t\\t\"; cout\u003c\u003c\"第\"\u003c\u003cnRow+1\u003c\u003c\"列之和\"\u003c\u003cnMatrix[5][nRow]\u003c\u003cendl; } cout\u003c\u003c\"\\n左上右下对角线之和：\"\u003c\u003cnMatrix[5][5]\u003c\u003cendl; return 0; } 这里的数组如果声明为静态的，未赋值的自动清零，若数组未声明为静态的，则不赋值时元素不确定。 ","date":"2021-01-28","objectID":"/07/:4:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"一维数组名作为参数 形式 形式1：\u003c类型标识符\u003e\u003c函数名\u003e(类型标识符 数组名[],int 长度) 形式2：\u003c类型标识符\u003e\u003c函数名\u003e(类型标识符 数组名[长度]) 实例： //计算成绩平均值，定义函数ave() #include\u003ciostream\u003eusing namespace std; double ave(int a[],int n); int main() { const int N=20; int nScore[N]={90,88,45,92,76,59,89,93,60,51,91,65,82,74,92,35,66,78,62,91}; cout\u003c\u003c\"学生平均分数为：\"\u003c\u003cave(nScore,N)\u003c\u003cendl; return 0; } double ave(int a[],int n) { int i,nSum=0; for(i=0;i\u003cn;i++) nSum+=a[i]; return ((float)nSum/n); } 调试可发现主调函数里数组nScore和被调函数的形参数组a的起始地址一样，即数组nScore和形参数组a用同一段内存空间。 ","date":"2021-01-28","objectID":"/07/:5:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"二维数组的行地址作为参数 既然二维数组中的每一行相当一个一维数组，就可以把二维数组的行地址作为函数参数，实现传递这一行数据的目的。 #include\u003ciostream\u003eusing namespace std; double grade(double fArray[],int n); //评分函数声明 int main() { double fScoreData[5][6]= { {9.31,9.20,9.00,9.40,9.35,9.20}, {9.71,9.52,9.50,9.66,9.49,9.57}, {8.89,8.80,9.10,9.25,8.90,9.00}, {9.38,9.50,9.40,9.20,9.90,8.90}, {9.30,8.84,9.40,9.45,9.10,8.89} }; cout.precision(3); //设置总的有效位数（不是设置小数点后的位数！） cout\u003c\u003c\"歌手的最后得分为：\"\u003c\u003cendl; for(int nRow=0;nRow\u003c5;nRow++) { cout\u003c\u003cnRow+1\u003c\u003c\" 号选手成绩为：\"; cout\u003c\u003cgrade(fScoreData[nRow],6)\u003c\u003cendl; } return 0; } double grade(double fArray[],int n) //评分函数定义，n作为行向量的长度 { double fMark,fMax,fMin; //定义记录成绩、最高分、最低分的变量 fMark=fMax=fMin=fArray[0]; for(int i=1;i\u003cn;i++) { if(fArray[i]\u003efMax) fMax=fArray[i]; if(fArray[i]\u003cfMin) fMin=fArray[i]; fMark+=fArray[i]; } return (fMark-fMax-fMin)/(n-2); //计算出平均分并返回调用函数 } ","date":"2021-01-28","objectID":"/07/:6:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"数组与字符串 在C++语言中没有字符串变量类型，为了表示字符串，可以使用字符型数组，字符型数组的每一个元素分别保存字符串中的每一个字符。 char \u003c数组名\u003e[]=\"字符串\" char \u003c数组名\u003e[]={'字符串'} 有问题的写法： char MyStrinq[]={'T','h','i','s',' ','i','s',' ','a',' ','c','o','m','p','u','t','e','r'}; //缺少字符串的结束标志，输出有问题！ cout\u003c\u003cMyStrinq\u003c\u003cendl; 正确写法： char MyStrinq[]=\"This is a computer\"; char MyStrinq[]={\"This is a computer\"}; //它们等同于： char MyStrinq[]={'T','h','i','s',' ','i','s',' ','a',' ','c','o','m','p','u','t','e','r','\\0'}; 说明： 1.转义字符\\0(即8进制的0)，表示的是字符串常量中字符串的结束标志。故：char a[4]={‘t’,‘h’,‘i’,‘s’};cout\u003c\u003ca\u003c\u003cendl; 缺少字符串的结束标志，输出有问题。 2.字符型数组也是数组，故赋初值时必须和字符数组的定义在一起。 char str1[]; str1[]=\"abcd\"; 错误！ 3.不能有：字符型数组名= “字符串”; 如: MyStrinq =\"abcd\";错误！ 4.字符型数组的长度在声明时就已经确定（字符串中字符个数+1），在使用的过程中不能更改。 const int N = 20;t[N] = \"uvwxyz\"; 转义字符：\\ddd:1到3位8进制符号；\\xhh:1到2位16进制符号 ","date":"2021-01-28","objectID":"/07/:7:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"字符串基本操作 在C++中要实现字符串的运算，例如：连接两个字符串，求字符串的长度等，可以： 编写程序对字符型数组进行操作：通常要借助于循环结构，通过判断当前字符是否为空字符’\\0’，来确定是否循环到底。 直接调用C++的库函数中提供的各种字符串运算的函数。 //求字符串的长度 char pString[] = \"abcd\"; int nSize=0; while(pString[nSize]!='\\0') //从第一个字符开始直到碰到'\\0'为止 nSize++; 注意： 字符型数组的长度:包括'\\0’的长度！ 字符串的长度:不包括'\\0’的长度！ //字符串的复制:将字符数组s中的字符依此赋给字符数组t，直到碰到字符数组s中的'\\0'为止 char s[] = \"abcd\",t[] = \"uvwxyz\"; int i=0; while(s[i]!='\\0') //从第一个字符开始直到碰到'\\0'为止 { t[i] = s[i]; i++; } t[i]='\\0'; //注意修改字符串t的结尾！ cout\u003c\u003ct\u003c\u003cendl; 注意： 字符数组t的长度要大于等于s的，否则t[i]访问越界错误！ 注意： 被连接的字符串t的初始化长度要大于字符串t目前的长度+字符串s的长度+1 //将字符串s连接到字符串t的尾部，要先找到字符串t中的‘\\0‘,或确定字符串t的长度，然后从t的尾部开始依此将字符串s中字符赋给t； const int N = 20; //N要足够大！N大于等于s和t的字符数之和+1 char s[] = \"abcd\",t[N] = \"uvwxyz\"; int i=0,nSize=0; while(t[nSize]!='\\0') nSize++; do{ t[nSize++]=s[i++]; }while(s[i]!='\\0'); t[nSize]='\\0'; //修改字符串t的结尾！ cout\u003c\u003ct\u003c\u003cendl; //通常采用while或do-while循环结构访问字符数组 ","date":"2021-01-28","objectID":"/07/:8:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"最后的实例 //求字符串长度，复制、连接字符串。 #include\u003ciostream\u003eusing namespace std; int StringLength(char pS[]); void StringCopy(char pS[],char pD[]); void StringCat(char pTocat[],char pD[]); int main() { char str1[]=\"abcd\"; char str2[5]=\"\"; char str3[]=\"efg\"; cout\u003c\u003c\"str1：\"\u003c\u003cstr1\u003c\u003cendl; cout\u003c\u003c\"str2：\"\u003c\u003cstr2\u003c\u003cendl; cout\u003c\u003c\"str3：\"\u003c\u003cstr3\u003c\u003cendl; cout\u003c\u003c\"\\nstr1的长度：\" \u003c\u003cStringLength(str1)\u003c\u003cendl; cout\u003c\u003c\"\\nstr1字符串复制给str2后：\"; StringCopy(str1,str2); cout\u003c\u003cstr2\u003c\u003cendl; cout\u003c\u003c\"\\nstr3字符串连接到str1后：\"; StringCat(str3,str1); cout\u003c\u003cstr1\u003c\u003cendl; return 0; } //注意：一维字符数组作为函数参数时，函数的声明形式与普通一维数组的不同！不需要提供数组长度！ int StringLength(char pS[]) { int nSize=0; while(pS[nSize]!='\\0') nSize++; return nSize; } void StringCopy(char pS[],char pD[]) { int nIndex=0; while(pS[nIndex]!='\\0') pD[nIndex]=pS[nIndex++]; pD[nIndex]='\\0'; } void StringCat(char pTocat[],char pD[]) { int nSize=0,nIndex=0; while(pD[nSize]!=0) nSize++; do{ pD[nSize++]=pTocat[nIndex++]; }while(pTocat[nIndex]!='\\0'); pD[nSize]='\\0'; } ","date":"2021-01-28","objectID":"/07/:9:0","tags":["C++"],"title":"C++数组","uri":"/07/"},{"categories":["C++"],"content":"定义函数 \u003c类型标识符\u003e\u003c函数名\u003e(形式参数表) { 语句序列 } 实例： //求n! #include\u003ciostream\u003eusing namespace std; int factorial(int m); //原型声明 int main() { int n; cout\u003c\u003c\"Input n:\"; cin\u003e\u003en; cout\u003c\u003cn\u003c\u003c\"!=\"\u003c\u003c\"factorial(n)\"\u003c\u003cendl; //函数调用作为表达式出现在语句中 return 0; } int factorial(int m) { int i,result=1; for(i=1;i\u003c=m;i++) result *=i; return result; } ","date":"2021-01-25","objectID":"/06/:1:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"函数返回值及其类型 函数头部的类型标识符规定函数返回值的类型，函数的返回值是返回给主调用函数的处理结果，由函数体中的return语句带回。 return后也可以是一个表达式，该表达式的结果必须是一个确定的值，且类型必须与函数的返回类型一致。 无返回值的函数不必有return语句，这时函数的类型标识符必须为void。 ","date":"2021-01-25","objectID":"/06/:2:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"形式参数 形式参数简称形参，作用是用来实现主调函数与被调函数之间数据联系的，通常将函数所处理的数据、影响函数功能的因素等作为形参。 函数头部分的形参表内容如下： 类型1形参名1,类型2形参名2,类型3形参名3……类型n形参名n ","date":"2021-01-25","objectID":"/06/:3:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"函数调用 1.函数原型声明： \u003c类型标识符\u003e\u003c函数名\u003e(形式参数表); 例如： int factorial(int m); 注意： (1)函数原型声明是一个独立的语句，其后要加分号; (2)声明时，形式参数表中可以省略形参名，即只有类型名 (3)如果是在所有函数之前声明了函数原型，那么该函数原型在本程序中的任何地方都有效。如果只在函数内部声明，就只能在内部用有效。 2.函数的调用形式 \u003c函数名\u003e(实参1,实参2……实参n) eg: cout\u003c\u003cn\u003c\u003c\"!=\"\u003c\u003cfactorial(n)\u003c\u003cendl; 3.函数调用及返回的过程 函数的定义是平行的，但是函数的调用允许嵌套。 ","date":"2021-01-25","objectID":"/06/:4:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"函数的参数传递 当函数未被调用时，C++编译系统并没有给函数的形参分配相应的内存空间，并且直接将实参的值复制给形参。 实参可以是常量变量或表达式，其类型必须与形参相符。 #include\u003ciostream\u003eusing namespace std; void change(int a,int b); int main() { int x,y; cout\u003c\u003c\"Input x,y:\"; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"Before change\"\u003c\u003cendl; cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\" y=\"\u003c\u003cy\u003c\u003cendl; change(x,y); cout\u003c\u003c\"After change\"\u003c\u003cendl; return 0; } void change(int a,int b) { int t; t=a; a=b; b=t; } ","date":"2021-01-25","objectID":"/06/:5:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"引用传递 #include\u003ciostream\u003eusing namespace std; void change(int \u0026a,int \u0026b); int main() { int x,y; cout\u003c\u003c\"Input x,y:\"; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"Before change\"\u003c\u003cendl; cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\" y=\"\u003c\u003cy\u003c\u003cendl; change(x,y); cout\u003c\u003c\"After change\"\u003c\u003cendl; return 0; } void change(int \u0026a,int \u0026b) { int t; t=a; a=b; b=t; } 程序分析： 现在子函数change()的两个参数都是引用，当被调用时，它们分别被初始化成为a和b的别名。因此，在子函数change()中将两个形参的值进行交换后，交换的结果可以影响实参x和y，实现两个数的真正交换。 ","date":"2021-01-25","objectID":"/06/:6:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"递归调用 //求n!的值 #include\u003ciostream\u003eusing namespace int factorial(int n); int main() { int n; cout\u003c\u003c\"Input n:\"; cin\u003e\u003en; cout\u003c\u003cn\u003c\u003c\"!=\"\u003c\u003cfactorial(n)\u003c\u003cendl; return 0; } int factorial(int n) { int result; if(n==0) result =1; //递归结束条件 else result = n*factorial(n-1); //参数减1进行递归调用 return result; } 问题：5人坐在一起，问第1个人多少岁，他说比第2个人大2岁，问第2个人多少岁，他说比第3个人大2岁，……问最后一个人，他说是12岁。问第一个人多少岁。 #include\u003ciostream\u003eusing namespace std; int age(int n); int main() { cout\u003c\u003c\"第一个人的年龄\"\u003c\u003cage(1)\u003c\u003c\"岁\"\u003c\u003cendl; return 0; } int age(int n) { int result; if(n==5) result = 12; //递归结束条件 else result = age(n+1)+2; //以参数加1的方式继续递归 return result; } ","date":"2021-01-25","objectID":"/06/:7:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"默认参数值的函数 这里和Python的定义与作用一样。 //求x的n次方 #include\u003ciostream\u003eusing namespace std; int main() { int power(int x,int n=2); int x,n; cout\u003c\u003c\"Input x,n:\"; cin\u003e\u003ex\u003e\u003en; cout\u003c\u003cx\u003c\u003c\"^\"\u003c\u003cn\u003c\u003c\"=\"\u003c\u003cpower(x,n)\u003c\u003cendl; } int power(int x,int n=2) //第二个形参具有默认值 { if(n==0) return 1; else if(n==1) return x; else return (power(x,n-1)*x); } ","date":"2021-01-25","objectID":"/06/:8:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"内联函数 语法形式： 使用关键字inline \u003cinline\u003e\u003c类型标识符\u003e\u003c函数名\u003e(含类型说明的参数表) 编译程序在遇到这个命令时将记录下来，在处理内联函数的调用时，编译程序就1试图产生扩展码。 实际上就是函数调用时不再通过传参引用，而是在编译时将函数体嵌入到每一个调用语句处，节省了参数传递，系统栈的保护与恢复等的开销。 注意： 1.内联函数体内一般不含复杂的循环语句和switch语句。 2.内联函数声明和定义前必须加关键字inline。 3.内联函数不能进行异常接口声明。 如果违背上述注意事项，编译程序会无视inline的存在，像处理一般函数一样处理它，不产生扩展码。因此，只有使用频率很高的函数才被说明为内联函数，内联函数会扩大目标代码，使用需要谨慎。 //找最大值 #include\u003ciostream\u003e#include\u003ciomainip\u003eusing namespace std; inline int max(int a,int b); int main() { int a,b,c,d,result; cout\u003c\u003c\"Input a,b,c:\"; cin\u003e\u003ea\u003e\u003eb\u003e\u003ec; d=max(a,b); //编译时两次调用处均被替换为max函数体语句 cout\u003c\u003c\"The biggest of\" \u003c\u003cstew(5)\u003c\u003ca \u003c\u003cstew(5)\u003c\u003cb \u003c\u003cstew(5)\u003c\u003cc\u003c\u003c\"is\"\u003c\u003cresult\u003c\u003cendl; return 0; } inline int max(int a,int b) { if(a\u003eb) return a; else return b; } ","date":"2021-01-25","objectID":"/06/:9:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"函数重载 函数重载又称为多态函数，C++编译系统运行为两个或两个以上的函数取相同的函数名，但形参的个数或者形参类型至少有1个不同，编译系统会根据实参和形参的类型和个数匹配最佳，自动确定调用哪个函数。 //使用函数重载实现两个数据或三个数据的相加 #include\u003ciostream\u003eusing namespace std; int add(int x,int y) { return x+y; } int add(int x,int y,int z) { return x+y+z; } int main() { int x,y,z; cout\u003c\u003c\"Input x,y,z:\"; cin\u003e\u003ex\u003e\u003ey\u003e\u003ez; cout\u003c\u003c\"x+y=\"\u003c\u003cadd(x,y)\u003c\u003c\"\\nx+y+z=\"\u003c\u003cadd(x,y,z)\u003c\u003cendl; return 0; } 这里C++语言支持函数重载，C语言不支持。 ","date":"2021-01-25","objectID":"/06/:10:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["C++"],"content":"函数模板 对于算法来说，希望它可以处理多种数据类型，但即使这一算法被设计为重载函数也只是使用相同函数名，函数体需要分别定义。 形式： \u003ctemplate\u003e\u003cclass标识符\u003e \u003c类型标识符\u003e\u003c函数名\u003e(形式参数表) { …… } //任意类型两数相加 #include\u003ciostream\u003eusing namespace std; template\u003ctypename T\u003e T add(T a,T b) { T sum; sum = a+b; return sum; } int main() { int x,y; double m,n; cout\u003c\u003c\"Input int x,y:\"; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"x+y=\"\u003c\u003cadd(x,y)\u003c\u003cendl; cout\u003c\u003c\"Input double m,n:\"; cin\u003e\u003em\u003e\u003en; cout\u003c\u003c\"m+n=\"\u003c\u003cadd(m,n)\u003c\u003cendl; return 0; } 当调用函数add()时，编译系统从实参的类型推导出函数模板的类型参数T。意思是T的为各类型名随着实参的类型变化。 ","date":"2021-01-25","objectID":"/06/:11:0","tags":["C++"],"title":"C++函数","uri":"/06/"},{"categories":["电脑技巧"],"content":"C盘空间视图化显示软件 蓝奏云盘链接：点此跳转 ","date":"2021-01-23","objectID":"/cpan/:1:0","tags":["windows"],"title":"C盘清理视图化操作","uri":"/cpan/"},{"categories":["电脑技巧"],"content":"具体操作教程 视频教程点击这里跳转 ","date":"2021-01-23","objectID":"/cpan/:2:0","tags":["windows"],"title":"C盘清理视图化操作","uri":"/cpan/"},{"categories":["电脑技巧"],"content":"除了按照视频操作，如果你还发现什么占空间特别大的文件，欢迎评论区留言交流 ","date":"2021-01-23","objectID":"/cpan/:3:0","tags":["windows"],"title":"C盘清理视图化操作","uri":"/cpan/"},{"categories":["博客建站相关"],"content":"前言 fastpages博客只适用于GitHub托管。 fastpages博客没有主题选择，想要对页面进行修改，需要有前端html，css，JavaScript语言基础，直接对模板进行修改，各个页面模板在layout文件夹下，主页模板是根目录的index.html文件，需要修改主题可以自行修改。 fastpages缺点就是上述部分，优点如下： 1.本地不需要搭建站点，只需要按照格式命名文件，并在文件内容头部加上头部信息。 2.可以自定义添加评论区，方法简单。 3.支持jupyter notebook文件，markdown文件，word文件。 4.云端后端服务自动将上传的文件转化为html文件展示到博客上。 5.内置搜索。 6.可以嵌入Twitter卡和YouTube视频。 ","date":"2021-01-23","objectID":"/fastpages/:1:0","tags":["fastpages"],"title":"fastpages博客搭建指南","uri":"/fastpages/"},{"categories":["博客建站相关"],"content":"简单创建步骤 声明：源步骤链接—»\u003e原说明 本人将说明简化如下，如有遗漏，请阅读原说明。 视频教程点击这里跳转 该教程请配合视频–»\u003e 使用，如有错漏或疑问，评论区留言我会解答。 1.登陆GitHub账户，在保持登陆的情况下复制下面链接到浏览器打开创建分支—-»\u003ehttps://github.com/fastai/fastpages/generate 2.命名仓库名时不能使用格式为你的用户名.github.io 3.创建完成后等待actions选项中的进程都变为绿色后再进行下一步操作 4.完成上面选项后复制下面网址按照视频提示加载SSH keys—-»\u003e链接：https://8gwifi.org/sshfunctions.jsp 5.按照视频教程在Settings中的’Secrets’中添加私钥，在’Deploy keys’中添加公钥 6.等待actions选项中的进程都变为绿色后再进行下一步操作 7.上述步骤完成后在Pull requests中合并分支，点击下面绿色的merge pull request合并 8.首页README.md中显示你的博客地址，可以点击查看 9.按照视频教程修改_config.yml文件 10.按照视频教程修改index.html文件 11.按照视频教程修改pages文件夹中的about.md文件 12.写博客只需要在本地写好博客，md文件命名格式为2020-01-28-文章标题写这里.md，md文件内容头部信息格式如下： --- toc: true layout: post description: 文章概述 categories: [markdown] title: 标题 --- 13.jupyter notebook文件命名格式为2020-01-28-文章标题写这里.ipynb，word文件命名格式为2020-01-28-文章标题写这里.docx 14.只有md文件需要头部信息，其他文件不需要 15.上传不同格式的文档注意上传的文件夹是不同的，word文档上传到_word文件夹里，md文档上传到_posts文件夹里，jupyter notebook文档上传到_notebooks里 15.等待actions选项中的进程都变为绿色后则部署完成，刷新博客页面即可展示修改结果 ","date":"2021-01-23","objectID":"/fastpages/:2:0","tags":["fastpages"],"title":"fastpages博客搭建指南","uri":"/fastpages/"},{"categories":["博客建站相关"],"content":"示例博客 fastpages ","date":"2021-01-23","objectID":"/fastpages/:3:0","tags":["fastpages"],"title":"fastpages博客搭建指南","uri":"/fastpages/"},{"categories":["C++"],"content":"输入信息控制循环 输入信息控制循环通常控制的是无限循环(循环次数不确定的循环)。 通常使用while(或do while)语句构建无限循环。 统计输入的字符个数 #include\u003ciostream\u003eusing namespace std; int main() { char ch; int count=0; cout\u003c\u003c\"输入字符串，以#结束：\"; while(true) { cin\u003e\u003ech; if(ch=='#') break; cout++; } cout\u003c\u003c\"共输入\"\u003c\u003ccount\u003c\u003c\"个字母。\"\u003c\u003cendl\u003c\u003cendl; return 0; } ","date":"2021-01-19","objectID":"/05/:1:0","tags":["C++"],"title":"C++循环结构补充","uri":"/05/"},{"categories":["C++"],"content":"循环嵌套 输出乘法九九表： 二维表，先从上到下输出行，再从左到右输出列。 需要构建两个循环，外循环控制行，内循环控制列。 #include\u003ciostream\u003eusing namespace std; int main() { int i,j; for(i=1,i\u003c=9;i++) cout\u003c\u003ci\u003c\u003c\"\\t\" cout\u003c\u003c\"\\n-------------------------------\" \u003c\u003c\"----------------------------------------\\n\"; for(i=1;i\u003c=9;i++) { cout\u003c\u003ci\u003c\u003c\"\\t\"; for(j=1;j\u003c=9;j++) cout\u003c\u003ci*j\u003c\u003c\"\\t\"; cout\u003c\u003cendl; } return 0; } ","date":"2021-01-19","objectID":"/05/:2:0","tags":["C++"],"title":"C++循环结构补充","uri":"/05/"},{"categories":["C++"],"content":"其他控制语句 1.break语句 使用于循环中用于跳出或结束循环。 2.continue语句 使用于循环体中，作用是结束本次循环，然后判断循环条件，决定是否进行下一次循环。 实例： //运行这段程序可以多次输入学生百分制成绩，并分别对其进行成绩分级，直到输入-1结束程序。 #include\u003ciostream\u003eusing namespace std; int main() { int score; char result; while(true) { cout\u003c\u003c\"请输入学生百分制成绩(0~100,输入-1结束):\"; cin\u003e\u003escore; if(score==-1) break; if(score\u003c0||score\u003e100) { cout\u003c\u003c\"输入学生百分制成绩有错，请重新输入！\"\u003c\u003cendl\u003c\u003cendl; continue; } switch(score/10) { case 10: case 9: result = 'A'; break; case 8: result = 'B'; case 7: result = 'C'; case 6: result = 'D'; default: result = 'E'; } cout\u003c\u003c\"百分制成绩\"\u003c\u003cscore\u003c\u003c\"对应的成绩等级为：\" \u003c\u003cresult\u003c\u003cendl\u003c\u003cendl; } return 0; } ","date":"2021-01-19","objectID":"/05/:3:0","tags":["C++"],"title":"C++循环结构补充","uri":"/05/"},{"categories":["C++"],"content":"goto语句 goto语句的作用是使程序的执行流程跳转到语句标号所指定的语句。语法格式如下 goto\u003c语句标号\u003e 上面实例中的continue可以用goto语句替代。 …… while(true) { a1: cout\u003c\u003c\"请输入学生百分制成绩(0~100,输入-1结束):\"; cin\u003e\u003escore; if(score==-1) break; if(score\u003c0||score\u003e100) { cout\u003c\u003c\"输入学生百分制成绩有错，请重新输入！\"\u003c\u003cendl\u003c\u003cendl; goto a1; } …… } …… 实例： //一元二次方程求解 #include\u003ciostream\u003e#include\u003cmath.h\u003eusing namespace std; int main() { double a,b,c,d,x1,x2; cout\u003c\u003c\"一元二次方程：ax*x+bx+c=0\\n请输入系数a,b,c:\"; n1:cin\u003e\u003ea\u003e\u003eb\u003e\u003ec; if(a==0) { cout\u003c\u003c\"请重新输入系数a,b,c:\"; goto n1; } else { d=b*b-4*a*c; if(d\u003e=0) { x1=(-b+sqt(d))/(2*a); x2=(-b-sqt(d))/(2*a); cout\u003c\u003c\"x1=\"\u003c\u003cx1\u003c\u003cendl; cout\u003c\u003c\"x2=\"\u003c\u003cx2\u003c\u003cendl; } else cout\u003c\u003c\"此方程无解：\\n\"; } return 0; } 注意：goto语句的使用会破坏程序的结构，应该少用或不用。 ","date":"2021-01-19","objectID":"/05/:4:0","tags":["C++"],"title":"C++循环结构补充","uri":"/05/"},{"categories":["C++"],"content":"选择控制语句 if else 这里不像Python，每个分支语句后不需要加:，直接加 (Tab)后写分支语句，条件判断需要小加括号括起来，Python中是空格加条件，这点也不同。 if(x\u003e=0) cout\u003c\u003c\"y=\"\u003c\u003c1\u003c\u003cendl; else cout\u003c\u003c\"y=\"\u003c\u003c-1\u003c\u003cendl; 也可以省去else后的语句 if(x\u003e=0) cout\u003c\u003c\"y=\"\u003c\u003c1\u003c\u003cendl; 又到了经典的找最大值程序2333 #include\u003ciostream\u003eusing namespace std; int main() { int a,b,max; cout\u003c\u003c\"Input a,b:\"; cin\u003e\u003ea\u003e\u003eb; if(a\u003eb) max=a; else max=b; cout\u003c\u003c\"The max is:\"\u003c\u003cmax\u003c\u003cendl; return 0; } ","date":"2021-01-18","objectID":"/04/:1:0","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"用条件运算符?:代替if else语句 max=a\u003eb?a:b; 代替 if(a\u003eb) max=a; else max=b; cout\u003c\u003c\"The max is:\"\u003c\u003cmax\u003c\u003cendl; 代替后的程序如下： #include\u003ciostream\u003eusing namespace std; int main() { int a,b,max; cout\u003c\u003c\"Input a,b:\"; cin\u003e\u003ea\u003e\u003eb; /* if(a\u003eb) max=a; else max=b; if(c\u003emax) max=c; cout\u003c\u003c\"The max is:\"\u003c\u003cmax\u003c\u003cendl; */ //用？：运算符实现 max=(a\u003eb?a:b)\u003ec?(a\u003eb?a:b):c; cout\u003c\u003c\"The max is:\"\u003c\u003cmax\u003c\u003cendl; return 0; } 这里的if else语句缩减了格式，这是常用书写规范下需要合理选择的，花括号{}不能超过一屏等就是类似的常用书写规范。 ","date":"2021-01-18","objectID":"/04/:2:0","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"if else语句的嵌套 有两种形式嵌套if语句： if() if() else else if() else 或 if() else if() …… else if() else 无论是何种形式的if else嵌套，需要注意的是if和else的对应关系，有时候为了区分该层if的语句范围，用花括号{}括起来表示。 if() { if() 语句1} else 语句2 实例(考试成绩分级) #inclue\u003ciostream\u003e using namespace std; int main() { int score; char result; cout\u003c\u003c\"请输入学生百分制成绩(0~100):\"; cin\u003e\u003escore; if(score\u003e=90) result='A'; else if(score\u003e=80) result='B'; else if(score\u003e=70) result='C'; else if(score\u003e=60) result='D'; else result='E'; cout\u003c\u003c\"百分制成绩\"\u003c\u003cscore\u003c\u003c\"对应的成绩等级\"\u003c\u003cresult\u003c\u003cendl; return 0; } 这里成绩通过自上而下的方式筛选，实际也可以自下而上筛选。 ","date":"2021-01-18","objectID":"/04/:2:1","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"多路选择控制语句switch switch(测试表达式) { case 常量表达式1: 语句1 case 常量表达式2: 语句2 …… case 常量表达式n: 语句n default: 语句n+1 } 执行顺序： 1.执行测试表达式得到其值; 2.在case语句中找到值相等的常量表达式; 3.如果没有找到相等的常量表达式时，则从\"default:“开始执行。 注意： 1.switch后的括号()内只能是整型、字符型、枚举型; 2.各常量表达式的值不能相等，且次序不影响执行结果; 3.每个case语句只是一个入口标号，通常只需要执行一个case后的语句，所以每个case选择的最后应该加break语句，用来结束整个switch结构; 4.当若干选择需要执行相同操作时，可以使多个case选择共用一组语句。 用switch重做考试成绩分级： #include\u003ciostream\u003eusing namespace std; int main() { int score; char result; cout\u003c\u003c\"请输入学生百分制的成绩(0~100):\"; cin\u003e\u003escore; switch(score/10) { case 10: // result='A'; case 9: result='A'; break; case 8: result='B'; break; case 7: result='C'; break; case 6: result='D'; break; default: result='E'; } cout\u003c\u003c\"百分制成绩\"\u003c\u003cscore\u003c\u003c\"对应的成绩等级为：\"\u003c\u003cresult\u003c\u003cendl; return 0; } ","date":"2021-01-18","objectID":"/04/:3:0","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"循环控制结构 ###1.while语句 while(测试表达式) 循环体 这里判断测试表达式为true时，执行循环体，一般这里的循环体会用花括号{}括起来，判断测试表达式为false时，循环结束。 求自然数1~100之和。 #include\u003ciostream\u003eusing namespace std; int main() { int i=1,sum=0; while(i\u003c=100) { sum+=i; i++; } cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; return 0; } 程序运行情况： sum=5050 ","date":"2021-01-18","objectID":"/04/:4:0","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"do while语句 形式 do 循环体 while(测试表达式); 实例：求1~100之和 #include\u003ciostream\u003eusing namespace std; int main() { int i=1,sum=0; do{ sum += i; i++; }while(i\u003c=100); cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; return 0; } 这里do while语句与while语句不同之处在于是测试表达式的判断先后。 有限次循环三要素: 1.循环控制变量初始化； 2.循环结束条件； 3.循环变量更新。 ","date":"2021-01-18","objectID":"/04/:5:0","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"for语句 形式 for(初始化表达式;测试表达式;更新表达式) 循环体 实例： #include\u003ciostream\u003eusing namespace std; int main() { int i=1,sum=0; for(i\u003c1,i\u003c=100,i++) { sum +=i; } cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; return 0; } 程序段： int i=1,sum=0; for(i\u003c1,i\u003c=100;i++) { sum +=i } 可以缩写成 for(int i=1,sum=0;i\u003c=100;i++) sum+=i 如果省略初始化表达式和更新表达式，只有测试表达式，则完全等同于while语句。 for(;i\u003c=60;) sum+= i++; 等同于 while(i\u003c=60) sum+= i++; ","date":"2021-01-18","objectID":"/04/:6:0","tags":["C++"],"title":"C++程序控制结构","uri":"/04/"},{"categories":["C++"],"content":"赋值表达式 常规类似python，同样有赋值运算的简写形式，如 b += 2 //b = b + 2 x *= y + 3 //x = x*(y+3) x += x -= x*x //x = x + (x = x - x*x) ","date":"2021-01-15","objectID":"/03/:1:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"逗号表达式 在C++中，逗号也是一个运算符，使用形式为 \u003c表达式1\u003e,\u003c表达式2\u003e,……,\u003c表达式n\u003e 上述表达式的求解顺序为先求解表达式1，再求解表达式2，……，逗号表达式的最终结果为表达式n的值。 #include \u003ciostream\u003eusing namespace std; int main( ) { //赋值 int a=1,c=2,n,m; n = 2-(a=3); // n=2-a = 3 //错误 n += m -= a*a; cout\u003c\u003c\"c+2=\"\u003c\u003cc+2\u003c\u003cendl; // cout\u003c\u003cn = m = a\u003c\u003cendl; //错误 a = (c=5,c+5,c/2); cout\u003c\u003c\"a=\"\u003c\u003ca\u003c\u003cendl; //a=2,注意c+5并没给c赋值 // cout\u003c\u003ca=(c=5,c+5,c/5)\u003c\u003cendl; //错误 // cout\u003c\u003ca-c+5\u003c\u003cendl; int i=12; i + = i =i * =i; cout\u003c\u003c\"i=\"\u003c\u003ci\u003c\u003cendl; n = m = a; cout\u003c\u003c\"n=\"\u003c\u003cn\u003c\u003c\",=\"\u003c\u003cm\u003c\u003cendl; return 0; } 程序运行情况: C+2=4 a=2 i=0 n=2,m=2 ","date":"2021-01-15","objectID":"/03/:2:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"关系表达式\u0026比较运算符 记住下面这段东西： // 优先级相同(较高) \u003c,\u003c=,\u003e,\u003e= //优先级相同(较低) ==,!= //以上运算符与Python一样 注意：==是两个等于号，表示判断左边是否等于右边，返回值是true或者false。这里与Python中的判断语句一样。 ","date":"2021-01-15","objectID":"/03/:3:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"逻辑表达式 !(非) \u0026\u0026(与) ||(或) 优先级为前高后低 !是一元运算符，作用是操作数取反 \u0026\u0026和||是二元运算符，作用是判断返回值为true或false。 ","date":"2021-01-15","objectID":"/03/:4:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"条件表达式 条件运算符?:是C++中唯一的三元运算符，作用是实现简单的选择功能，形式如下： \u003c测试表达式\u003e?\u003c表达式1\u003e:\u003c表达式2\u003e 其中，测试表达式通常是bool类型，表达式1和表达式2可以是任何类型。 执行顺序： 1.求解测试表达式，求解出值; 2.若值为true，执行表达式1，表达式1的结果就是该条件表达式结果; 3.若值为false，执行表达式2，表达式2的结果就是该条件表达式结果; 注意： 条件运算符的优先级高于赋值运算符，低于逻辑运算符，结合方向自右向左。 eg:将a与b中的最大值赋值给max max=(a\u003eb)?a:b; ","date":"2021-01-15","objectID":"/03/:5:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"sizeof运算符 计算某种数据类型在内存中所占字节数。 //XXX是类型名 sizeof(XXX) //或者XXX是表达式 sizeof(XXX) //注意，这里的表达式并不会求解，只会返回表达式结果的类型所占的字节数 ","date":"2021-01-15","objectID":"/03/:6:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"位运算 这是Python中所没有的，高级语言处理数据最小单位只能是字节，C++可以对数据按二进制位进行操作。 C++中有6个位运算符，只能对整型数据进行操作。 1.按位与(\u0026) 将两个操作数对应每一位分别进行逻辑与操作。 3 00000011 5(\u0026) 00000101 ------------------ 3\u00265 00000001 这里与0相与，清零该位；与1相与，维持不变。 最常用的使用方法是将操作数中的若干位清零，或者取操作数中的若干指定位。 (1)将char型变量a的最低位清零： a=a\u00260xfe (2)设变量c是char型变量，变量a是int变量，下列语句可取出a的低字节，并放置于c中： c=a\u00260337; 2.按位或(|) 将两个操作数的对应每一位分别进行逻辑或操作。 3 00000011 5(|) 00000101 ------------------ 3|5 00000111 常用于将操作数中若嘎巴位的值置为1(其他位保持不变)。 将int型变量a的低字节置为1： a=a|0xff 3.按位异或(^) 将两个操作数对应每一位进行异或操作(对应位相同为0，不同为1)。 071 00111001 051(^) 00101010 ------------------------ 071^051 00010011 常用于将操作数中的若干指定位取反。 与0异或，结果是该位原值；与1异或，结果是该位值取反。 4.按位取反(~) 按位取反是一个单目运算符，作用是对一个二进制数的每一位取反。 025 00010101 ~025 11101010 5.移位 C++中有两个移位运算符：左移位运算符(«)，右移位运算符(»)。它们都是二元运算符。 移位运算符左边是操作数，右边是需要移动的位数。 移位规则： 左移，低位补0，移出的高位舍弃。 右移，低位舍弃，无符号数高位补0，有符号数高位补符号位。 设 short a = 65 ，则a\u003e\u003e1的操作过程如下 移位前： 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 移位后： (0) 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 (1) 补1位0 舍弃低1位 设 2\u003c\u003c4的值为32 ，则2\u003c\u003c4的操作过程如下 移位前： 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 移位后： (0 0 0 0) 0 0 0 0 0 0 0 0 0 0 1 (0 0 0 0) 舍弃高4位 补4位0 注意：移位运算的结果是位运算表达式的值。移位后，左边的值不变，即a»1后，a还是原值65。 ","date":"2021-01-15","objectID":"/03/:7:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"数据类型转换 1.将一种类型值赋值给另一种类型的变量 #include\u003ciostream\u003eusing namespace std; int main() { //整型和实型的赋值 int i = 3.56; //i赋值为3 int j = 1.8E12; //数值超出类型取值范围，j不能被正确赋值 float n = 5; //n被赋值为5.0 cout\u003c\u003c\" int i = \"\u003c\u003ci\u003c\u003cendl; cout\u003c\u003c\" int j = \"\u003c\u003cj\u003c\u003cendl; cout\u003c\u003c\" float n = \"\u003c\u003cn\u003c\u003c\" , n/2 =\"\u003c\u003cn/2\u003c\u003cendl; //bool类型的赋值 bool t1 = 19,t2 = 0; //t1被赋值为true，t2被赋值为false cout\u003c\u003c\" bool t1 = \"\u003c\u003ct1\u003c\u003c\" , bool t2 = \"\u003c\u003ct2\u003c\u003cendl; //取值范围不同类型的赋值 short s1 = 50; long l1 = s1; cout\u003c\u003c\" short s1 = \"\u003c\u003cs1\u003c\u003c\" , long l1 =\"\u003c\u003cl1\u003c\u003cendl; long l2 = 3500; short s2 = l2; //数值超过类型取值范围，s2不能被正确赋值 cout\u003c\u003c\" long l2 = \"\u003c\u003cl2\u003c\u003c\" , short s2 =\"\u003c\u003cs2\u003c\u003cendl; double d = 3.4E50; float f = d; //数值超出类型取值范围，f不能正确赋值 cout\u003c\u003c\" double d = \"\u003c\u003cd\u003c\u003c\" , float f =\"\u003c\u003cf\u003c\u003cendl; return 0 } 程序运行结果： int i = 3 int j = 408702976 float n = 5,n/2 = 2.5 bool t1 = 1,bool t2 = 0 short s1 = 50,long l1 = 50 long l2 = 3500,short s2 = -30536 double d = 3.4e+050,float = 1.#INF 小范围值可以赋值给大范围值，大范围值无法赋值给小范围值，此时会显示#INF表示不能正确赋值。 赋值运算要求左值与右值的类型相同，不同会自动进行类型转换，其转换的规则是将右值类型转换为左值的类型。 bool值赋值时，非0则赋值为true，0赋值为false。 ","date":"2021-01-15","objectID":"/03/:8:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"表达式的隐含转换 混合运算中二元运算符要求两边类型一致，若不一致，自动进行转换，由低到高。 大小关系如下 char short int unsigned long unsigned-long float double --------------------------------------------------------------------------------- 低 高 ","date":"2021-01-15","objectID":"/03/:9:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"强制类型转换\u0026显式转换 \u003c类型标识符\u003e(表达式) 或 (类型标识符)\u003c表达式\u003e 这里类似Python。 ","date":"2021-01-15","objectID":"/03/:10:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"输入与输出 1.cout cout\u003c\u003c\"\\\"This is a simple.\\\",he said.\\n\"; 输出结果为： “This is a simple.\",he said. 2.cin 程序需要键盘输入时，用提取操作符(»)从cin输入流中抽取字符，格式如下 cin\u003e\u003e变量名\u003e\u003e…… cin是预定义的流类对象，»是预定义的提取符，cin能自动识别输入的数据类型。 ","date":"2021-01-15","objectID":"/03/:11:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"I/O流控制符 包含在iomanip中 #include\u003ciomanip\u003e 头文件引入后可使用dec,hex,oct,ws,endl,ends,setprecision(int),setw(int) 其中较为常用的是设置宽域的setw()，插入换行符并刷新流的endl，插入空字符的ends。 cout\u003c\u003csetw(8)\u003c\u003c10\u003c\u003c20\u003c\u003cendl; 运行结果为 ------1020 例子： //用格式控制符控制输出 #include\u003ciostream\u003e#include\u003ciomainip\u003eusing namespace std; int main() { int k; double n; cout\u003c\u003c\"输入十进制整数K和实数n的值：\"; cin\u003c\u003ck\u003c\u003cn; cout\u003c\u003c\"\\tDecimal:\"\u003c\u003cdec\u003c\u003ck\u003c\u003cendl \u003c\u003c\"\\tHexadecimal:\"\u003c\u003chex\u003c\u003ck\u003c\u003cendl \u003c\u003c\"\\t0ctal:\"\u003c\u003coct\u003c\u003ck\u003c\u003cendl; cout\u003c\u003c\"设置域宽setw(5):\\n\"\u003c\u003csetw(5)\u003c\u003cn\u003c\u003cendl; //5\u003c7 cout\u003c\u003c\"设置域宽setw(10):\\n\"\u003c\u003csetw(10)\u003c\u003cn\u003c\u003cendl; //10\u003e7 cout\u003c\u003c\"设置小数位数setprecision(4):\\n\"\u003c\u003csetprecision(4)\u003c\u003cn\u003c\u003cendl; return 0 } 程序运行情况： 输入十进制整数K和实数n的值：1001 3.14159 Decimal:1001 Hexadecimal:3e9 Octal:1751 设置域宽setw(5): 3.14159 设置域宽setw(10): 3.14159 设置小数位数setprecision(4): 2.142 ","date":"2021-01-15","objectID":"/03/:12:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"插入部分C语言控制符和函数 1.printf(“格式控制符”,输出列表)和scanf(“格式控制符”,地址列表) #include\u003ciostream\u003eusing namespace std; int main() { int k; float n; char ch; printf(\"Input k,n,ch\") scanf(\"%d%f,%c\",\u0026k,\u0026n,\u0026ch); printf(\"k=%d,n=%f,ch=%c\\n\",k,n,ch); return 0 } 程序运行情况： Input k,n,ch:5 3.14,a k=5,n=3,ch=a printf(\"x=%dy=%f\\n\",x,y); 等同于 cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\"y=\"\u003c\u003cy; 2.getchar()和putchar() #include\u003ciostream\u003eusing namespace std; int main() { char ch; printf(\"Input ch:\"); //scanf()和printf() scanf(\"%c\",\u0026ch); printf(\"ch=5c\\n\",ch) //getchar()和putchar() // ch=getchar(); // putchar(ch); // putchar('\\n'); return 0; } 程序运行情况： Input ch:A ch=A ","date":"2021-01-15","objectID":"/03/:13:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"数据溢出 #include\u003ciostream\u003eusing namespace std; int main() { short a=32767,b; cout\u003c\u003c\"Input b:\"; cin\u003e\u003eb; a = a+b; cout\u003c\u003c\"sizeof=\"\u003c\u003csizeof(short)\u003c\u003cendl; cout\u003c\u003c\"a=\"\u003c\u003ca\u003c\u003c\",b=\"\u003c\u003cb\u003c\u003cendl; return 0; } 测试用例： Input b:2 sizeof=2 a=-32767,b=2 ","date":"2021-01-15","objectID":"/03/:14:0","tags":["C++"],"title":"C++简单程序","uri":"/03/"},{"categories":["C++"],"content":"如果有Python的基础，学习c++会感觉很别扭2333 如果是用VS写c++程序，注意打开文件夹包含.vscode文件夹，否则会运行找不到路径。 (Python就没那么麻烦，不用整json配置) ","date":"2021-01-10","objectID":"/02/:0:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"注释 /* 这是C++的 多行注释方法*/ /*******************/ //这是c++的单行注释方法 注释约定俗成写在程序上方或右方 ","date":"2021-01-10","objectID":"/02/:1:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"头文件 #include\u003ciostream\u003e .cpp文件开头在编译前将iostream.h文件中的代码嵌入到程序中，作为程序的一部分。 ","date":"2021-01-10","objectID":"/02/:2:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"主函数 int main() { cout\u003c\u003c\"hellow!\"\u003c\u003cendl; cout\u003c\u003c\"I am student\"\u003c\u003cendl; return 0; } main()之前的int表示主函数返回值的类型是整数类型int,函数主体用了花括号{}括起来，每个语句由;作为结束符。 另外，C++程序都是由函数构成的，在C++程序中，有且只能有一个main()函数，c++程序从主函数main()开始执行。 cout是输出语句，return是函数返回语句。 ","date":"2021-01-10","objectID":"/02/:3:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"名称空间 using namespace std; 这里的std是名称空间，类似python在库中预定义的方法一样，避免自己使用的名称存在歧义(即自己命名的标识符和所使用的类库的标识符重合的情况)，python中通过前缀库名解决，c++通过开头声明名称空间来解决。 ","date":"2021-01-10","objectID":"/02/:4:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"第一个c++程序 /*第一个c++程序*/ #include\u003ciostream\u003eusing namespace std; int main() { cout\u003c\u003c\"Hello world!\"\u003c\u003cendl; return 0; } ","date":"2021-01-10","objectID":"/02/:5:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"其他注意事项 1.编程预处理语句：#开头的行， 2.一个程序函数名可以很多，但是每个程序必须包含main()，程序总是从main()开始执行，不管main()处于程序哪个位置， 3.程序中符号都是英文符号，不是中文符号， 4.函数体由{}括起来，一般包含变量定义和程序功能实现部分，所有变量需要先定义再使用， 5.程序中标识符分大小写， 6.凡是空格符出现的地方都可以换行表示，运行结果一样。 ","date":"2021-01-10","objectID":"/02/:6:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"数据类型 测试数据类型字节数 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Size of char : \" \u003c\u003c sizeof(char) \u003c\u003c endl; cout \u003c\u003c \"Size of int : \" \u003c\u003c sizeof(int) \u003c\u003c endl; cout \u003c\u003c \"Size of short int : \" \u003c\u003c sizeof(short int) \u003c\u003c endl; cout \u003c\u003c \"Size of long int : \" \u003c\u003c sizeof(long int) \u003c\u003c endl; cout \u003c\u003c \"Size of float : \" \u003c\u003c sizeof(float) \u003c\u003c endl; cout \u003c\u003c \"Size of double : \" \u003c\u003c sizeof(double) \u003c\u003c endl; cout \u003c\u003c \"Size of wchar_t : \" \u003c\u003c sizeof(wchar_t) \u003c\u003c endl; return 0; } ","date":"2021-01-10","objectID":"/02/:7:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"转义字符\\ \\n 换行 \\t 横向跳格，输出位置跳到下一个制表位 \\b 退格，输出位置回退一个字符 \\r 回车，输出位置回退到本行开头 \\a 响铃 这里的\\类似Python中的r，作为转义字符使用 \\\\ 两个反斜杠实际表示一个反斜杠 ' 表示' \" 表示\" \\ddd 表示1~3位的八进制数 \\xhh 表示1~2位的十六进制数 #include\u003ciostream\u003eusing namespace std; int main() { //整型常量 int a=3; int b=023; int c=0x3a; int d=0x3A; cout\u003c\u003c\"整型常量：\\n赋值\\t\\t输出\\n\"; cout\u003c\u003c\"a=3,\\t\\ta=\"\u003c\u003ca\u003c\u003cendl; cout\u003c\u003c\"b=023,\\t\\tb=\"\u003c\u003cb\u003c\u003cendl; cout\u003c\u003c\"c=0x3a,\\tc=\"\u003c\u003cc\u003c\u003cendl; cout\u003c\u003c\"\\144=0x3A,\\t\\x64=\"\u003c\u003cd\u003c\u003cendl; //实型常量 double e=30000; //一般形式，大数 double f=0.00012; //一般形式，小数 double g=3.0E+4; //指数形式，大数 double h=0.12e-3; //指数形式，小数 cout\u003c\u003c\"\\xA实型常量：\\12赋值\\t\\t输出\\x0a\"; cout\u003c\u003c\"e=30000.0,\\te=\"\u003c\u003ce\u003c\u003cendl; cout\u003c\u003c\"f=0.0012\\tf=\"\u003c\u003cf\u003c\u003cendl; cout\u003c\u003c\"g=3.0E+4,\\tg=\"\u003c\u003cg\u003c\u003cendl; cout\u003c\u003c\"h=0.12e-3,\\th=\"\u003c\u003ch\u003c\u003cendl; } ","date":"2021-01-10","objectID":"/02/:8:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"变量声明与引用 声明形式如下 \u003c类型\u003e 变量名1,变量名2,……; 引用形式如下 \u003c类型\u003e \u0026引用名=目标名; eg： int r=10; //声明 int \u0026qr=r; //引用 实际qr=r=10,这里就是引用。 (这里如果是Python则直接用等号即可，c++需要在引用名前添加\u0026) ","date":"2021-01-10","objectID":"/02/:9:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"运算符 常规类似python，不同的如下。 1.单独使用自增自减运算符 int i=1,j=1; //前后置自增运算符单独执行 cout\u003c\u003c\"i=\"\u003c\u003ci\u003c\u003cendl; cout\u003c\u003c\"j=\"\u003c\u003cj\u003c\u003cendl; i++;++j; cout\u003c\u003c\"i=\"\u003c\u003ci\u003c\u003cendl; cout\u003c\u003c\"j=\"\u003c\u003cj\u003c\u003cendl; //运算后结果两者都为2 2.参与其他操作的自增自减运算符 int i=1,j=1; //参与其他操作的自增运算符 cout\u003c\u003c\"i=\"\u003c\u003ci\u003c\u003cendl; cout\u003c\u003c\"j=\"\u003c\u003cj\u003c\u003cendl; cout\u003c\u003c\"i++=\"\u003c\u003ci++\u003c\u003cendl; cout\u003c\u003c\"++j=\"\u003c\u003c++j\u003c\u003cendl; /* i=1 j=1 i++=1 ++j=2 */ 注意：自增自减运算符后置优先于前置。 ","date":"2021-01-10","objectID":"/02/:10:0","tags":["C++"],"title":"C++入门","uri":"/02/"},{"categories":["C++"],"content":"安装vscode 安装包 ","date":"2021-01-09","objectID":"/01/:1:0","tags":["C++"],"title":"C++环境安装","uri":"/01/"},{"categories":["C++"],"content":"教程安装C++用到的配置 压缩包解压后放到你装c++程序的文件夹里，里面的配置文件需要根据教程的第五步改。 压缩包链接 ","date":"2021-01-09","objectID":"/01/:2:0","tags":["C++"],"title":"C++环境安装","uri":"/01/"},{"categories":["C++"],"content":"安装教程 csdn链接 ","date":"2021-01-09","objectID":"/01/:3:0","tags":["C++"],"title":"C++环境安装","uri":"/01/"},{"categories":["C++"],"content":"暂时只安装c++环境，c环境有需要我再补充 ","date":"2021-01-09","objectID":"/01/:4:0","tags":["C++"],"title":"C++环境安装","uri":"/01/"},{"categories":["python","爬虫"],"content":"创建并使用多线程 print('主线程执行代码') # 从 threading 库中导入Thread类 from threading import Thread from time import sleep # 定义一个函数，作为新线程执行的入口函数 def threadFunc(arg1,arg2): print('子线程 开始') print(f'线程函数参数是：{arg1}, {arg2}') sleep(5) print('子线程 结束') # 创建 Thread 类的实例对象， 并且指定新线程的入口函数，此时并没有执行 thread = Thread(target=threadFunc, args=('参数1', '参数2') ) #target=threadFunc对应执行的函数threadFunc #args=('参数1', '参数2')这样新进程添加参数 # 执行start 方法，就会创建新线程， # 并且新线程会去执行入口函数里面的代码。 # 这时候这个进程有两个线程了。↓ thread.start() # 主线程的代码执行 子线程对象的join方法， # 就会等待子线程结束，才继续执行下面的代码 thread.join() print('主线程结束') 运行该程序，解释器执行到下面代码时 thread = Thread(target=threadFunc, args=('参数1', '参数2') ) 创建了一个Thread实例对象，其中，Thread类的初始化参数 有两个 target参数 是指定新线程的 入口函数， 新线程创建后就会 执行该入口函数里面的代码， args 指定了 传给 入口函数threadFunc 的参数。 线程入口函数 参数，必须放在一个元组里面，里面的元素依次作为入口函数的参数。 注意，上面的代码只是创建了一个Thread实例对象， 但这时，新的线程还没有创建。 要创建线程，必须要调用 Thread 实例对象的 start方法 。也就是执行完下面代码的时候 thread.start() 新的线程才创建成功，并开始执行 入口函数threadFunc 里面的代码。 有的时候， 一个线程需要等待其它的线程结束，比如需要根据其他线程运行结束后的结果进行处理。 这时可以使用 Thread对象的 join 方法 thread.join() 如果一个线程A的代码调用了 对应线程B的Thread对象的 join 方法，线程A就会停止继续执行代码，等待线程B结束。 线程B结束后，线程A才继续执行后续的代码。 就是等所一线程执行完毕才继续运行运行下面的程序 所以主线程在执行上面的代码时，就暂停在此处， 一直要等到 新线程执行完毕，退出后，才会继续执行后续的代码。 #错误示例！！！！ thread = Thread(target=threadFunc('参数1', '参数2')) ↑如果这样写无法创建新线程并执行，这样target传入不是函数，传入的是运行结果(null)，而且是在主线程运行完了，并不是在子线程里运行。 ","date":"2020-08-31","objectID":"/2020-08-31-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/:0:1","tags":["python","爬虫"],"title":"创建新线程(通用)","uri":"/2020-08-31-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/"},{"categories":["python","爬虫"],"content":"共享数据的访问控制 做多线程开发，经常遇到这样的情况：多个线程里面的代码需要访问同一个公共的数据对象。 这个公共的数据对象可以是任何类型， 比如一个列表、字典、或者自定义类的对象。 有的时候，程序需要防止线程的代码同时操作公共数据对象。否则，就有可能导致数据的访问互相冲突影响。 请看一个例子。 我们用一个简单的程序模拟一个银行系统，用户可以往自己的帐号上存钱。 对应代码如下： from threading import Thread from time import sleep bank = { 'byhy' : 0 } # 定义一个函数，作为新线程执行的入口函数 def deposit(theadidx,amount): balance = bank['byhy'] # 执行一些任务，耗费了0.1秒 sleep(0.1) bank['byhy'] = balance + amount print(f'子线程 {theadidx}结束') theadlist = [] for idx in range(10): thread = Thread(target = deposit, args = (idx,1) ) thread.start() # 把线程对象都存储到 threadlist中 theadlist.append(thread) for thread in theadlist: thread.join() print('主线程结束') print(f'最后我们的账号余额为 {bank[\"byhy\"]}') 上面的代码中，一起执行 开始的时候， 该帐号的余额为0，随后我们启动了10个线程， 每个线程都deposit函数，往帐号byhy上存1元钱。 可以预期，执行完程序后，该帐号的余额应该为 10。 然而，我们运行程序后，发现结果如下 子线程 0 结束 子线程 3 结束 子线程 2 结束 子线程 4 结束 子线程 1 结束 子线程 7 结束 子线程 5 结束 子线程 9 结束 子线程 6 结束 子线程 8 结束 主线程结束 最后我们的账号余额为 1 为什么是 1 呢？ 而不是 10 呢？ 如果在我们程序代码中，只有一个线程，如下所示 from time import sleep bank = { 'byhy' : 0 } # 定义一个函数，作为新线程执行的入口函数 def deposit(theadidx,amount): balance = bank['byhy'] # 执行一些任务，耗费了0.1秒 sleep(0.1) bank['byhy'] = balance + amount for idx in range(10): deposit (idx,1) print(f'最后我们的账号余额为 {bank[\"byhy\"]}') 代码都是串行执行的。不存在多线程同时访问bank对象的问题，运行结果一切都是正常的。 现在我们程序代码中，有多个线程，并且在这个几个线程中都会去调用deposit，就有可能同时操作这个bank对象，就有可能出一个线程覆盖另外一个线程的结果的问题。 这时，可以使用threading库里面的锁对象Lock去保护。 我们修改多线程代码，如下： from threading import Thread,Lock from time import sleep bank = { 'byhy' : 0 } bankLock = Lock() # 定义一个函数，作为新线程执行的入口函数 def deposit(theadidx,amount): # 操作共享数据前，申请获取锁 bankLock.acquire() balance = bank['byhy'] # 执行一些任务，耗费了0.1秒 sleep(0.1) bank['byhy'] = balance + amount print(f'子线程 {theadidx}结束') # 操作完共享数据后，申请释放锁 bankLock.release() theadlist = [] for idx in range(10): thread = Thread(target = deposit, args = (idx,1) ) thread.start() # 把线程对象都存储到 threadlist中 theadlist.append(thread) for thread in theadlist: thread.join() print('主线程结束') print(f'最后我们的账号余额为 {bank[\"byhy\"]}') 执行一下，结果如下 子线程 0 结束 子线程 1 结束 子线程 2 结束 子线程 3 结束 子线程 4 结束 子线程 5 结束 子线程 6 结束 子线程 7 结束 子线程 8 结束 子线程 9 结束 主线程结束 最后我们的账号余额为 10 正确了。 Lock对象的acquire方法是申请锁。 每个线程在操作共享数据对象之前，都应该申请获取操作权，也就是调用该共享数据对象对应的锁对象的acquire方法。 如果线程A执行如下代码，调用acquire方法的时候， bankLock.acquire() 别的线程B已经申请到了这个锁，并且还没有释放，那么线程A的代码就在此处等待线程B释放锁，不去执行后面的代码。 直到线程B执行了锁的release方法释放了这个锁，线程A才可以获取这个锁，就可以执行下面的代码了。 如果这时线程B又执行这个锁的acquire方法，就需要等待线程A执行该锁对象的release方法释放锁，否则也会等待，不去执行后面的代码。 ","date":"2020-08-31","objectID":"/2020-08-31-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/:0:2","tags":["python","爬虫"],"title":"创建新线程(通用)","uri":"/2020-08-31-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/"},{"categories":["python","爬虫"],"content":"daemon线程 from threading import Thread from time import sleep def threadFunc(): sleep(2) print('子线程 结束') thread = Thread(target=threadFunc) thread.start() print('主线程结束') 可以发现，主线程先结束，要过个2秒钟，等子线程运行完，整个程序才会结束退出。 因为： Python程序中当所有的 非daemon线程 结束了，整个程序才会结束 主线程是非daemon线程，启动的子线程缺省也是非daemon线程线程。 所以，要等到主线程和子线程都结束，程序才会结束。 我们可以在创建线程的时候，设置daemon参数值为True，如下 from threading import Thread from time import sleep def threadFunc(): sleep(2) print('子线程 结束') thread = Thread(target=threadFunc, daemon=True # 设置新线程为daemon线程 ) thread.start() print('主线程结束') 再次运行，可以发现，只要主线程结束了，整个程序就结束了。因为只有主线程是非daemon线程。 ","date":"2020-08-31","objectID":"/2020-08-31-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/:0:3","tags":["python","爬虫"],"title":"创建新线程(通用)","uri":"/2020-08-31-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/"},{"categories":["电脑技巧"],"content":"第三方词库资源 密码：QLHL 第三方词库下载链接 安装及使用视频 B站视频 ","date":"2020-07-27","objectID":"/weiruan/:0:0","tags":["windows"],"title":"微软输入法进化类搜狗输入法","uri":"/weiruan/"},{"categories":["matlab","数学建模"],"content":"通过下标引用矩阵元素 A(3,2)表示A矩阵第3行第2列的元素。\r 如若超出限制行列维数，自动扩展，未赋值的默认为0 通过序号来引用矩阵元素 A(3)等同于A(1,2)\r A(i,j)的序号为(j-1)×m+i ps:A(:)可以将矩阵A的每一列元素堆叠起来，成为一个列向量。 运算 数值运算是矩阵运算的特殊形式 .点运算是矩阵各个元素对应作运算 判断运算： == 等于 ~= 不等于 当参与比较的量是两个同型的矩阵时，比较是对两矩阵相同位置的元素按标量关系运算规则逐个进行，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成。 当参与比较的一个是标量，而另一个 是矩阵时，则把标量与矩阵的每一个元素按标量 关系运算规则逐个比较，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成。 逻辑运算： 在算术运算、关系运算和逻辑运算中，算术运算的优先级最高，逻辑运算优先级最低，但逻辑非运算是单目运算，它的优先级比双目运算要高。 ps:双目运算是有两个数参与运算。单目运算是只有一个数参与运算。a\u0026b是双目运算。~a是单目运算 若参与逻辑运算的是两个同型矩阵，那么将对矩阵相同位置上的元素按标量规则逐个进行运算，最终运算结果是一个与原矩阵同型的矩阵，其元素由1或0组成。 若参与逻辑运算的一个是标量，一个是矩阵，那么将在标量与矩阵中的每个元素之间按标量规则逐个进行运算，最终运算结果是一个与原矩阵同型的矩阵，其元素由1或0组成。 字符串的表示 字符串是用单引号括起来的字符序列 字符串占一行，可通过(:)索引，类似Python切片操作，但区间是前包后闭 若字符串包含单引号，用两个单引号表示一个单引号 实战： 字符串的执行 矩阵处理 1.通用的特殊矩阵 2.魔方矩阵 3.范德蒙矩阵 4.希尔伯特矩阵 5.伴随矩阵 6.帕斯卡矩阵 7.函数 ","date":"2020-07-02","objectID":"/2020-07-02-matlab02/:0:0","tags":["matlab","数学建模"],"title":"Matlab02(矩阵运算)","uri":"/2020-07-02-matlab02/"},{"categories":["matlab","数学建模"],"content":"基础命令 1.打开文件夹 命令行窗口输入 cd 文件夹名\r 这里推荐先在文件管理器先创建后打开 2.赋值变量会在工作区显示 可在命令行窗口输入whos 或 who 可以查看变量属性和具体参数 3.清空数据 clear\r 4.设置文件搜索路径 5.数字类型转换 class()函数可得数字类型 class(数字)\r 整型转换 int8() #转换成有符号的8位整型 uint8() #转换成无符号的8位整型 浮点型转换 数值数据默认为双精度型，可使用 single函数：single(数字)转换成单精度型 double函数：double(数字)转换成双精度型 复型 a+bi或a+bj real函数：取复型实部数据 image函数：取复型虚部数据 format命令格式 format long %输出长格式\rformat %输出短格式\rformat rat %输出有理数格式\r 这个不影响数据存储，只是表达方式不同 ps:%是注释符号，按ctrl+R注释一行，ctrl+T取消一行注释 6.常见函数 三角函数及取整函数 实战及其他函数 rem(除数,被除数)函数取余数 isprime(n)函数判断n是否为素数，当n是素数时返回1，否则返回0 find()函数找寻数组中的序列号 7.预定义变量 简单矩阵的建立 1.直接输入法 A=[1,2,3;4,5,6;7,8,9]\r 2.小矩阵拼接成大矩阵 A=[1,2,3;4,5,6;7,8,9] B=[-1,-2,3;-4,5,-6;-7,-8,-9] C=[A,B;B,A] 效果图： 3.用实部矩阵和虚部矩阵构成复数矩阵 B=[1,2,3;4,5,6] C=[6,7,8;9,10,11] A=B+i*C 效果图： 冒号表达式 结构矩阵和单元矩阵 ","date":"2020-07-01","objectID":"/2020-07-01-matlab01/:0:0","tags":["matlab","数学建模"],"title":"Matlab01(基础命令)","uri":"/2020-07-01-matlab01/"},{"categories":["python","数学建模"],"content":"前言 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:1:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"本篇鸣谢 马川-燕大 的增删整理， 王圣元 ——原创文章，与原文不同之处包含我的学习记录。 匹配Jupyter Notebook的ipynb文档链接下载地址在资源页面里 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:2:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"0 引言 Matplotlib 是 Python 中最基本的可视化工具，官网里 (https://matplotlib.org/) 好资料无数，可多多参考。 本章采用以下思路来讲解： 第一部分介绍 matplotlib 中的绘图逻辑，图包含的重要元素和他们之间的层级 (hierarchy) 第二部分只关注折线图 (line chart)，但是一步步从最初的烂图完善到最终的美图。这样可以把一种类型的图中的性质吃透，类比到其他类型的图一点也不难。 第三部分从画图的四大目的出发，即分布、联系、比较和构成，介绍了相对应的直方图 (historgram chart)，散点图 (scatter chart)，折线图 (line chart) 和饼状图 (pie chart)。这章偏向于用合适的图来实现不同的目的，没有在如何完善图的方面上下功夫，但在最后一节提到了如何画出使信息更有效的表达的图。 提纲： 和 NumPy, SciPy, Pandas 一样，要用 Matplotlib，首先引用其库。 import matplotlib 下面代码就是给 matplotlib 起了个别名 mpl，由于用 matplotlib.plot 比较多，也给它起了个别名 plt。 import matplotlib as mpl import matplotlib.pyplot as plt %matplotlib inline 而 %matplotlib inline 就是在 Jupyter notebook 里面内嵌画图的， 在画图中，个人偏好百度 Echarts 里面的一组颜色，因此将其 hex 颜色代码定义出来留在后面用。其中红色的 r_hex 和深青色的 dt_hex 是大爱。 r_hex = '#dc2624' # red, RGB = 220,38,36 dt_hex = '#2b4750' # dark teal, RGB = 43,71,80 tl_hex = '#45a0a2' # teal, RGB = 69,160,162 r1_hex = '#e87a59' # red, RGB = 232,122,89 tl1_hex = '#7dcaa9' # teal, RGB = 125,202,169 g_hex = '#649E7D' # green, RGB = 100,158,125 o_hex = '#dc8018' # orange, RGB = 220,128,24 tn_hex = '#C89F91' # tan, RGB = 200,159,145 g50_hex = '#6c6d6c' # grey-50, RGB = 108,109,108 bg_hex = '#4f6268' # blue grey, RGB = 79,98,104 g25_hex = '#c7cccf' # grey-25, RGB = 199,204,207 Hex Color RGB r_hex = ‘#dc2624’ # red RGB = 220,38,36 dt_hex = ‘#2b4750’ # dark teal RGB = 43,71,80 tl_hex = ‘#45a0a2’ # teal RGB = 69,160,162 r1_hex = ‘#e87a59’ # red RGB = 232,122,89 tl1_hex = ‘#7dcaa9’ # teal RGB = 125,202,169 g_hex = ‘#649E7D’ # green RGB = 100,158,125 o_hex = ‘#dc8018’ # orange RGB = 220,128,24 tn_hex = ‘#C89F91’ # tan RGB = 200,159,145 g50_hex = ‘#6c6d6c’ # grey-50 RGB = 108,109,108 bg_hex = ‘#4f6268’ # blue grey RGB = 79,98,104 g25_hex = ‘#c7cccf’ # grey-25 RGB = 199,204,207 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:3:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1 Matplotlib结构 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1.1 概览 Matplotlib 是一个巨无霸，乍一看无从下手，只能分解之后各点击破。总体来说，它包含两类元素： 基础 (primitives) 类：线 (line), 点 (marker), 文字 (text), 图例 (legend), 网格 (grid), 标题 (title), 图片 (image) 等。 容器 (containers) 类：图 (figure), 坐标系 (axes), 坐标轴 (axis) 和刻度 (tick) 基础类元素是程序员想画出的标准对象，而容器类元素是基础类元素的寄居处，它们也有层级结构。 图 → 坐标系 → 坐标轴 → 刻度 由上图看出： 图包含着坐标系 (多个) 坐标系由坐标轴组成 (横轴 xAxis 和纵轴 yAxis) 坐标轴上面有刻度 (主刻度 MajorTicks 和副刻度 MinorTicks) Python 中万物皆对象，Matplotlib 里这些元素也都是对象。下面代码打印出坐标系、坐标轴和刻度。 fig = plt.figure() ax = fig.add_subplot(1,1,1) plt.show() xax = ax.xaxis yax = ax.yaxis print( 'fig.axes:', fig.axes, '\\n') print( 'ax.xaxis:', xax ) print( 'ax.yaxis:', yax, '\\n' ) print( 'ax.xaxis.majorTicks:', xax.majorTicks, '\\n' ) print( 'ax.yaxis.majorTicks:', yax.majorTicks, '\\n') print( 'ax.xaxis.minorTicks:', xax.minorTicks ) print( 'ax.yaxis.minorTicks:', yax.minorTicks ) fig.axes: [\u003cmatplotlib.axes._subplots.AxesSubplot object at 0x000001C7E5D332B0\u003e] ax.xaxis: XAxis(54.0,36.0)\rax.yaxis: YAxis(54.0,36.0) ax.xaxis.majorTicks: [\u003cmatplotlib.axis.XTick object at 0x000001C7E5D54898\u003e, \u003cmatplotlib.axis.XTick object at 0x000001C7E5D54860\u003e, \u003cmatplotlib.axis.XTick object at 0x000001C7F8DB6B38\u003e, \u003cmatplotlib.axis.XTick object at 0x000001C7F8DB6D30\u003e, \u003cmatplotlib.axis.XTick object at 0x000001C7F8DCC470\u003e, \u003cmatplotlib.axis.XTick object at 0x000001C7F8DCC908\u003e] ax.yaxis.majorTicks: [\u003cmatplotlib.axis.YTick object at 0x000001C7E5D685C0\u003e, \u003cmatplotlib.axis.YTick object at 0x000001C7E5D54F60\u003e, \u003cmatplotlib.axis.YTick object at 0x000001C7F8DCCC88\u003e, \u003cmatplotlib.axis.YTick object at 0x000001C7F8DCC8D0\u003e, \u003cmatplotlib.axis.YTick object at 0x000001C7F8DD34E0\u003e, \u003cmatplotlib.axis.YTick object at 0x000001C7F8DD3668\u003e] ax.xaxis.minorTicks: [\u003cmatplotlib.axis.XTick object at 0x000001C7F8DA16A0\u003e]\rax.yaxis.minorTicks: [\u003cmatplotlib.axis.YTick object at 0x000001C7F8DAA940\u003e]\r 从打印结果可看出坐标系、坐标轴和刻度都是对象。细看一下发现 xaxis 和 yaxis 上面都有 6 个主刻度 (majorTicks)。 此外，由坐标系和坐标轴指向同一个图 (侧面验证了图、坐标系和坐标轴的层级性)。 print( 'axes.figure:', ax.figure ) print( 'xaxis.figure:', xax.figure ) print( 'yaxis.figure:', yax.figure ) axes.figure: Figure(432x288)\rxaxis.figure: Figure(432x288)\ryaxis.figure: Figure(432x288)\r 创造完以上四个容器元素后，可在上面添加各种基础元素，比如： 在坐标轴和刻度上添加标签 在坐标系中添加线、点、网格、图例和文字 在图中添加图例 如下图所示： 接下来四节分别介绍四大容器，首先从「图」开始。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:1","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1.2 图 图是整个层级的顶部。 在图中可以添加基本元素「文字」。 plt.figure() plt.text( 0.5, 0.5, 'Figure', ha='center', va='center', size=20, alpha=0.5 ) plt.xticks([]), plt.yticks([]) plt.show() 用 plt.text() 函数，其参数解释如下： 第一、二个参数是指横轴和纵轴坐标 第三个参数字符是指要显示的内容 ha, va 是横向和纵向位置 size 设置字体大小 alpha 设置字体透明度 (0.5 是半透明) 在图中可以添加基本元素「图片」。 import numpy as np from PIL import Image plt.figure() plt.xticks([]), plt.yticks([]) im = np.array(Image.open('images/小白.jpg')) #im = plt.imread('images/小白.jpg') # Mc: 这种方式打开也可以 plt.imshow(im) plt.show() 用 Image.open() 将图片转成像素存在 ndarray 中，再用 plt.imshow() 展示。 在图中可以添加基本元素「折线」。 plt.figure() plt.plot( [0,1],[0,1] ) plt.show() plt.plot() 函数是用来画折线图的，前两个参数分别是 x 和 y，该函数会在第二节细讲。 当我们每次说画东西，看起来是在图 (Figure) 里面进行的，实际上是在坐标系 (Axes) 里面进行的。一幅图中可以有多个坐标系，因此在坐标系里画东西更方便 (有些设置使用起来也更灵活)。 下面来看看层级中排名第二的「坐标系」。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:2","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1.3 坐标系 \u0026 子图 一幅图 (Figure) 中可以有多个坐标系 (Axes)，那不是说一幅图中有多幅子图 (Subplot)，因此坐标系和子图是不是同样的概念？ 在绝大多数情况下是的，两者有一点细微差别： 子图在母图中的网格结构一定是规则的 坐标系在母图中的网格结构可以是不规则的 由此可见，子图是坐标系的一个特例，来我们先研究特例。 子图 把图想成矩阵，那么子图就是矩阵中的元素，因此可像定义矩阵那样定义子图 - (子图行数、子图列数、第几个子图)。 subplot(rows, columns, i-th plots)\r 文字解释起来有些晦涩，看代码和图就好懂了。 1×2 子图 plt.subplot(2,1,1) plt.xticks([]),plt.yticks([])#隐藏坐标 plt.text(0.5, 0.5, 'subplot(2,1,1)', ha='center', va='center', size=20, alpha=.5 ) plt.subplot(2,1,2) plt.xticks([]), plt.yticks([]) plt.text( 0.5, 0.5, 'subplot(2,1,2)', ha='center', va='center', size=20, alpha=.5 ) plt.show() 这两个子图类似于一个列向量 subplot(2,1,1) 是第一幅 subplot(2,1,2) 是第二幅 声明完子图后，下面所有代码就只在这幅子图上生效，直到声明下一幅子图。 2×1 子图 plt.subplot(1,2,1) plt.xticks([]),plt.yticks([]) plt.text(0.5, 0.5, 'subplot(1,2,1)', ha='center', va='center', size=20, alpha=.5 ) plt.subplot(1,2,2) plt.xticks([]), plt.yticks([]) plt.text( 0.5, 0.5, 'subplot(1,2,2)', ha='center', va='center', size=20, alpha=.5 ) plt.show() 这两个子图类似于一个行向量 subplot(1,2,1) 是第一幅 subplot(1,2,2) 是第二幅 创建包含subplot网格的figure是一个非常常见的任务，matplotlib有一个更为方便的方法plt.subplots，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组。这是非常实用的，因为可以轻松地对axes数组进行索引，就好像是一个二维数组一样，例如axes[0,1]。你还可以通过sharex和sharey指定subplot应该具有相同的X轴或Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib会自动缩放各图表的界限。 2×2 子图 fig, axes = plt.subplots(nrows=2, ncols=2) # 可以轻松地对axes数组进行索引，就好像是一个二维数组一样 # axes[0,0].set( xticks=[], yticks=[] ) # s = 'My subplot' # axes[0,0].text( 0.5, 0.3, s, ha='center', va='center', size=20, alpha=.5 ) for i,ax in enumerate(axes.flat): #也可以axes.flatten()打平. flat将数组转换为1-D的迭代器,可以用for访问数组每一个元素;而flatten将数组的副本转换为一维(1-D)，并返回 ax.set( xticks=[], yticks=[] ) s = 'subplot(2,2,' + str(i) + ')' ax.text( 0.5, 0.5, s, ha='center', va='center', size=20, alpha=.5 ) plt.show() 这次我们用过坐标系来生成子图 (子图是坐标系的特例嘛)，第 1 行 fig, axes = plt.subplots(nrows=2, ncols=2)\r 得到的 axes 是一个 2×2 的对象。在第 8行的 for 循环中用 axes.flat 将其打平，然后在每个 ax 上生成子图。 坐标系 坐标系比子图更通用，有两种生成方式 用 gridspec 包加上 subplot() gridspec用于生成一个标准的虚拟网格，后面可以对它进行切片处理生成不规则的图 用 plt.axes() 不规则网格 import matplotlib.gridspec as gridspec G = gridspec.GridSpec(3,3)#三行三列 ax1 = plt.subplot(G[0,:]) plt.xticks([]),plt.yticks([]) plt.text( 0.5, 0.5, 'Axes 1', ha='center', va='center', size=20, alpha=.5 ) ax2 = plt.subplot(G[1,:-1])#只有序号为1的行 plt.xticks([]),plt.yticks([]) plt.text( 0.5, 0.5, 'Axes 2', ha='center', va='center', size=20, alpha=.5 ) ax3 = plt.subplot(G[1:,-1])#序号为1以后的行 1: plt.xticks([]),plt.yticks([]) plt.text( 0.5, 0.5, 'Axes 3', ha='center', va='center', size=20, alpha=.5 ) ax4 = plt.subplot(G[-1,0]) plt.xticks([]),plt.yticks([]) plt.text( 0.5, 0.5, 'Axes 4', ha='center', va='center', size=20, alpha=.5 ) ax5 = plt.subplot(G[-1,-2]) plt.xticks([]),plt.yticks([]) plt.text( 0.5, 0.5, 'Axes 5', ha='center', va='center', size=20, alpha=.5 ) plt.show() 第 2 行将整幅图分成 3×3 份赋值给 G，第 4, 8, 12, 16, 20 行分别用 plt.subplot(G[]) 生成五个坐标系。G[] 里面的切片和 Numpy 数组用法一样： G[0, :] = 图的第一行 (Axes 1) G[1, :-1] = 图的第二行，第二三列 (Axes 2) G[1:, -1] = 图的第二三行，第三列 (Axes 3) G[-1, 0] = 图的第三行，第一列 (Axes 4) G[-1, -2] = 图的第三行，第二列 (Axes 5) 大图套小图 plt.axes([0.1,0.1,0.8,0.8]) plt.xticks([]),plt.yticks([]) plt.text( 0.6, 0.6, 'axes([0.1,0.1,0.8,0.8])', ha='center', va='center', size=20, alpha=.5 ) plt.axes([0.2,0.2,0.3,0.3]) plt.xticks([]),plt.yticks([]) plt.text( 0.5, 0.5, 'axes([0.2,0.2,0.3,0.3])', ha='center', va='center', size=20, alpha=.5 ) Text(0.5, 0.5, 'axes([0.2,0.2,0.3,0.3])')\r 第 1 和 5 行分别用 plt.axes([l,b,w,h]) 其中 [l, b, w, h] 可以定义坐标系 l 代表坐标系左边到 Figure 左边的水平距离 b 代表坐标系底边到 Figure 底边的垂直距离 w 代表坐标系的宽度 h 代表坐标系的高度 如果 l, b, w, h 都小于 1，那它们是标准化 (normalized) 后的距离。比如 Figure 底边长度为 10， 坐标系底边到它的垂直距离是 2，那么 b = 2/10 = 0.2。 重叠图 plt.axes([0.1,0.1,0.5,0.5]) plt.xticks([]),plt.yticks([]) plt.text( 0.1, 0.1, 'axes([0.1,0.1,0.5,0.5])', ha='left', va='center', size=16, alpha=.5 ) plt.axes([0.2,0.2,0.5,0.5]) plt.xticks([]),plt.yticks([]) plt.text( 0.1, 0.1, 'axes([0.2,0.2,0.5,0.5])', ha='left', va='center', size=16, alpha=.5 ) plt.axes([0.3,0.3,0.5,0.5]) plt.xticks([]),plt.yticks([]) plt.text( 0.1, 0.1, 'axes([0.3,0.3,0.5,0.5])', ha='","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:3","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1.4 坐标轴 一个坐标系 (Axes)，通常是二维，有两条坐标轴 (Axis)： 横轴：XAxis 纵轴：YAxis 每个坐标轴都包含两个元素 容器类元素「刻度」，该对象里还包含刻度本身和刻度标签 基础类元素「标签」，该对象包含的是坐标轴标签 「刻度」和「标签」都是对象，下面代码通过改变它们一些属性值来进行可视化。 fig,ax = plt.subplots() ax.set_xlabel('Label on x-axis') ax.set_ylabel('Label on y-axis') for label in ax.xaxis.get_ticklabels():#设定刻度标签 #label is a Text instance label.set_color( dt_hex )#设定颜色 label.set_rotation(45)#设定字体逆时针旋转角度 label.set_fontsize(20)#设定字体大小 for line in ax.yaxis.get_ticklines():#设定对象的刻度本身 (即一条短线) #line is a Line2D instance line.set_color( r_hex ) line.set_markersize(500) line.set_markeredgewidth(30) plt.show() 第 2 和 3 行打印出 x 轴和 y 轴的标签。 第 5 到 9 行处理「刻度」对象里的刻度标签，将它颜色设定为深青色，字体大小为 20，旋转度 45 度。 第 11 到 15 行处理「标签」对象的刻度本身 (即一条短线)，将它颜色设定为红色，标记长度和宽度为 500 和 30 (夸张了些，但就为大家看清楚这条代表刻度的短线！)。 万物皆对象，坐标轴也不例外，下面代码打印出 x 轴的标签、刻度位置点、刻度标签、刻度线，刻度标签位置、主刻度。 print( ax.xaxis.get_label() )#x 轴的标签 print( ax.xaxis.get_ticklocs() )#x 轴的刻度位置点 print( ax.xaxis.get_ticklabels() )#x 轴的刻度标签 print( ax.xaxis.get_ticklines() )#x 刻度线 print( ax.xaxis.get_ticks_position() )#x 轴的刻度标签位置 print( ax.xaxis.get_major_ticks() )#x 轴的主刻度 Text(0.5,17.2,'Label on x-axis')\r[0. 0.2 0.4 0.6 0.8 1. ]\r\u003ca list of 6 Text major ticklabel objects\u003e\r\u003ca list of 12 Line2D ticklines objects\u003e\rbottom\r[\u003cmatplotlib.axis.XTick object at 0x000000000A5DDCF8\u003e, \u003cmatplotlib.axis.XTick object at 0x00000000087E5A58\u003e, \u003cmatplotlib.axis.XTick object at 0x0000000009C97F28\u003e, \u003cmatplotlib.axis.XTick object at 0x000000000A5FA6A0\u003e, \u003cmatplotlib.axis.XTick object at 0x000000000A5FACF8\u003e, \u003cmatplotlib.axis.XTick object at 0x000000000A600390\u003e]\r 问题：其他都好懂，比如 6 个刻度标签，但为什么有 12 条刻度线？不应该是 6 条吗？ get_ticklines 返回12个对象是因为将左侧(tick1line)与右侧(tick2line)的tickline都返回了，如果右侧的label也是开启的，get_ticklabels也会返回12个。 下面来看看层级中排名第四也是最后的「刻度」。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:4","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1.5 刻度 刻度 (Tick) 其实在坐标轴那节已经讲过了，它核心内容就是 一条短线 (刻度本身) 一串字符 (刻度标签) ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:5","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"1.6 基础元素 目前，我们已经介绍四个最重要的容器以及它们之间的层级 Figure → Axes → Axis → Ticks 图 → 坐标系 → 坐标轴 → 刻度 但要画出一幅有内容的图，还需要在容器里添加基础元素比如线 (line), 点 (marker), 文字 (text), 图例 (legend), 网格 (grid), 标题 (title), 图片 (image) 等，具体来说 画一条线，用 plt.plot() 或 ax.plot() 画个记号，用 plt.scatter() 或 ax.scatter() 添加文字，用 plt.text() 或 ax.text() 添加图例，用 plt.legend() 或 ax.legend() 添加图片，用 plt.imshow() 或 ax.imshow() 最后用 Matplotlib 官网的图来总结所有元素。 现在你基本理解了 Matplotlib 里面的绘图逻辑和元素，下两节分别从不同维度 (深度和广度) 研究如何画图： 第二节只研究一种类型的图「折线图」，但从头到尾不断根据需求添加元素完善它。深度研究做到完美！ 第三节研究四种类型的图 (展示数据的分布、联系、对比和组成)，却没在美感上下功夫，广度研究满足目的！ 但读完后两节后，你应该可以在各种类型的图上做到完美。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:4:6","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2 画美感图 本节记录着老板让斯蒂文绘图不断提需求直到把他逼疯的一段对话。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.1 画第一幅图 首先用 pd.read_csv 函数从存好的 S\u0026P500.csv，截屏如下： 该函数中三个参数代表： index_col = 0 是说把第一列 Date 当成行标签 (index) parse_dates = True 是说把行标签转成 date 对象 dayFirst = True 是说日期是 DD/MM/YYYY 这样的格式 import pandas as pd data = pd.read_csv( 'data/S\u0026P500.csv', index_col=0, parse_dates=True, dayfirst=True ) data.head(3).append(data.tail(3)) \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rOpen\rHigh\rLow\rClose\rAdj Close\rVolume\r\r\rDate\r\r\r\r\r\r\r\r\r\r\r1950-01-03\r16.660000\r16.660000\r16.660000\r16.660000\r16.660000\r1260000\r\r\r1950-01-04\r16.850000\r16.850000\r16.850000\r16.850000\r16.850000\r1890000\r\r\r1950-01-05\r16.930000\r16.930000\r16.930000\r16.930000\r16.930000\r2550000\r\r\r2019-04-22\r2898.780029\r2909.510010\r2896.350098\r2907.969971\r2907.969971\r2997950000\r\r\r2019-04-23\r2909.989990\r2936.310059\r2908.530029\r2933.679932\r2933.679932\r3635030000\r\r\r2019-04-24\r2934.000000\r2936.830078\r2926.050049\r2927.250000\r2927.250000\r3448960000\r\r\r\r\rS\u0026P 500 的数据从 1950 年 1 月 3 号开始，老板只需要 2007 年 1 月 1 日到 2010 年 1 月 1 日的数据。做个切片即可，存储成 spx。 spx = data[['Adj Close']].loc['2007-01-01':'2010-01-01'] spx.head(3).append(spx.tail(3)) \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rAdj Close\r\r\rDate\r\r\r\r\r\r2007-01-03\r1416.599976\r\r\r2007-01-04\r1418.339966\r\r\r2007-01-05\r1409.709961\r\r\r2009-12-29\r1126.199951\r\r\r2009-12-30\r1126.420044\r\r\r2009-12-31\r1115.099976\r\r\r\r\rspx 是个 DataFrame，将它的值一个个画出折线图只需用 plt.plot() 函数，展示在屏幕需用 plt.show()。 plt.plot( spx.values ) plt.show() 在 plot() 函数里面只有变量 y 时 (y = spx.values)，那么自变量就是默认赋值为 range(len(y))。 此外我们没有设置图的尺寸，像素、线的颜色宽度、坐标轴的刻度和标签、图例、标题等等，所有设置都用的是 matplotlib 的默认设置。 此图虽丑，但也满足了老板的需求，即标准普尔 500 指数在 2007-2010 的走势图。斯蒂文提交给了老板。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:1","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.2 图的默认设置 要修改图就必须知道它的属性，用 plt.rcParams 可查看上图的所有默认属性 (非常多的属性值)。 plt.rcParams RcParams({'_internal.classic_mode': False,\r'agg.path.chunksize': 0,\r'animation.avconv_args': [],\r'animation.avconv_path': 'avconv',\r'animation.bitrate': -1,\r'animation.codec': 'h264',\r'animation.convert_args': [],\r'animation.convert_path': 'convert',\r'animation.embed_limit': 20.0,\r'animation.ffmpeg_args': [],\r'animation.ffmpeg_path': 'ffmpeg',\r'animation.frame_format': 'png',\r'animation.html': 'none',\r'animation.html_args': [],\r'animation.mencoder_args': [],\r'animation.mencoder_path': 'mencoder',\r'animation.writer': 'ffmpeg',\r'axes.autolimit_mode': 'data',\r'axes.axisbelow': 'line',\r'axes.edgecolor': 'k',\r'axes.facecolor': 'w',\r'axes.formatter.limits': [-7, 7],\r'axes.formatter.min_exponent': 0,\r'axes.formatter.offset_threshold': 4,\r'axes.formatter.use_locale': False,\r'axes.formatter.use_mathtext': False,\r'axes.formatter.useoffset': True,\r'axes.grid': False,\r'axes.grid.axis': 'both',\r'axes.grid.which': 'major',\r'axes.hold': None,\r'axes.labelcolor': 'k',\r'axes.labelpad': 4.0,\r'axes.labelsize': 'medium',\r'axes.labelweight': 'normal',\r'axes.linewidth': 0.8,\r'axes.prop_cycle': cycler('color', ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']),\r'axes.spines.bottom': True,\r'axes.spines.left': True,\r'axes.spines.right': True,\r'axes.spines.top': True,\r'axes.titlepad': 6.0,\r'axes.titlesize': 'large',\r'axes.titleweight': 'normal',\r'axes.unicode_minus': True,\r'axes.xmargin': 0.05,\r'axes.ymargin': 0.05,\r'axes3d.grid': True,\r'backend': 'module://ipykernel.pylab.backend_inline',\r'backend.qt4': 'PyQt4',\r'backend.qt5': 'PyQt5',\r'backend_fallback': True,\r'boxplot.bootstrap': None,\r'boxplot.boxprops.color': 'k',\r'boxplot.boxprops.linestyle': '-',\r'boxplot.boxprops.linewidth': 1.0,\r'boxplot.capprops.color': 'k',\r'boxplot.capprops.linestyle': '-',\r'boxplot.capprops.linewidth': 1.0,\r'boxplot.flierprops.color': 'k',\r'boxplot.flierprops.linestyle': 'none',\r'boxplot.flierprops.linewidth': 1.0,\r'boxplot.flierprops.marker': 'o',\r'boxplot.flierprops.markeredgecolor': 'k',\r'boxplot.flierprops.markerfacecolor': 'none',\r'boxplot.flierprops.markersize': 6.0,\r'boxplot.meanline': False,\r'boxplot.meanprops.color': 'C2',\r'boxplot.meanprops.linestyle': '--',\r'boxplot.meanprops.linewidth': 1.0,\r'boxplot.meanprops.marker': '^',\r'boxplot.meanprops.markeredgecolor': 'C2',\r'boxplot.meanprops.markerfacecolor': 'C2',\r'boxplot.meanprops.markersize': 6.0,\r'boxplot.medianprops.color': 'C1',\r'boxplot.medianprops.linestyle': '-',\r'boxplot.medianprops.linewidth': 1.0,\r'boxplot.notch': False,\r'boxplot.patchartist': False,\r'boxplot.showbox': True,\r'boxplot.showcaps': True,\r'boxplot.showfliers': True,\r'boxplot.showmeans': False,\r'boxplot.vertical': True,\r'boxplot.whiskerprops.color': 'k',\r'boxplot.whiskerprops.linestyle': '-',\r'boxplot.whiskerprops.linewidth': 1.0,\r'boxplot.whiskers': 1.5,\r'contour.corner_mask': True,\r'contour.negative_linestyle': 'dashed',\r'datapath': 'G:\\\\ProgramData\\\\Anaconda3\\\\lib\\\\site-packages\\\\matplotlib\\\\mpl-data',\r'date.autoformatter.day': '%Y-%m-%d',\r'date.autoformatter.hour': '%m-%d %H',\r'date.autoformatter.microsecond': '%M:%S.%f',\r'date.autoformatter.minute': '%d %H:%M',\r'date.autoformatter.month': '%Y-%m',\r'date.autoformatter.second': '%H:%M:%S',\r'date.autoformatter.year': '%Y',\r'docstring.hardcopy': False,\r'errorbar.capsize': 0.0,\r'examples.directory': '',\r'figure.autolayout': False,\r'figure.dpi': 72.0,\r'figure.edgecolor': (1, 1, 1, 0),\r'figure.facecolor': (1, 1, 1, 0),\r'figure.figsize': [6.0, 4.0],\r'figure.frameon': True,\r'figure.max_open_warning': 20,\r'figure.subplot.bottom': 0.125,\r'figure.subplot.hspace': 0.2,\r'figure.subplot.left': 0.125,\r'figure.subplot.right': 0.9,\r'figure.subplot.top': 0.88,\r'figure.subplot.wspace': 0.2,\r'figure.titlesize': 'large',\r'figure.titleweight': 'normal',\r'font.cursive': ['Apple Chancery',\r'Textile',\r'Zapf Chancery',\r'Sand',\r'Script MT',\r'Felipa',\r'cursive'],\r'font.family': ['san","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:2","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.3 设置尺寸和 DPI 用 figsize 和 dpi 一起可以控制图的大小和像素。 函数 figsize(w,h) 决定图的宽和高 (单位是英寸)，而属性 dpi 全称 dots per inches，测量每英寸多少像素。两个属性一起用，那么得到的图的像素为 (wdpi, hdpi) 套用在下面代码中，我们其实将图的大小设置成 16×6 平方英寸，而像素设置成 (1600, 600)，因为 dpi = 100。 plt.figure( figsize=(16,6), dpi=100 ) plt.plot( spx.values ) plt.show() 运行代码生成大宽屏图！ ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:3","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.4 设置颜色-风格-宽度 在 plt.plot() 用 color，linewidth 和 linestyle 属性一起可以控制折线的颜色 (上面定义的深青色)、宽度 (2 像素) 和风格 (连续线)。 plt.figure( figsize=(16,6), dpi=100 ) plt.plot( spx.values, color=dt_hex, linewidth=2, linestyle='-' ) plt.show() 现在线条更明显了，而深青色看起来也比较有品位。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:4","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.5 设置边界 下面代码第 2 行在图中 (fig) 添加了一个坐标系 (ax)，然后所有操作都在 ax 里面完成，比如用 ax.plot() 来画折线 ax.set_xlim(), ax_set_ylim() 来设置横轴和纵轴的边界 fig = plt.figure( figsize=(16,6), dpi=100) ax = fig.add_subplot(1,1,1) x = spx.index y = spx.values ax.plot( x, y, color=dt_hex, linewidth=2, linestyle='-' ) #ax.set_xlim(['1/1/2007', '1/1/2010']) #ax.set_ylim( y.min()*0.8, y.max()*1.2 ); #加分号则不打印y.min()*0.8, y.max()*1.2 [\u003cmatplotlib.lines.Line2D at 0x1c7fc574fd0\u003e]\r 第 3 行的 x 是日期 (回顾 spx 是一个 DataFrame，行标签是日期)。 第 6 行将横轴的上下边界设为 2007-01-01 和 2010-01-01，只好是整个时间序列的起始日和终止日。 第 7 行将纵轴的上下边界设为 spx 的最小值的 0.8 倍和最大值的 1.2 倍。 现在横轴的刻度标签都是日期，比数字刻度带来的信息多；而 spx 图离顶部也有空间，看起来没那么挤。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:5","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.6 设置刻度和标签 上图横轴的刻度个数 (老板说日期隔得有点开) 和标签显示 (老板说只有年月) 都是默认设置。为了满足老板的要求，斯蒂文只能手动设置，用以下两个函数： 先用 ax.set_ticks() 设置出数值刻度 再用 ax.set_xticklabels() 在对应的数值刻度上写标签 fig = plt.figure( figsize=(16,6), dpi=100) ax = fig.add_subplot(1,1,1) x = spx.index y = spx.values ax.plot( y, color=dt_hex, linewidth=2, linestyle='-' ) ax.set_xlim(-1, len(x)+1) ax.set_ylim( y.min()*0.8, y.max()*1.2 ) ax.set_xticks( range(0,len(x),40)) ax.set_xticklabels( [x[i].strftime('%Y-%m-%d') for i in ax.get_xticks()], rotation=90 ); 第 7 行设置横轴的边界，下界是 - 1，上界是 len(x) +1。 第 10 行先设置横轴「数值刻度」为 range(0,len(x), 40)，即 0, 40, 80, …. 第 11 行在这些「数值刻度」上写标签，即格式为 %Y-%m-%d 的日期。由于日期个数比较多，而且日期字符比较长，直接在图中显示出来会相互重叠非常难看。这里调节参数 rotation = 90 使得日期逆时针转了 90 度，看上图效果好多了。 现在横轴的刻度标签是带「年-月-日」的日期，而且标签的间隔刚刚好。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:6","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.7 添加图例 添加图例 (legend) 非常简单，只需要在 ax.plot() 里多设定一个参数 label，然后用 ax.legend() 其中 loc = 0 表示 matplotlib 自动安排一个最好位置显示图例，而 frameon = True 给图例加了外框。 fig = plt.figure( figsize=(16,6), dpi=100) ax = fig.add_subplot(1,1,1) x = spx.index y = spx.values ax.plot( y, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) ax.legend( loc=0, frameon=True ) ax.set_xlim(-1, len(x)+1) ax.set_ylim( y.min()*0.8, y.max()*1.2 ) ax.set_xticks( range(0,len(x),40)) ax.set_xticklabels( [x[i].strftime('%Y-%m-%d') for i in ax.get_xticks()], rotation=90 ); 注意图的右上角多了图例 S\u0026P500。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:7","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.8 添加第二幅图 在改进代码之前，先介绍一下 VIX 指数。 知识点 VIX 指数是芝加哥期权交易所 (CBOE) 市场波动率指数的交易代号，常见于衡量 S\u0026P500 指数期权的隐含波动性，通常被称为「恐慌指数」，它是了解市场对未来30天市场波动性预期的一种衡量方法。 由其定义可知，S\u0026P500 指数涨时，VIX 跌，而 S\u0026P500 指数暴跌时，VIX 暴涨。 和之前一样，首先用 pd.read_csv 函数从存好的 VIX.csv 读取数据存成 DataFrame。 data = pd.read_csv( 'data/VIX.csv', index_col=0, parse_dates=True, dayfirst=True ) vix = data[['Adj Close']].loc['2007-01-01':'2010-01-01'] vix.head(3).append(vix.tail(3)) \r.dataframe tbody tr th:only-of-type {\rvertical-align: middle;\r}\r.dataframe tbody tr th {\rvertical-align: top;\r}\r.dataframe thead th {\rtext-align: right;\r}\r \r\rAdj Close\r\r\rDate\r\r\r\r\r\r2007-01-03\r12.040000\r\r\r2007-01-04\r11.510000\r\r\r2007-01-05\r12.140000\r\r\r2009-12-29\r20.010000\r\r\r2009-12-30\r19.959999\r\r\r2009-12-31\r21.680000\r\r\r\r\r添加第二幅图也很简单，用两次 plt.plot() 或者 ax.plot() 即可。这里面用的是 plt 没用 ax，没有特殊原因，在本例中两者可以随意使用，但两者在使用「.methods」时有个小细节不知道大家注意到没有， plt.xlim plt.ylim plt.xticks ax.set_xlim ax.set_ylim ax_set_xticks fig = plt.figure( figsize=(16,6), dpi=100) x = spx.index y1 = spx.values y2 = vix.values plt.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) plt.plot( y2, color=r_hex, linewidth=2, linestyle='-',label='VIX' ) plt.legend( loc=0, frameon=True ) plt.xlim(-1, len(x)+1) plt.ylim( np.vstack([y1,y2]).min()*0.8, np.vstack([y1,y2]).max()*1.2 ) x_tick = range(0,len(x),40) x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] plt.xticks( x_tick, x_label, rotation=90 ) plt.show() 这图怎么成这样？？？VIX 怎么是一条平线？ ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:8","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.9 两个坐标系 \u0026 两幅子图 S\u0026P500 的量纲都是千位数，而 VIX 的量刚是两位数，两者放在一起，那可不是 VIX 就像一条水平线一样。两种改进方式： 用两个坐标系 (two axes) 用两幅子图 (two subplots) 两个坐标系 fig = plt.figure( figsize=(16,6), dpi=100) ax1 = fig.add_subplot(1,1,1) x = spx.index y1 = spx.values y2 = vix.values ax1.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) ax1.set_xlim(-1, len(x)+1) ax1.set_ylim( np.vstack([y1,y2]).min()*0.8, np.vstack([y1,y2]).max()*1.2 ) x_tick = range(0,len(x),40) x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] ax1.set_xticks( x_tick ) ax1.set_xticklabels( x_label, rotation=90 ) ax1.legend( loc='upper left', frameon=True ) #Add a second axes ax2 = ax1.twinx() ax2.plot( y2, color=r_hex, linewidth=2, linestyle='-',label='VIX' ) ax2.legend( loc='upper right', frameon=True ); 用 ax1 和 ax2 就能实现在两个坐标系上画图，代码核心部分是第 19 行的 ax2 = ax1.twinx() 在每个坐标系下画图以及各种设置前面都讲的很清楚了。 Mc：股市那两条曲线的legend分开放在两侧，怎么看怎么别扭，还是放在一块显示比较好。 实现方式有二： 仅使用一个轴的legend()函数 使用figure.legend() fig = plt.figure( figsize=(16,6), dpi=100) ax1 = fig.add_subplot(1,1,1) x = spx.index y1 = spx.values y2 = vix.values lns1 = ax1.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) ax1.set_xlim(-1, len(x)+1) ax1.set_ylim( np.vstack([y1,y2]).min()*0.8, np.vstack([y1,y2]).max()*1.2 ) x_tick = range(0,len(x),40) x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] ax1.set_xticks( x_tick ) ax1.set_xticklabels( x_label, rotation=90 ) # ax1.legend( loc='upper left', frameon=True ) #Add a second axes ax2 = ax1.twinx() lns2 = ax2.plot( y2, color=r_hex, linewidth=2, linestyle='-',label='VIX' ) # ax2.legend( loc='upper right', frameon=True ); # 方法一：仅使用一个轴的legend()函数 #lns = lns1+lns2 #labs = [l.get_label() for l in lns] #ax2.legend(lns, labs, loc=0) # 方法二：使用figure.legend() fig.legend(loc=1, bbox_to_anchor=(0.88,1.05), bbox_transform=ax.transAxes) \u003cmatplotlib.legend.Legend at 0x1c7fb007780\u003e\r 两幅子图 plt.figure( figsize=(16,12), dpi=100) # subplot 1 plt.subplot(2,1,1) x = spx.index y1 = spx.values plt.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) plt.xlim(-1, len(x)+1) plt.ylim( y1.min()*0.8, y1.max()*1.2 ) x_tick = range(0,len(x),40) x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] plt.xticks( x_tick, x_label, rotation=45 ) plt.legend( loc='upper left', frameon=True ) # subplot 2 plt.subplot(2,1,2) y2 = vix.values plt.plot( y2, color=r_hex, linewidth=2, linestyle='-',label='VIX' ) plt.xlim(-1, len(x)+1) plt.ylim( y2.min()*0.8, y2.max()*1.2 ) plt.xticks( x_tick, x_label, rotation=45 ) plt.legend( loc='upper left', frameon=True ) plt.show() 定义 subplot(2,1,1) 和 subplot(2,1,2) 就能实现再两幅子图上画图。 在每幅子图上画图以及各种设置前面都讲的很清楚了。 这两种方法都可用，但在本例中，S\u0026P500 和 VIX 放在一起 (用两个坐标系) 更能看出它们之间的关系，比如 2008 年 9 月到 2009 年 3 月的金融危机期间，S\u0026P 500 在狂泻和 VIX 在飙升 。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:9","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.10 设置标注 在金融危机时期，市场发生了 5 件大事，分别是 2017-10-11: 牛市顶点 2008-03-12: 贝尔斯登倒闭 2008-09-15: 雷曼兄弟倒闭 2009-01-20: 苏格兰皇家银行股票抛售 2009-04-02: G20 峰会 加标注的代码略长，新内容为 第 3-7 行的定义危机事件，以元组的列表存储 第 26-34 行的事件标注，用到 annotate() 函数 from datetime import datetime fig = plt.figure( figsize=(16,6), dpi=100) crisis_data = [(datetime(2007, 10, 11), 'Peak of bull market'), (datetime(2008, 3, 12), 'Bear Stearns Fails'), (datetime(2008, 9, 15), 'Lehman Bankruptcy'), (datetime(2009, 1, 20), 'RBS Sell-off'), (datetime(2009, 4, 2), 'G20 Summit')] ax1 = fig.add_subplot(1,1,1) x = spx.index y1 = spx.values y2 = vix.values ax1.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) ax1.set_xlim(-1, len(x)+1) ax1.set_ylim( np.vstack([y1,y2]).min()*0.8, np.vstack([y1,y2]).max()*1.2 ) x_tick = range(0,len(x),40) x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] ax1.set_xticks( x_tick ) ax1.set_xticklabels( x_label, rotation=90 ) ax1.legend( loc='upper left', frameon=True ) for date, label in crisis_data: date = date.strftime('%Y-%m-%d') xi = x.get_loc(date) yi = spx.asof(date) ax1.scatter( xi, yi, 80, color=r_hex ) ax1.annotate( label, xy=(xi, yi + 60), xytext=(xi, yi+300), arrowprops=dict(facecolor='black',headwidth=4,width=1,headlength=6), horizontalalignment='left',verticalalignment='top' ) verticalalignment：垂直对齐方式 ，参数：[ ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ ] horizontalalignment：水平对齐方式 ，参数：[ ‘center’ | ‘right’ | ‘left’ ] #Add a second axes ax2 = ax1.twinx() ax2.plot( y2, color=r_hex, linewidth=2, linestyle='-',label='VIX' ) ax2.legend( loc='upper right', frameon=True ); 从第 26 行开始，用 for 循环读取 crisis_data 里面每个日期 date 和事件 label。 第 28 和 29 行是获取每一个 date 在整个日期数组中的索引 xi，以及对应的 spx 值 yi。 第 30 行用 scatter() 函数画出一个圆点，标注事件在 spx 折现上的位置。 第 31 和 34 行是重头戏，在 annotate() 函数里设置了事件，箭头坐标(距离圆点中心位置)，事件打印的坐标，箭头性质，以及对齐属性。 事件的确标注在图上了，但是效果像一坨~。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:10","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.11 设置透明度 为了把 VIX 折线弄得透明些，只用设置 ax2.plot() 里的 alpha 参数为 0.3，具体设什么值看你想要多透明，alpha 在 0 和 1 之间，0 是完全透明，1 是完全不透明。 fig = plt.figure( figsize=(16,6), dpi=100) crisis_data = [(datetime(2007, 10, 11), 'Peak of bull market'), (datetime(2008, 3, 12), 'Bear Stearns Fails'), (datetime(2008, 9, 15), 'Lehman Bankruptcy'), (datetime(2009, 1, 20), 'RBS Sell-off'), (datetime(2009, 4, 2), 'G20 Summit')] ax1 = fig.add_subplot(1,1,1) x = spx.index y1 = spx.values y2 = vix.values ax1.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) ax1.set_xlim(-1, len(x)+1) ax1.set_ylim( np.vstack([y1,y2]).min()*0.8, np.vstack([y1,y2]).max()*1.2 ) x_tick = range(0,len(x),40) x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] ax1.set_xticks( x_tick ) ax1.set_xticklabels( x_label, rotation=90 ) ax1.legend( loc='upper left', frameon=True ) for date, label in crisis_data: date = date.strftime('%Y-%m-%d') xi = x.get_loc(date) yi = spx.asof(date) ax1.scatter( xi, yi, 80, color=r_hex ) ax1.annotate( label, xy=(xi, yi + 60), xytext=(xi, yi+300), arrowprops=dict(facecolor='black',headwidth=4,width=1,headlength=6), horizontalalignment='left',verticalalignment='top' ) #Add a second axes ax2 = ax1.twinx() #设置透明度 ax2.plot( y2, color=r_hex, linewidth=2, linestyle='-', label='VIX', alpha=0.3 ) ax2.legend( loc='upper right', frameon=True ); 美如画！雷曼兄弟倒闭 (事件 3) 后 S\u0026P 暴跌最厉害，而同期的 VIX 也飙到天际。在 G20 峰会 (事件 5) 过后，大国领导者一起解决金融危机问题，从那个点开始，S\u0026P500 上涨 VIX 下跌。 经济总体平稳！风险总体可控！ ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:11","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"2.12 完善细节 既然老板关注这五个事件，而它们发生的日期可能没有落在横轴标签上，那老板不是在图上还是找不到他们发生的具体时间么？把它们加上去怎么样？ fig = plt.figure( figsize=(16,6), dpi=100) crisis_data = [(datetime(2007, 10, 11), 'Peak of bull market'), (datetime(2008, 3, 12), 'Bear Stearns Fails'), (datetime(2008, 9, 15), 'Lehman Bankruptcy'), (datetime(2009, 1, 20), 'RBS Sell-off'), (datetime(2009, 4, 2), 'G20 Summit')] ax1 = fig.add_subplot(1,1,1) x = spx.index y1 = spx.values y2 = vix.values ax1.plot( y1, color=dt_hex, linewidth=2, linestyle='-',label='S\u0026P500' ) ax1.set_xlim(-1, len(x)+1) ax1.set_ylim( np.vstack([y1,y2]).min()*0.8, np.vstack([y1,y2]).max()*1.2 ) ax1.legend( loc='upper left', frameon=True ) init_tick = list( range(0,len(x),40) ) impt_tick = [] impt_date = [] for date, label in crisis_data: date = date.strftime('%Y-%m-%d') impt_date.append(date) xi = x.get_loc(date) impt_tick.append(xi) yi = spx.asof(date) ax1.scatter( xi, yi, 80, color=r_hex ) ax1.annotate( label, xy=(xi, yi + 60), xytext=(xi, yi+300), arrowprops=dict(facecolor='black',headwidth=4,width=1,headlength=6), horizontalalignment='left',verticalalignment='top' ) x_tick = init_tick + impt_tick x_label = [x[i].strftime('%Y-%m-%d') for i in x_tick] ax1.set_xticks( x_tick ) ax1.set_xticklabels( x_label, rotation=90 ) for i, label in enumerate(ax1.get_xticklabels()): if i \u003e= len(init_tick): label.set_color(r_hex) label.set_fontweight('bold') else: label.set_fontsize(9) #Add a second axes ax2 = ax1.twinx() ax2.plot( y2, color=r_hex, linewidth=2, linestyle='-', label='VIX', alpha=0.3 ) ax2.legend( loc='upper right', frameon=True ); 新添加的代码在第 20-22 行和第 43-48 行。主要就是把日期分成两类： 常规日期标签 init_tick 五个事件日期标签 impt_tick ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:5:12","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3 画有效图 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3.1 概览 在做图表设计时候经常面临着怎么选用合适的图表，图表展示的关系分为四大类 (点击下图放大)： 分布 (distribution) 联系 (relationship) 比较 (comparison) 构成 (composition) 在选用图表前首先要想清楚：你要表达什么样的数据关系。上面的图表分类太过繁多，接下来我们只讨论在量化金融中用的最多的几种类型，即 用直方图来展示股票价格和收益的分布 用散点图来展示两支股票之间的联系 用折线图来比较汇率在不同窗口的移动平均线 用饼状图来展示股票组合的构成成分 首先用 YahooFinancials API 来下载若干资产的一年历史数据 (安装该 API 用 pip install yahoofinancials)： 在 Anaconda 命令框(开始菜单的搜索框里搜ana,搜索到Anaconda Prompt并打开)里 pip install yahoofinancials 起始日：2018-04-29 终止日：2019-04-29 五只股票：英伟达、亚马逊、阿里巴巴、脸书、苹果 三个汇率：欧元美元、美元日元、美元人民币 下面代码就是从 API 获取数据，股票用的是股票代号 (stock code)，而货币用的该 API 要求的格式，比如「欧元美元」用 EURUSD=X，而不是市场常见的 EURUSD，而「美元日元」用 JPY=X 而不是 USDJPY。 from yahoofinancials import YahooFinancials start_date = '2018-04-29' end_date = '2019-04-29' stock_code = ['NVDA','AMZN','BABA','FB','AAPL' ] currency_code = ['EURUSD=X', 'JPY=X', 'CNY=X'] stock =YahooFinancials( stock_code ) currency = YahooFinancials( currency_code ) stock_daily = stock.get_historical_price_data( start_date, end_date, 'daily' ) currency_daily = currency.get_historical_price_data( start_date, end_date, 'daily' ) 该 API 返回结果 stock_daily 和 currency_daily 是「字典」格式，样子非常丑陋，感受一下。 stock_daily \r展开查看\r\r{'AAPL': {'currency': 'USD',\r'eventsData': {'dividends': {'2018-05-11': {'amount': 0.73,\r'date': 1526045400,\r'formatted_date': '2018-05-11'},\r'2018-08-10': {'amount': 0.73,\r'date': 1533907800,\r'formatted_date': '2018-08-10'},\r'2018-11-08': {'amount': 0.73,\r'date': 1541687400,\r'formatted_date': '2018-11-08'},\r'2019-02-08': {'amount': 0.73,\r'date': 1549636200,\r'formatted_date': '2019-02-08'}}},\r'firstTradeDate': {'date': 345479400, 'formatted_date': '1980-12-12'},\r'instrumentType': 'EQUITY',\r'prices': [{'adjclose': 160.24440002441406,\r'close': 165.25999450683594,\r'date': 1525095000,\r'formatted_date': '2018-04-30',\r'high': 167.25999450683594,\r'low': 161.83999633789062,\r'open': 162.1300048828125,\r'volume': 42427400},\r{'adjclose': 163.96783447265625,\r'close': 169.10000610351562,\r'date': 1525181400,\r'formatted_date': '2018-05-01',\r'high': 169.1999969482422,\r'low': 165.27000427246094,\r'open': 166.41000366210938,\r'volume': 53569400},\r{'adjclose': 171.21115112304688,\r'close': 176.57000732421875,\r'date': 1525267800,\r'formatted_date': '2018-05-02',\r'high': 177.75,\r'low': 173.8000030517578,\r'open': 175.22999572753906,\r'volume': 66539400},\r{'adjclose': 171.52142333984375,\r'close': 176.88999938964844,\r'date': 1525354200,\r'formatted_date': '2018-05-03',\r'high': 177.5,\r'low': 174.44000244140625,\r'open': 175.8800048828125,\r'volume': 34068200},\r{'adjclose': 178.2508087158203,\r'close': 183.8300018310547,\r'date': 1525440600,\r'formatted_date': '2018-05-04',\r'high': 184.25,\r'low': 178.1699981689453,\r'open': 178.25,\r'volume': 56201300},\r{'adjclose': 179.54043579101562,\r'close': 185.16000366210938,\r'date': 1525699800,\r'formatted_date': '2018-05-07',\r'high': 187.6699981689453,\r'low': 184.75,\r'open': 185.17999267578125,\r'volume': 42451400},\r{'adjclose': 180.40342712402344,\r'close': 186.0500030517578,\r'date': 1525786200,\r'formatted_date': '2018-05-08',\r'high': 186.22000122070312,\r'low': 183.6699981689453,\r'open': 184.99000549316406,\r'volume': 28402800},\r{'adjclose': 181.67367553710938,\r'close': 187.36000061035156,\r'date': 1525872600,\r'formatted_date': '2018-05-09',\r'high': 187.39999389648438,\r'low': 185.22000122070312,\r'open': 186.5500030517578,\r'volume': 23211200},\r{'adjclose': 184.27232360839844,\r'close': 190.0399932861328,\r'date': 1525959000,\r'formatted_date': '2018-05-10',\r'high': 190.3699951171875,\r'low': 187.64999389648438,\r'open': 187.74000549316406,\r'volume': 27989300},\r{'adjclose': 183.5714874267578,\r'close': 188.58999633789062,\r'date': 1526045400,\r'formatted_date': '2018-05-11',\r'high': 190.05999755859375,\r'low': 187.4499969482422,\r'open': 189.49000549316406,\r'volume': 26212200},\r{'adjclose': 183.14320373535156,\r'close': 188.14999389648438,\r'date': 1526304600,\r'formatted_date': '2018-05-14',\r'high': 189.52999877929688,\r'low': 187.86000061035156,\r'open': 189.00999450683594,\r'volume': 20778800},\r{'adjclose': 181.47872924804688,\r'close': 1","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:1","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3.2 直方图 直方图 (histogram chart)，又称质量分布图，是一种统计报告图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据类型，纵轴表示分布情况。在 Matplotlib 里的语法是 plt.hist() ax.hist() 我们先看看英伟达 (NVDA) 的价格分布。 p_NVDA = NVDA['close'] fig = plt.figure( figsize=(8,4) ) plt.hist( p_NVDA, bins=30, color=dt_hex ) plt.xlabel('Nvidia Price') plt.ylabel('Number of Days Observed') plt.title('Frequency Distribution of Nvidia Prices, Apr-2018 to Apr-2019') plt.show() 在本例中函数 hist() 里的参数有 p_NVDA：Series，也可以是 list 或者 ndarray bins：分成多少堆 colors：用之前定义的深青色 从上图可看出，NVDA 的价格分布在有 220 划分的两个范围 (regime)。在 2018 年 11 月 16 日 (星期五)，英伟达第三季度的报表低于预期，那么股价暴跌 19%，在之后的星期一，又跌 12%，两个交易日股价一下子从原来的 220 左右跌到 150。 在研究股票价格序列中，由于收益率有些好的统计性质，我们对其更感兴趣，接下来再看看英伟达 (NVDA) 的对数收益 (log-return) 的分布。 date = p_NVDA.index price = p_NVDA.values r_NVDA = pd.Series( np.log(price[1:]/price[:-1]),index=date[1:] ) fig = plt.figure( figsize=(8,4) ) plt.hist( r_NVDA, bins=30, color=dt_hex ) plt.xlabel('Nvidia Daily Log-Return') plt.ylabel('Number of Days Observed') plt.title('Frequency Distribution of Nvidia Daily Log-Return, Apr-2018 to Apr-2019') plt.show() 首先对数收益的计算公式为 r(t) = ln(P(t)/P(t-1) 得到 r_NVDA。计算一天的收益率需要两天的价格，因此用 p_NVDA 计算 r_NVDA 时，会丢失最新一天的数据，因此我们用 date[1:] 作为 r_NVDA 的行标签 (index)。 不考虑在 -0.20 和 -0.15 那两个极端值，对数收益率的分布像一个正态分布 (人人都喜欢正态分布)。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:2","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3.3 散点图 散点图 (scatter chart) 用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种联系的分布模式。在 Matplotlib 里的语法是 plt.scatter() ax.scatter() 我们看看中美两大电商亚马逊 (AMZN) 和阿里巴巴 (BABA) 之间的价格和对数收益率的联系。 首先计算价格和对数收益率。 AMZN = data_converter( stock_daily, 'AMZN', ' EQ' ) BABA = data_converter( stock_daily, 'BABA', ' EQ' ) p_AMZN = AMZN['close'] p_BABA = BABA['close'] date = p_AMZN.index price = p_AMZN.values r_AMZN = pd.Series( np.log(price[1:]/price[:-1]),index=date[1:] ) date = p_BABA.index price = p_BABA.values r_BABA = pd.Series( np.log(price[1:]/price[:-1]),index=date[1:] ) 用两个子图分别展示「价格」和「收益率」的散点图。 fig, axes = plt.subplots( nrows=1, ncols=2, figsize=(14,6) ) axes[0].scatter( p_AMZN, p_BABA, color=dt_hex ) axes[0].set_xlabel('Amazon Price') axes[0].set_ylabel('Alibaba Price') axes[0].set_title('Daily Price from Apr-2018 to Apr-2019') axes[1].scatter( r_AMZN, r_BABA, color=r_hex ) axes[1].set_xlabel('Amazon Log-Return') axes[1].set_ylabel('Alibaba Log-Return') axes[1].set_title('Daily Returns from Apr-2018 to Apr-2019') plt.show() 在本例中函数 scatter() 里的参数有 p_AMZN (r_AMZN)：Series，也可以是 list 或者 ndarray p_BABA (r_BABA)：Series，也可以是 list 或者 ndarray colors：用之前定义的深青色和红色 从右图来看，亚马逊和阿里巴巴在这段时期的表现正相关，如果做线性回归是一条斜率为正的线。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:3","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3.4 折线图 折线图 (line chart) 显示随时间而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。在 Matplotlib 里的语法是 plt.plot() ax.plot() 我们来看看如何画 EURUSD 的 20 天和 60 天移动平均 (moving average, MA) 线。 首先获取 EURUSD 的收盘价。 curr = 'EURUSD' EURUSD = data_converter( currency_daily, curr, 'FX' ) rate = EURUSD['close'] 用 Pandas 里面的 rolling() 函数来计算 MA，在画出收盘价，MA20 和 MA60 三条折线。 fig = plt.figure( figsize=(16,6) ) ax = fig.add_subplot(1,1,1) ax.set_title( curr + ' - Moving Average') ax.set_xticks( range(0,len(rate.index),10) ) ax.set_xticklabels( [rate.index[i] for i in ax.get_xticks()], rotation=90 ); ax.plot( rate, color=dt_hex, linewidth=2,label='Close' ) MA_20 = rate.rolling(20).mean() MA_60 = rate.rolling(60).mean() ax.plot(MA_20, color=r_hex, linewidth=2, label='MA20') ax.plot(MA_60, color=g_hex, linewidth=2, label='MA60') ax.legend(loc=0); 在本例中函数 plot() 里的参数有 rate, MA_20, MA_60：Series，也可以是 list 或者 ndarray colors：用之前定义的深青色，红色，绿色 linewidth：像素 2 label：用于显示图例 上面代码最关键的就是第 10 和 11 行，用 rolling(n) 函数对 rate 求 n 天移动均值。从图中注意到绿色的 MA60最短，红色的 MA20 其次。原因很简单，假如一年有 252 个交易日，那么第 1 个 MA60 值需要第 1 到 60 个汇率，第 2 个 MA60 值需要第 2 到 61 个汇率，第 193 个 MA60 值需要第 193 到 252 个汇率。最终只有 193 个 MA60。同理可得到只有 223 个 MA20。 双均线策略如下：MA60 和 MA20 必有交点，若 20 天平均线「上穿越」60 天均线，则为买入点；反之为卖出点。该策略基于不同天数均线的交叉点抓住股票的强势和弱势时刻进行交易。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:4","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3.5 饼状图 饼状图 (pie chart) 是一个划分为几个扇形的圆形统计图表，用于描述量、频率或百分比之间的相对关系。 在饼状图中，每个扇区面积大小为其所表示的数量的比例。在 Matplotlib 里的语法是 plt.pie() ax.pie() 我们来看看如何画出一个股票投资组合在 2019 年 4 月 26 日的饼状图，假设组合里面有 100 股英伟达，20 股亚马逊，50 股阿里巴巴，30 股脸书和 40 股苹果 (一个科技股爱好者的组合 )。 首先计算组合里五支股票在 2019 年 4 月 26 日的市值 (market value, MV)。 stock_list = ['NVDA','AMZN','BABA','FB','AAPL' ] date = '2019-04-26' MV = [ data_converter(stock_daily, code, ' EQ')['close'][date] for code in stock_list ] MV = np.array(MV) * np.array([100,20,50,30,40]) 第 4 行用了列表解析式来获取 stock_list 每支股票的价格，第 5 行将价格乘上数量得到市值。 设定好五种颜色和百分数格式 %.0f%% (小数点后面保留 0 位)，画出饼状图。 fig = plt.figure( figsize=(7,7) ) ax = fig.add_subplot(1,1,1) ax.pie( MV, labels=stock_list, colors=[dt_hex,r_hex,g_hex,tn_hex,g25_hex], autopct='%.0f%%' ) plt.show() 在本例中函数 pie() 里的参数有 MV：股票组合市值，ndarray labels：标识，list colors：用之前定义的一组颜色，list autopct：显示百分数的格式，str 虽然画出了饼状图，但看起来有些别扭，且听下节分解如何改进。 ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:5","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"3.6 同理心 为用户习惯考虑 把饼当成钟，大多数人习惯顺时针的看里面的内容，因此把面积最大的那块的一条边 (见下图) 放在 12 点的位置最能突显其重要性，之后按面积从大到小顺时针排列。 在画饼状图前，我们需要额外做两件事： 按升序排列 5 只股票的市值 设定 pie() 的相关参数达到上述「最大块放 12 点位置」的效果 首先按市值大小按升序排序。 idx = MV.argsort()[::-1] MV = MV[idx] stock_list = [ stock_list[i] for i in idx ] print( MV ) print( stock_list ) [39012.60009766 17808.99963379 9354.49981689 8172.00012207\r5744.70016479]\r['AMZN', 'NVDA', 'BABA', 'AAPL', 'FB']\r 设定参数 startangle = 90 是说第一片扇形 (AMZN 深青色那块) 的左边在 90 度位置 counterclock = False 是说顺时针拜访每块扇形 fig = plt.figure( figsize=(7,7) ) ax = fig.add_subplot(1,1,1) ax.pie( MV, labels=stock_list, colors=[dt_hex,r_hex,g_hex,tn_hex,g25_hex], \\ autopct='%.0f%%',startangle=90, counterclock=False ) plt.show() 和上节最后的图相比，现在这饼状图看上去是不是顺眼多了。你承不承认你第一眼就注意到 12 点那个位置的扇形？ 为图表信息考虑 当饼状图里面扇形多过 5 个时，面积相近的扇形大小并不容易一眼辨别出来，不信看上图的 BABA 和 APPL，没看到数字很难看出那个面积大。但绝大多数人是感官动物，图形和数字肯定先选择看图形，这个时候用柱状图 (bar chart) 来代替饼状图，每个市值成分大小一目了然 (好图就是能让用户能最快的抓住核心信息)。 用 ax.bar() 函数来画柱状图，为了和饼状图的信息一致，几个关键操作为 第 4 行计算出市值的百分数 pct_MV 第 8, 9 行设置横轴刻度 (0,1,2,3,4) 和标签 (stock_list) 第 12, 13 行在特定位置上 (x+0.04, y+0.05/100) 将 pct_MV 以 {0:.0%} 的格式 (不保留小数点) 写出来，这些位置试几次看图的效果就可以确定下来。 fig = plt.figure( figsize=(8,6) ) ax = fig.add_subplot(1,1,1) pct_MV = MV / np.sum(MV) index = np.arange(len(pct_MV)) ax.bar( index, pct_MV, facecolor=r_hex, edgecolor=dt_hex) ax.set_xticks( index ) ax.set_xticklabels( stock_list ) ax.set_ylim( 0, np.max(pct_MV)*1.1 ) for x,y in zip(index,pct_MV): ax.text(x+0.04,y+0.05/100,'{0:.0%}'.format(y), ha='center', va='bottom' ) plt.show() 在本例中函数 bar() 里的参数有 index：横轴刻度，ndarray pct_MV：股票组合市值比例，ndarray facecolor：柱状颜色，红色 edgecolor：柱边颜色，深青色 如果柱状很多时，或者标签名字很长时，用横向柱状图 (horizontal bar chart)，函数为 ax.barh()。代码和上面非常类似，就是把横轴和纵轴的调换了一下。 fig = plt.figure( figsize=(8,4) ) ax = fig.add_subplot(1,1,1) pct_MV = MV[::-1] / np.sum(MV) index = np.arange(len(pct_MV)) ax.barh( index, pct_MV, facecolor=r_hex, edgecolor=dt_hex ) ax.set_yticks( index ) ax.set_yticklabels( stock_list[::-1] ) ax.set_xlim( 0, np.max(pct_MV)*1.1 ) for x,y in zip(pct_MV,index): ax.text(x+0.04,y,'{0:.0%}'.format(x), ha='right', va='center' ) plt.show() 为色盲用户考虑 世界上有 1/12 的男人和 1/200 的女人都有不同程度的色盲症状。因此当你将结果展示给重要客户时，最好考虑到这一点，我相信对方会非常欣赏你这种「同理心」。 幸运的是，Matplotlib 里面有专门为色盲考虑的色彩风格，首先用下列语句看查看所有的色彩风格。 print(plt.style.available) ['bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn', 'Solarize_Light2', '_classic_test']\r 不难发现 seaborn-colorblind就是我们所需要的。下面我们看看不同色彩风格下的「饼状图」和「柱状图」。 首先看从 R 中借用过来的大名鼎鼎的 ggplot 的效果。 plt.style.use('ggplot') fig, axes = plt.subplots( nrows=1, ncols=2, figsize=(14,7) ) axes[0].pie( MV, labels=stock_list,autopct='%.0f%%', \\ startangle=90, counterclock=False ) pct_MV = MV[::-1] / np.sum(MV) index = np.arange(len(pct_MV)) axes[1].barh( index, pct_MV ) axes[1].set_yticks( index ) axes[1].set_yticklabels( stock_list[::-1] ) axes[1].set_xlim( 0, np.max(pct_MV)*1.1 ) for x,y in zip(pct_MV,index): axes[1].text(x+0.04,y,'{0:.0%}'.format(x), ha='right', va='center' ) plt.tight_layout() plt.show() 再看 seaborn-colorblind 的效果(先执行下面代码，再重新执行上面代码)。 plt.style.use('seaborn-colorblind') ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:6:6","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"4 总结 本贴的思路非常清晰： 第一部分了解 Matplotlib 的绘图逻辑，以及里面包含的画图元素以及它们之间的层级。 第二部分深度学 Matplotlib，只研究折线图，通过研究它的属性，一步步改进图的尺寸、像素、线条颜色宽度风格、坐标轴边界、刻度标签、图例、多图、多坐标系、标注、透明度等等，画出了一幅美图。 第三部分广度学 Matplotlib，通过数据的分布、联系、比较和构成研究了直方图、散点图、折线图和饼状图，最后还为用户着想 (习惯、色盲等等) 画出更能有效表达信息的图。 基本绘图流程 我们现在处于一个大数据的时代，制图能力现在和写作能力一样重要。任何人现在都可以用各种制图工具或者编程语言来画图，但是很少人懂得画出好图。 好图不是指的绚烂的颜色 (fancy colors) 和复杂的层级 (complex layers)，当一张图里的信息能够以最清晰和有效的方式传递给使用者，那么这张图就是好图。 Stay Tuned! ","date":"2020-06-22","objectID":"/2020-06-22-matplotlib/:7:0","tags":["python","数学建模"],"title":"Matplotlib","uri":"/2020-06-22-matplotlib/"},{"categories":["python","数学建模"],"content":"前言 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:1:0","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"本篇鸣谢 马川-燕大 的增删整理， 王圣元 ——原创文章，与原文不同之处包含我的学习记录。 匹配Jupyter Notebook的ipynb文档链接下载地址在资源页面里 接着上篇继续后面三个章节 提纲 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:2:0","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4 数据表的合并和连接 数据表可以按「键」合并，用 merge 函数；可以按「轴」来连接，用 concat 函数。 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:3:0","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4.1 合并 合并用 merge 函数，语法如下： pd.merge( df1, df2, how=s, on=c ) c 是 df1 和 df2 共有的一栏，合并方式 (how=s) 有四种： 左连接 (left join)：合并之后显示 df1 的所有行 右连接 (right join)：合并之后显示 df2 的所有行 外连接 (outer join)：合并所有行 内连接 (inner join)：合并df1 和 df2 共有的所有行 (默认情况) 首先创建两个 DataFrame： df_price：4 天的价格 (2019-01-01 到 2019-01-04) df_volume：5 天的交易量 (2019-01-02 到 2019-01-06) import pandas as pd df_price = pd.DataFrame( {'Date': pd.date_range('2019-1-1', periods=4), 'Adj Close': [24.42, 25.00, 25.25, 25.64]}) df_price .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Adj Close 0 2019-01-01 24.42 1 2019-01-02 25.00 2 2019-01-03 25.25 3 2019-01-04 25.64 df_volume = pd.DataFrame( {'Date': pd.date_range('2019-1-2', periods=5), 'Volume' : [56081400, 99455500, 83028700, 100234000, 73829000]}) df_volume .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Volume 0 2019-01-02 56081400 1 2019-01-03 99455500 2 2019-01-04 83028700 3 2019-01-05 100234000 4 2019-01-06 73829000 接下来用 df_price 和 df_volume 展示四种合并。 left join pd.merge( df_price, df_volume, how='left' ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Adj Close Volume 0 2019-01-01 24.42 NaN 1 2019-01-02 25.00 56081400.0 2 2019-01-03 25.25 99455500.0 3 2019-01-04 25.64 83028700.0 按 df_price 里 Date 栏里的值来合并数据 df_volume 里 Date 栏里没有 2019-01-01，因此 Volume 为 NaN df_volume 里 Date 栏里的 2019-01-05 和 2019-01-06 不在 df_price 里 Date 栏，因此丢弃 right join pd.merge( df_price, df_volume, how='right' ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Adj Close Volume 0 2019-01-02 25.00 56081400 1 2019-01-03 25.25 99455500 2 2019-01-04 25.64 83028700 3 2019-01-05 NaN 100234000 4 2019-01-06 NaN 73829000 按 df_volume 里 Date 栏里的值来合并数据 df_price 里 Date 栏里没有 2019-01-05 和 2019-01-06，因此 Adj Close 为 NaN df_price 里 Date 栏里的 2019-01-01 不在 df_volume 里 Date 栏，因此丢弃 outer join pd.merge( df_price, df_volume, how='outer' ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Adj Close Volume 0 2019-01-01 24.42 NaN 1 2019-01-02 25.00 56081400.0 2 2019-01-03 25.25 99455500.0 3 2019-01-04 25.64 83028700.0 4 2019-01-05 NaN 100234000.0 5 2019-01-06 NaN 73829000.0 按 df_price 和 df_volume 里 Date 栏里的所有值来合并数据 df_price 里 Date 栏里没有 2019-01-05 和 2019-01-06，因此 Adj Close 为 NaN df_volume 里 Date 栏里没有 2019-01-01，因此 Volume 为 NaN inner join pd.merge( df_price, df_volume, how='inner' ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Adj Close Volume 0 2019-01-02 25.00 56081400 1 2019-01-03 25.25 99455500 2 2019-01-04 25.64 83028700 按 df_price 和 df_volume 里 Date 栏里的共有值来合并数据 df_price 里 Date 栏里的 2019-01-01 不在 df_volume 里 Date 栏，因此丢弃 df_volume 里 Date 栏里的 2019-01-05 和 2019-01-06 不在 df_price 里 Date 栏，因此丢弃 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:3:1","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4.2 连接 Numpy 数组可相互连接，用 np.concat；同理，Series 和 DataFrame 也可相互连接，用 pd.concat。 连接 Series 在 concat 函数也可设定参数 axis， axis = 0 (默认)，沿着轴 0 (行) 连接，得到一个更长的 Series axis = 1，沿着轴 1 (列) 连接，得到一个 DataFrame 被连接的 Series 它们的 index 可以重复 (overlapping)，也可以不同。 non-overlapping index 先定义三个 Series，它们的 index 各不同。 s1 = pd.Series([0, 1], index=['a', 'b']) s2 = pd.Series([2, 3, 4], index=['c', 'd', 'e']) s3 = pd.Series([5, 6], index=['f', 'g']) print(s1) print(s2) print(s3) a 0 b 1 dtype: int64 c 2 d 3 e 4 dtype: int64 f 5 g 6 dtype: int64 沿着「轴 0」连接得到一个更长的 Series。 pd.concat([s1, s2, s3]) a 0 b 1 c 2 d 3 e 4 f 5 g 6 dtype: int64 沿着「轴 1」连接得到一个 DataFrame。 pd.concat([s1, s2, s3], axis=1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 a 0.0 NaN NaN b 1.0 NaN NaN c NaN 2.0 NaN d NaN 3.0 NaN e NaN 4.0 NaN f NaN NaN 5.0 g NaN NaN 6.0 overlapping index 将 s1 和 s3 沿「轴 0」连接来创建 s4，这样 s4 和 s1 的 index 是有重复的。 s4 = pd.concat([s1, s3]) print(s1) print(s4) a 0 b 1 dtype: int64 a 0 b 1 f 5 g 6 dtype: int64 将 s1 和 s4 沿「轴 1」内连接 (即只连接它们共有 index 对应的值) pd.concat([s1, s4], axis = 1, join='inner') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 a 0 0 b 1 1 hierarchical index 最后还可以将 n 个 Series 沿「轴 0」连接起来，再赋予 3 个 keys 创建多层 Series。 pd.concat( [s1, s1, s3], keys=['one','two','three']) one a 0 b 1 two a 0 b 1 three f 5 g 6 dtype: int64 连接 DataFrame 连接 DataFrame 的逻辑和连接 Series 的一模一样。 沿着行连接 (axis = 0) 先创建两个 DataFrame，df1 和 df2。 import numpy as np df1 = pd.DataFrame( np.arange(12).reshape(3,4), columns=['a','b','c','d']) df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d 0 0 1 2 3 1 4 5 6 7 2 8 9 10 11 df2 = pd.DataFrame( np.arange(6).reshape(2,3), columns=['b','d','a']) df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } b d a 0 0 1 2 1 3 4 5 沿着行连接分两步 先把 df1 和 df2 列标签补齐 再把 df1 和 df2 纵向连起来 pd.concat( [df1, df2] ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d 0 0 1 2.0 3 1 4 5 6.0 7 2 8 9 10.0 11 0 2 0 NaN 1 1 5 3 NaN 4 得到的 DataFrame 的 index = [0,1,2,0,1]，有重复值。如果 index 不包含重要信息 (如上例)，可以将 ignore_index 设置为 True，这样就得到默认的 index 值了。 pd.concat( [df1, df2], ignore_index=True ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d 0 0 1 2.0 3 1 4 5 6.0 7 2 8 9 10.0 11 3 2 0 NaN 1 4 5 3 NaN 4 沿着列连接 (axis = 1) 先创建两个 DataFrame，df1 和 df2。 df1 = pd.DataFrame( np.arange(6).reshape(3,2), index=['a','b','c'], columns=['one','two'] ) df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } one two a 0 1 b 2 3 c 4 5 df2 = pd.DataFrame( 5 + np.arange(4).reshape(2,2), index=['a','c'], columns=['three','four']) df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } three four a 5 6 c 7 8 沿着列连接分两步 先把 df1 和 df2 行标签补齐 再把 df1 和 df2 横向连起来 pd.concat( [df1, df2], axis=1 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } one two three four a 0 1 5.0 6.0 b 2 3 NaN NaN c 4 5 7.0 8.0 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:3:2","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"5 数据表的重塑和透视 有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。 重塑 (reshape) 和透视 (pivot) 两个操作只改变数据表的布局 (layout)： 重塑用 stack 和 unstack 函数 (互为逆转操作) 透视用 pivot 和 melt 函数 (互为逆转操作) ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:4:0","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"5.1 重塑 重塑就是通过改变数据表里面的「行索引」和「列索引」来改变展示形式，从本质上说，就是重塑层次化索引(多层索引)。 行列旋转 列索引 → 行索引，用 stack 函数 行索引 → 列索引，用 unstack 函数 单层 DataFrame 创建 DataFrame df (1 层行索引，1 层列索引) symbol = ['JD', 'AAPL'] data = {'行业': ['电商', '科技'], '价格': [25.95, 172.97], '交易量': [27113291, 18913154]} df = pd.DataFrame( data, index=symbol ) df.columns.name = '特征' df.index.name = '代号' df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 特征 行业 价格 交易量 代号 JD 电商 25.95 27113291 AAPL 科技 172.97 18913154 从上表中可知： 行索引 = [JD, AAPL]，名称是代号 列索引 = [行业, 价格, 交易量]，名称是特征 stack: 列索引 → 行索引 列索引 (特征) 变成了行索引，原来的 DataFrame df 变成了两层 Series (第一层索引是代号，第二层索引是特征)。 c2i_Series = df.stack() c2i_Series 代号 特征 JD 行业 电商 价格 25.95 交易量 27113291 AAPL 行业 科技 价格 172.97 交易量 18913154 dtype: object unstack: 行索引 → 列索引 行索引 (代号) 变成了列索引，原来的 DataFrame df 也变成了两层 Series (第一层索引是特征，第二层索引是代号)。 i2c_Series = df.unstack() i2c_Series 特征 代号 行业 JD 电商 AAPL 科技 价格 JD 25.95 AAPL 172.97 交易量 JD 27113291 AAPL 18913154 dtype: object 基于层和名称来 unstack 对于多层索引的 Series，unstack 哪一层有两种方法来确定： 基于层 (level-based) 基于名称 (name-based) 拿 c2i_Series 举例 (读者也可以尝试 i2c_Series)： 代号 特征 JD 交易量 27113291 价格 25.95 行业 电商 AAPL 交易量 18913154 价格 172.97 行业 科技 dtype: object 其索引列出如下： c2i_Series.index MultiIndex([( 'JD', '行业'), ( 'JD', '价格'), ( 'JD', '交易量'), ('AAPL', '行业'), ('AAPL', '价格'), ('AAPL', '交易量')], names=['代号', '特征']) 1.基于层来 unstack() 时，没有填层数，默认为最后一层。 c2i_Series.unstack() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 特征 行业 价格 交易量 代号 JD 电商 25.95 27113291 AAPL 科技 172.97 18913154 c2i_Series 的最后一层 (看上面它的 MultiIndex) 就是 [交易量, 价格,行业 ]，从行索引转成列索引得到上面的 DataFrame。 2.基于层来 unstack() 时，选择第一层 (参数放 0) c2i_Series.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 代号 JD AAPL 特征 行业 电商 科技 价格 25.95 172.97 交易量 27113291 18913154 c2i_Series 的第一层 (看上面它的 MultiIndex) 就是 [JD, AAPL]，从行索引转成列索引得到上面的 DataFrame。 3.基于名称来 unstack c2i_Series.unstack('代号') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 代号 JD AAPL 特征 行业 电商 科技 价格 25.95 172.97 交易量 27113291 18913154 c2i_Series 的代号层 (看上面它的 MultiIndex) 就是 [JD, AAPL]，从行索引转成列索引得到上面的 DataFrame。 多层 DataFrame 创建 DataFrame df (2 层行索引，1 层列索引) data = [ ['电商', 101550, 176.92], ['电商', 175336, 25.95], ['金融', 60348, 41.79], ['金融', 36600, 196.00] ] midx = pd.MultiIndex( levels=[['中国','美国'], ['BABA', 'JD', 'GS', 'MS']], codes=[[0,0,1,1],[0,1,2,3]], names = ['地区', '代号']) mcol = pd.Index(['行业','雇员','价格'], name='特征') df = pd.DataFrame( data, index=midx, columns=mcol ) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 特征 行业 雇员 价格 地区 代号 中国 BABA 电商 101550 176.92 JD 电商 175336 25.95 美国 GS 金融 60348 41.79 MS 金融 36600 196.00 从上表中可知： 行索引第一层： r1 = [中国, 美国]，名称是地区 行索引第二层： r2 = [BABA, JD, GS, MS]，名称是代号 列索引： c = [行业, 雇员, 价格]，名称是特征 查看 df 的 index 和 columns 的信息 df.index, df.columns (MultiIndex([('中国', 'BABA'), ('中国', 'JD'), ('美国', 'GS'), ('美国', 'MS')], names=['地区', '代号']), Index(['行业', '雇员', '价格'], dtype='object', name='特征')) 那么 df 的行索引 = [r1, r2] df 的列索引 = c 1.基于层来 unstack() 时，选择第一层 (参数放 0) df.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } 特征 行业 雇员 价格 地区 中国 美国 中国 美国 中国 美国 代号 BABA 电商 NaN 101550.0 NaN 176.92 NaN JD 电商 NaN 175336.0 NaN 25.95 NaN GS NaN 金融 NaN 60348.0 NaN 41.79 MS NaN 金融 NaN 36600.0 NaN 196.00 df 被 unstack(0) 之后变成 (行 → 列) 行索引 = r2 列索引 = [c, r1] 重塑后的 DataFrame 这时行索引只有一层 (代号)，而列索引有两层，第一层是特征，第二层是地区。 2.基于层来 unstack() 时，选择第二层 (参数放 1) df.unstack(1) .dataframe tbody tr th:","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:4:1","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"5.2 透视 多个时间序列数据(在多个时间点观察或测量到的数据)通常是以所谓的**“长格式”（long）或“堆叠格式”（stacked）**存储在数据库和CSV中的。 因此，经常有重复值出现在各列下，因而导致源表不能传递有价值的信息。这时可用「透视」方法调整源表的布局用作更清晰的展示。 在 Pandas 里透视的方法有两种： 用 pivot 函数将「长格式」旋转为「宽格式」， 用 melt 函数将「宽格式」旋转为「长格式」， 本节使用的数据描述如下： 5 只股票：AAPL, JD, BABA, FB, GS 4 个交易日：从 2019-02-21 到 2019-02-26 data = pd.read_csv('data/Stock.csv', parse_dates=[0], dayfirst=True) data .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Symbol Open High Low Close Adj Close Volume 0 2019-02-21 AAPL 171.800003 172.369995 170.300003 171.059998 171.059998 17249700 1 2019-02-21 JD 24.820000 24.879999 24.010000 24.270000 24.270000 13542600 2 2019-02-21 BABA 171.000000 171.779999 169.800003 171.660004 171.660004 8434800 3 2019-02-21 GS 198.970001 199.449997 195.050003 196.360001 196.360001 2785900 4 2019-02-21 FB 161.929993 162.240005 159.589996 160.039993 160.039993 15607800 5 2019-02-22 AAPL 171.580002 173.000000 171.380005 172.970001 172.970001 18913200 6 2019-02-22 JD 24.549999 25.959999 24.480000 25.950001 25.950001 27113300 7 2019-02-22 BABA 172.800003 177.020004 172.520004 176.919998 176.919998 16175600 8 2019-02-22 GS 196.600006 197.750000 195.199997 196.000000 196.000000 2626600 9 2019-02-22 FB 160.580002 162.410004 160.309998 161.889999 161.889999 15858500 10 2019-02-25 AAPL 174.160004 175.869995 173.949997 174.229996 174.229996 21873400 11 2019-02-25 JD 27.110001 27.379999 26.040001 26.190001 26.190001 29338500 12 2019-02-25 BABA 181.259995 183.720001 180.729996 183.250000 183.250000 22831800 13 2019-02-25 GS 198.000000 201.500000 197.710007 198.649994 198.649994 3032200 14 2019-02-25 FB 163.070007 166.070007 162.899994 164.619995 164.619995 18737100 15 2019-02-26 AAPL 173.710007 175.300003 173.169998 174.330002 174.330002 17006000 16 2019-02-26 JD 25.980000 26.820000 25.660000 26.590000 26.590000 20264100 17 2019-02-26 BABA 179.789993 184.350006 179.369995 183.539993 183.539993 13857900 18 2019-02-26 GS 198.470001 200.559998 196.550003 198.899994 198.899994 2498000 19 2019-02-26 FB 164.339996 166.240005 163.800003 164.130005 164.130005 13645200 从上表看出有 20 行 (5 × 4) 和 8 列，在 Date 和 Symbol 那两列下就有重复值，4 个日期和 5 个股票在 20 行中分别出现了 5 次和 4 次。 这就是多个时间序列（或者其它带有两个或多个键的可观察数据，这里，我们的键是Date和Symbol）的长格式。表中的每行代表一次观察。 关系型数据库（如MySQL）中的数据经常都是这样存储的，因为固定架构（即列名和数据类型）有一个好处：随着表中数据的添加，Symbol列中的值的种类能够增加。在前面的例子中，Date和Symbol通常就是主键（关系型数据库中的术语，是表中的一个或多个字段，它的值用于唯一地标识表中的某一条记录），不仅提供了关系完整性，而且提供了更为简单的查询支持。有的情况下，使用这样的数据会很麻烦，你可能会更喜欢不同的Symbol值分别形成一列，Date列中的时间戳则用作索引。DataFrame的pivot方法完全可以实现这个转换： 从长到宽 (pivot) 当我们做数据分析时，只关注不同股票在不同日期下的 Adj Close data.iloc[:,[0,1,6]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Symbol Adj Close 0 2019-02-21 AAPL 171.059998 1 2019-02-21 JD 24.270000 2 2019-02-21 BABA 171.660004 3 2019-02-21 GS 196.360001 4 2019-02-21 FB 160.039993 5 2019-02-22 AAPL 172.970001 6 2019-02-22 JD 25.950001 7 2019-02-22 BABA 176.919998 8 2019-02-22 GS 196.000000 9 2019-02-22 FB 161.889999 10 2019-02-25 AAPL 174.229996 11 2019-02-25 JD 26.190001 12 2019-02-25 BABA 183.250000 13 2019-02-25 GS 198.649994 14 2019-02-25 FB 164.619995 15 2019-02-26 AAPL 174.330002 16 2019-02-26 JD 26.590000 17 2019-02-26 BABA 183.539993 18 2019-02-26 GS 198.899994 19 2019-02-26 FB 164.130005 那么可用 pivot 函数将原始 data「透视」成一个新的 DataFrame，起名 close_price。在 pivot 函数中 将 index 设置成 ‘Date’ 将 columns 设置成 ‘Symbol’ 将 values 设置 ‘Adj Close’ close_price 实际上把 data[‘Date’] 和 data[‘Symbol’] 的唯一值当成支点(pivot 就是支点的意思) 创建一个 DataFrame，其中 行标签 = 2019-02-21, 2019-02-22, 2019-02-25, 2019-02-26 列标签 = AAPL, JD, BABA, FB, GS 在把 data[‘Adj Close’] 的值放在以如上的行标签和列标签创建的 close_price 来展示。 代码如下： close_price = data.pivot( index='Date', columns='Symbol', values='Adj Close' ) close_price .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: righ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:4:2","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"6 数据表的分组和聚合 DataFrame 中的数据可以根据某些规则分组，然后在每组的数据上计算出不同统计量。这种操作称之为 split-apply-combine（拆分－应用－合并）。 第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。 该 split-apply-combine 过程有两步(apply-combine合为一步完成)： Step1 ：数据分组(split) groupby 方法 Step2 ：数据聚合(apply-combine) 使用内置函数——sum / mean / max / min / count等 使用自定义函数—— agg ( aggregate ) 方法 自定义更丰富的分组运算—— apply 方法 agg 方法将一个函数使用在一个数列上，然后返回一个标量的值。也就是说agg每次传入的是一列数据，对其聚合后返回标量。 apply 是一个更一般化的方法，会将当前分组后的数据一起传入，返回多维数据。 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:5:0","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"6.1 数据准备 本节使用数据：泰坦尼克数据集 PassengerId =\u003e 乘客编号 Survived =\u003e 获救情况（1为获救，0为未获救） Pclass =\u003e 乘客等级(1/2/3等舱位) Name =\u003e 乘客姓名 Sex =\u003e 性别 Age =\u003e 年龄 SibSp =\u003e 堂兄弟/妹个数 Parch =\u003e 父母与小孩个数 Ticket =\u003e 船票信息 Fare =\u003e 票价 Cabin =\u003e 客舱 Embarked =\u003e 登船港口 titanic = pd.read_csv(r'data\\Titanic.csv') titanic.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 用前面所学透视一下数据： titanic.pivot_table(index='Sex',columns='Pclass',values='Survived') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Pclass 1 2 3 Sex female 0.968085 0.921053 0.500000 male 0.368852 0.157407 0.135447 titanic.pivot_table(index='Sex',columns='Pclass',values='Survived',aggfunc='sum') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Pclass 1 2 3 Sex female 91 70 72 male 45 17 47 titanic.pivot_table(index='Sex',columns='Pclass',aggfunc={'Survived':'sum','Age':'mean'}) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } Age Survived Pclass 1 2 3 1 2 3 Sex female 34.611765 28.722973 21.750000 91 70 72 male 41.281386 30.740707 26.507589 45 17 47 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:5:1","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"6.2 分组 (grouping) 用某一特定标签 (label) 将数据 (data) 分组的语法如下： data.groupBy( label ) 单标签分组 首先来按 Symbol 来分组： grouped = titanic.groupby('Sex') grouped \u003cpandas.core.groupby.generic.DataFrameGroupBy object at 0x00000278AE849CC0\u003e dir(grouped) ['Age', 'Cabin', 'Embarked', 'Fare', 'Name', 'Parch', 'PassengerId', 'Pclass', 'Sex', 'SibSp', 'Survived', 'Ticket', '__annotations__', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_accessors', '_add_numeric_operations', '_agg_examples_doc', '_agg_see_also_doc', '_aggregate', '_aggregate_frame', '_aggregate_item_by_item', '_aggregate_multiple_funcs', '_apply_filter', '_apply_to_column_groupbys', '_apply_whitelist', '_assure_grouper', '_bool_agg', '_builtin_table', '_choose_path', '_concat_objects', '_constructor', '_cumcount_array', '_cython_agg_blocks', '_cython_agg_general', '_cython_table', '_cython_transform', '_define_paths', '_deprecations', '_dir_additions', '_dir_deletions', '_fill', '_get_cython_func', '_get_cythonized_result', '_get_data_to_aggregate', '_get_index', '_get_indices', '_gotitem', '_group_selection', '_insert_inaxis_grouper_inplace', '_internal_names', '_internal_names_set', '_is_builtin_func', '_iterate_column_groupbys', '_iterate_slices', '_make_wrapper', '_obj_with_exclusions', '_python_agg_general', '_python_apply_general', '_reindex_output', '_reset_cache', '_reset_group_selection', '_selected_obj', '_selection', '_selection_list', '_selection_name', '_set_group_selection', '_set_result_index_ordered', '_transform_fast', '_transform_general', '_transform_item_by_item', '_transform_should_cast', '_try_aggregate_string_function', '_try_cast', '_wrap_agged_blocks', '_wrap_aggregated_output', '_wrap_applied_output', '_wrap_frame_output', '_wrap_transformed_output', 'agg', 'aggregate', 'all', 'any', 'apply', 'backfill', 'bfill', 'boxplot', 'corr', 'corrwith', 'count', 'cov', 'cumcount', 'cummax', 'cummin', 'cumprod', 'cumsum', 'describe', 'diff', 'dtypes', 'expanding', 'ffill', 'fillna', 'filter', 'first', 'get_group', 'groups', 'head', 'hist', 'idxmax', 'idxmin', 'indices', 'last', 'mad', 'max', 'mean', 'median', 'min', 'ndim', 'ngroup', 'ngroups', 'nth', 'nunique', 'ohlc', 'pad', 'pct_change', 'pipe', 'plot', 'prod', 'quantile', 'rank', 'resample', 'rolling', 'sem', 'shift', 'size', 'skew', 'std', 'sum', 'tail', 'take', 'transform', 'tshift', 'var'] 又要提起那句说了无数遍的话「万物皆对象」了。这个 grouped 也不例外，当你对如果使用某个对象感到迷茫时，用 dir() 来查看它的「属性」和「内置方法」。以下几个属性和方法是学生感兴趣的： ngroups: 组的个数 (int) size(): 每组元素的个数 (Series) groups: 每组元素在原 DataFrame 中的索引信息 (dict) get_groups(label): 标签 label 对应的数据 (DataFrame) 下面看看这些属性和方法的产出结果。 数据里性别为male和female，因此有2组。 列索引变行索引，同项合并得到新运算结果 grouped.ngroups 2 每组的信息条数 grouped.size() Sex female 314 male 577 dtype: int64 女士 (female) 的索引 1, 2, 3, 8, 9, …，男士( male) 的索引0, 4, 5, 6, 7,… grouped.groups {'female': Int64Index([ 1, 2, 3, 8, 9, 10, 11, 14, 15, 18, ... 866, 871, 874, 875, 879, 880, 882, 885, 887, 888], dtype='int64', length=314), 'male': Int64Index([ 0, 4, 5, 6, 7, 12, 13, 16, 17, 20, ... 873, 876, 877, 878, 881, 883, 884, 886, 889, 890], dtype='int64', length=577)} 查查 ‘male’ 组里的数据的前五行。 grouped.get_group('male').head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 5 6 0 3 Moran, Mr. James male NaN 0 0 330877 8.4583 NaN Q 6 7 0 1 McCarthy, Mr. Timothy J male 54.0 0 0 17463 51.8625 E46 S 7 8 0 3 Palsson, Master. Gosta ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:5:2","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"6.3 聚合 (aggregating) 6.3.1 使用内置函数——sum / mean / max / min / count等 grouped.mean() # grouped.sum() # grouped.max() # grouped.min() # grouped.count() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Age SibSp Parch Fare Sex female 431.028662 0.742038 2.159236 27.915709 0.694268 0.649682 44.479818 male 454.147314 0.188908 2.389948 30.726645 0.429809 0.235702 25.523893 6.3.2 使用自定义函数—— agg ( aggregate ) 方法 agg 方法将一个函数使用在一个数列上，然后返回一个标量的值。也就是说agg每次传入的是一列数据，对其聚合后返回标量。 # grouped['Survived'].agg(np.mean) grouped.agg(np.mean) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Age SibSp Parch Fare Sex female 431.028662 0.742038 2.159236 27.915709 0.694268 0.649682 44.479818 male 454.147314 0.188908 2.389948 30.726645 0.429809 0.235702 25.523893 titanic.groupby(['Sex','Pclass'])['Survived'].agg(['mean','sum']) # 或者这样写 # titanic.groupby(['Sex','Pclass'])['Survived'].agg([np.mean,np.sum]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean sum Sex Pclass female 1 0.968085 91 2 0.921053 70 3 0.500000 72 male 1 0.368852 45 2 0.157407 17 3 0.135447 47 将 np.mean 和 np.std 放进列表中，当成是高阶函数 agg() 的参数。上面代码按性别和乘客等级对获救情况求均值与和。 既然 agg() 是高阶函数，参数当然也可以是匿名函数 (lambda 函数)，下面先定义一个对 grouped2 里面每个标签下求最大值和最小值，再求差。注意 lambda 函数里面的 x 就是 grouped2。 grouped2.agg( lambda x: np.max(x)-np.min(x) ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Age SibSp Parch Fare Sex Pclass female 1 886 1 61.00 3 2 486.4000 2 871 1 55.00 3 3 54.5000 3 886 1 62.25 8 6 62.8000 male 1 883 1 79.08 3 4 512.3292 2 869 1 69.33 2 2 73.5000 3 890 1 73.58 8 5 69.5500 上面代码对每个分组在Age、Fare、Parch、PassengerId、SibSp和Survived上求「最大值」和「最小值」的差。真正有价值的信息在 Age、Parch 等栏，但是可以借此来验证agg使用自定义函数的用法。 6.3.3 自定义更丰富的分组运算—— apply 方法 apply 是一个更一般化的方法：将一个数据分拆-应用-汇总，会将当前分组后的数据一起传入，返回多维数据。 有时候返回的值不一定是一个标量的值，有可能是一个数组或是其他类型。此时，agg无法胜任，就需要使用apply了。 在看具体例子之前，先定一个 top 函数，返回 DataFrame 某一栏中 n 个最大值。 def top( df, n=5, column='Parch' ): return df.sort_values(by=column)[-n:] df.sort_values 根据column排序，上一代码中是升序 将 top 函数用到最原始的数据 (从 csv 中读取出来的) 上。 top( titanic ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 13 14 0 3 Andersson, Mr. Anders Johan male 39.0 1 5 347082 31.2750 NaN S 25 26 1 3 Asplund, Mrs. Carl Oscar (Selma Augusta Emilia... female 38.0 1 5 347077 31.3875 NaN S 885 886 0 3 Rice, Mrs. William (Margaret Norton) female 39.0 0 5 382652 29.1250 NaN Q 638 639 0 3 Panula, Mrs. Juha (Maria Emilia Ojala) female 41.0 0 5 3101295 39.6875 NaN S 678 679 0 3 Goodwin, Mrs. Frederick (Augusta Tyler) female 43.0 1 6 CA 2144 46.9000 NaN S 上面的top函数中，df 代表你传递给它的DataFrame数据，n代表取它的前n行，在这里，n的默认值是5，也就是说在调用这个函数的时候，如果没有给n赋值，n值等于5。column是排序列，函数会先按column升序排序，然后返回最大的n行。在这个时候，agg的方法就不管用的，要是强行使用，就会出错。 来，演示一遍错误！ titanic.groupby('Sex').agg(top) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) D:\\Anaconda\\envs\\python32\\lib\\site-packages\\pandas\\core\\groupby\\generic.py in aggregate(self, func, *args, **kwargs) 947 try: --\u003e 948 result = self._aggregate_multiple_funcs([func], _axis=self.axis) 949 except ValueError as err: D:\\Anaconda\\envs\\python32\\lib\\site-packages\\pandas\\core\\base.py in _aggregate_multiple_funcs(self, arg, _axis) 541 if not len(results): --\u003e 542 raise ValueError(\"no results\") 543 ValueError: no results During handling of the above exception, another exception occurred: ValueError Traceback (most rece","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:5:3","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"6.4 排序(Mc补充) 排序分为对索引排序 sort_index 和对 值排序 sort_values ascending：默认True升序排列；False降序排列 obj = pd.Series(range(4), index=['d','a','b','c']) print(obj) #索引排序 print('索引排序\\n',obj.sort_index()) #值排序 print('值排序\\n',obj.sort_values(ascending=False)) d 0 a 1 b 2 c 3 dtype: int64 索引排序 a 1 b 2 c 3 d 0 dtype: int64 值排序 c 3 b 2 a 1 d 0 dtype: int64 frame = pd.DataFrame(np.arange(8).reshape((2,4)),index=['three','one'], columns=['d','a','b','c']) print(frame) # 索引排序 print(frame.sort_index()) # frame.sort_index(axis=1) # 降序 # frame.sort_index(axis=1, ascending=False) # 值排序 # frame.sort_values(by='a',ascending=False) # frame.sort_values(by=['a','b'],ascending=False) # frame.sort_values(by='one',axis=1,ascending=False) d a b c three 0 1 2 3 one 4 5 6 7 d a b c one 4 5 6 7 three 0 1 2 3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } c b a d three 3 2 1 0 one 7 6 5 4 ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:5:4","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"7 总结 【合并数据表】用 merge 函数按数据表的共有列进行左/右/内/外合并。 【连接数据表】用 concat 函数对 Series 和 DataFrame 沿着不同轴连接。 【重塑数据表】用 stack 函数将「列索引」变成「行索引」，用 unstack 函数将「行索引」变成「列索引」。它们只是改变数据表的布局和展示方式而已。 【透视数据表】用 pivot 函数将「一张长表」变成「多张宽表」，用 melt 函数将「多张宽表」变成「一张长表」。它们只是改变数据表的布局和展示方式而已。 【分组数据表】用 groupBy 函数按不同「列索引」下的值分组。一个「列索引」或多个「列索引」就可以。 【聚合数据表】用 agg 函数对每个组做聚合而计算统计量。 【split-apply-combine】用 apply 函数做数据分析时美滋滋。 至此，可以说已经打好 Python Basics 的基础，能用 NumPy 做数组计算，能用 Pandas 做数据分析，现在已经搞很多事情了。现在我们唯一欠缺的是如何画图或可视化数据，下帖从最基础的可视化工具 Matplotlib 开始讲。Stay Tuned! ","date":"2020-06-22","objectID":"/2020-06-02-pandas%E4%B8%8B/:6:0","tags":["python","数学建模"],"title":"Pandas (下)","uri":"/2020-06-02-pandas%E4%B8%8B/"},{"categories":["C++","python"],"content":"尹成爬虫课件 蓝奏云链接 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:1","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"电脑抓包工具fiddler fiddler百度云盘链接 提取码：qk5c fiddler蓝奏云盘链接 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:2","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"爬虫headers伪装UserAgent集合 电脑端 pcUserAgent = { \"safari 5.1 – MAC\":\"User-Agent:Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50\", \"safari 5.1 – Windows\":\"User-Agent:Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50\", \"IE 9.0\":\"User-Agent:Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0);\", \"IE 8.0\":\"User-Agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)\", \"IE 7.0\":\"User-Agent:Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\", \"IE 6.0\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\", \"Firefox 4.0.1 – MAC\":\"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\", \"Firefox 4.0.1 – Windows\":\"User-Agent:Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\", \"Opera 11.11 – MAC\":\"User-Agent:Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11\", \"Opera 11.11 – Windows\":\"User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11\", \"Chrome 17.0 – MAC\":\"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Maxthon\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)\", \"Tencent TT\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)\", \"The World 2.x\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\", \"The World 3.x\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)\", \"sogou 1.x\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)\", \"360\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)\", \"Avant\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)\", \"Green Browser\":\"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\" } 移动手机端 mobileUserAgent = { \"iOS 4.33 – iPhone\":\"User-Agent:Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", \"iOS 4.33 – iPod Touch\":\"User-Agent:Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", \"iOS 4.33 – iPad\":\"User-Agent:Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", \"Android N1\":\"User-Agent: Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", \"Android QQ\":\"User-Agent: MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", \"Android Opera \":\"User-Agent: Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10\", \"Android Pad Moto Xoom\":\"User-Agent: Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13\", \"BlackBerry\":\"User-Agent: Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+\", \"WebOS HP Touchpad\":\"User-Agent: Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0\", \"Nokia N97\":\"User-Agent: Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124\", \"Windows Phone Mango\":\"User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)\", \"UC\":\"User-Agent: UCWEB7.0.2.37/28/999\", \"UC standard\":\"User-Agent: NOKIA5700","date":"2020-06-22","objectID":"/about/ziyuan/:0:3","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"Appium布置软件集合 链接: https://pan.baidu.com/s/126x-AgLKvM7qSJqdOzAAHA 提取码: h9b2 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:4","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"go-cqhttp 下载链接：点我 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:5","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"Numpy课件 源文档(上) 源文档(下) ","date":"2020-06-22","objectID":"/about/ziyuan/:0:6","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"Pandas课件 源文档及相关文件(上) 源文档及相关文件(下) ","date":"2020-06-22","objectID":"/about/ziyuan/:0:7","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"MySQL数据库下载链接(5.5版本) https://spiritlhl.lanzous.com/id5vt2f ","date":"2020-06-22","objectID":"/about/ziyuan/:0:8","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"MySQL图形界面客户端下载链接 https://spiritlhl.lanzous.com/id5vuji ","date":"2020-06-22","objectID":"/about/ziyuan/:0:9","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"Matplotlib课件 源文档及相关文件压缩包 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:10","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"1Stopt安装包 点击跳转下载解压即可使用，记得看说明先 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:11","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"代理加速网站 主站若下载慢请去镜像站 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:12","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"反代理加速访问Github 将下面链接替换官方链接https://github.com即可国内直连加速访问，仅供访问查看。 https://git.spiritlhl.workers.dev ","date":"2020-06-22","objectID":"/about/ziyuan/:0:13","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"大学项目文件仓库 仓库文件包含： 数值逼近课设文件 数据结构课设文件 常微分项目文件 常微分偏微分建模练习 长三角数学建模B题 小额贷款的划算问题 仓库地址： https://github.com/spiritLHL/college-item 备用仓库 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:14","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"新冠疫情数据分析文件 https://github.com/spiritLHL/Cov2019Analysis 备用仓库 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:15","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"常微分偏微分建模练习 python数据处理的所有文件 matlab建模的所有文件 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:16","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"长三角数学建模B题 个人自己写的代码文件包，很乱没整理，1Stopt安装包在上面 matlab建模的所有文件 ","date":"2020-06-22","objectID":"/about/ziyuan/:0:17","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["C++","python"],"content":"自建小站点 随手搭的小玩意，免费代挂某东JD活动，有需要请联系我 代挂JD日常任务站点 代挂JD互助任务站点 两个面板数据互不相通，有需要建议都扫。 随手搭的小玩意，如果有会员欢迎联系我捐赠进行高速解析：百度云盘直链解析站点。 解析下载需要IDM等软件搭配，建议去吾爱破解论坛下个破解版IDM搭配使用。 解析密码：spiritlhl 随手搭的小玩意，二叉树在线游戏站点。 欢迎请站长喝一杯 ","date":"2020-06-22","objectID":"/about/ziyuan/:1:0","tags":["windows"],"title":"博客相关资源","uri":"/about/ziyuan/"},{"categories":["数据库"],"content":"分组函数 功能：作统计使用，又称为聚合函数或统计函数或组函数 ","date":"2020-06-15","objectID":"/mysql04/:0:0","tags":["MySQL"],"title":"MySQL数据库04(常见函数)","uri":"/mysql04/"},{"categories":["数据库"],"content":"分类： sum 求和 avg 平均值 max 最大值 min 最小值 count 计算个数 ","date":"2020-06-15","objectID":"/mysql04/:1:0","tags":["MySQL"],"title":"MySQL数据库04(常见函数)","uri":"/mysql04/"},{"categories":["数据库"],"content":"特点： 1.sum，avg一般用于处理数值型，max，min，count可以处理任何类型 2.以上分组函数都忽略null值 3.可以和distinct搭配实现去重运算 4、count函数的单独介绍 一般使用count(*)用作统计行数 5、和分组函数一同查询的字段要求是group by后的字段 1.简单使用 select SUM(salary) from employees; select AVG(salary) from employees; select MIN(salary) from employees; select MAX(salary) from employees; select count(salary) from employees; (单行执行，一行一行的输出)\rselect SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,count(salary) 个数 from employees; (单行输出全部结果)\r 2.参数支持哪些类型 select SUM(last_name) ,AVG(last_name) from employees;\r(即便不报错，也不支持字符串类型) select SUM(hiredate) ,AVG(hiredate) from employees; (不支持日期类型) select MAX(hiredate) ,MIN(hiredate) from employees; (数值型可用，日期型可用) select MAX(last_name) ,MIN(last_name) from employees; (可排序的都可用) select count(任意类型) from employees; (计算非空值的个数)\r 3.和distinc搭配 select SUM(distinct salary) from employees; (去重后再求和)\rselect SUM(*) from employees; (数行数)\rselect SUM(1) from employees; (数开头为1的行)\r 效率： MYISAM存储引擎下，count(*)的效率最高 INNODB存储引擎下，COUNT (*)和COUNT (1)的效牢差不多，比COUNT(字段)要高一些 6.和分组函数一同查询的字段有限制 SELECT AVG (salary) , employee_id FRCM employees; (后面的那个employee_id无法查询但不报错) ","date":"2020-06-15","objectID":"/mysql04/:2:0","tags":["MySQL"],"title":"MySQL数据库04(常见函数)","uri":"/mysql04/"},{"categories":["python","数学建模"],"content":"前言 ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:1:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"本篇鸣谢 马川-燕大 的增删整理， 王圣元 ——原创文章，与原文不同之处包含我的学习记录。 匹配Jupyter Notebook的ipynb文档链接下载地址如下 源文档及相关文件 ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:2:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"0 引言 Pandas 是 Python 为解决数据分析而创建的，详情看官网 https://pandas.pydata.org/。 在使用 pandas 之前，需要引进它，语法如下： import pandas 这样就可以用 pandas 里面所有的内置方法 (build-in methods) 了，比如创建一维的 Series 和二维的 DataFrame。 pandas.Series() pandas.DataFrame() 但是每次写 pandas 字数有点多，通常给 pandas 起个别名 pd，用以下语法，这样所有出现 pandas 的地方都可以用 pd 替代。 import pandas as pd#本篇使用的是0.25.1版本的pandas Pandas 里面的数据结构是「多维数据表」，学习它可以类比这 NumPy 里的「多维数组」。1/2 维的「多维数据表」分别叫做 Series (系列)和 DataFrame (数据帧)，与1/2 维的「多维数组」的类比关系如下。 由于「系列」、「数据帧」这些直译过来的中文名词听起来有些奇怪，在本帖还是直接用 Series和 DataFrame。 对比 NumPy (np) 和 Pandas (pd) 每个维度下的数据结构，不难看出 pd 多维数据表 = np 多维数组 + 描述 其中 Series = 1darray + index DataFrame = 2darray + index + columns 每个维度上的「索引」使得「多维数据表」比「多维数组」涵盖更多的信息，如下图，左边的 2d array 仅仅储存了一组数值 (具体代表什么意思却不知道)，而右边的 DataFrame 一看就知道这是平安银行和茅台从 2018-1-3 到 2019-1-3 的价格。 和学习 numpy 一样，学习 pandas 还是遵循的 Python 里「万物皆对象」的原则，既然把数据表当对象，就得按着数据表的创建、数据表的存载、数据表的获取、数据表的合并和连接、数据表的重塑和透视、和数据表的分组和整合来盘一盘 Pandas。 提纲： 由于篇幅原因，Pandas 系列分两贴，上贴讲前三节的内容，下帖讲后三节的内容。 ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:3:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"1 数据表的创建 数据表有两大类型 Series: 一维数据，类似于 python 中的基本数据的 list 或 NumPy 中的 1D array。Pandas 里最基本的数据结构 DataFrame: 二维数据，类似于 R 中的 data.frame 或 Matlab 中的 Tables。DataFrame 是 Series 的容器 知识点 最常见的数据类型是二维的 DataFrame，其中 每行代表一个示例 (instance) 每列代表一个特征 (feature) DataFrame 可理解成是 Series 的容器，每一列都是一个 Series，或者 Series 是只有一列的 DataFrame。 接下来用代码来创建 pandas 数据表： 一维 Series 创建 Series 只需用下面一行代码 pd.Series( x, index=idx ) 其中 x 可以是 列表 (list) numpy 数组 (ndarray) 字典 (dict) 回顾Python编程基础中函数的定义，那么 x 是位置参数 index 是默认参数，默认值为 idx = range(0, len(x)) 用列表 s = pd.Series([27.2, 27.65, 27.70, 28]) s 0 27.20 1 27.65 2 27.70 3 28.00 dtype: float64 打印出来并不仅仅是列表里面的浮点数，每个浮点数前面还有一个索引，在本例中是 0, 1, 2, 3。 因此在创建 Series 时，如果不显性设定 index，那么 Python 给定一个默认从 0 到 N-1 的值，其中 N 是 x 的长度。 Series s 也是一个对象，用 dir(s) 可看出关于 Series 所有的属性和内置函数，其中最重要的是 用 s.values 打印 s 中的元素 用 s.index 打印 s 中的元素对应的索引 s.values array([27.2 , 27.65, 27.7 , 28. ]) s.index RangeIndex(start=0, stop=4, step=1) 不难发现，以上创建的 Series 和 numpy 数组比多了「索引」，但这种 0,1,2,3 的索引是在没有什么描述意义。实际上定义的 s 是海底捞在 2019 年 4 月 1 日到 2019 年 4 月 4 日的股价，那么用日期来当索引是不是更好些？ dates = pd.date_range('20190401',periods=4) s2 = pd.Series( [27.2, 27.65, 27.70, 28], index=dates ) s2 2019-04-01 27.20 2019-04-02 27.65 2019-04-03 27.70 2019-04-04 28.00 Freq: D, dtype: float64 pandas.date_range(start=None, end=None, periods=None, freq=‘D’, tz=None, normalize=False, name=None, closed=None, **kwargs) 该函数主要用于生成一个固定频率的时间索引，在调用构造方法时，必须指定start、end、periods中的两个参数值，否则报错。 主要参数说明： periods：固定时期，取值为整数或None freq：日期偏移量，取值为string或DateOffset，默认为’D' normalize：若参数为True表示将start、end参数值正则化到午夜时间戳 name：生成时间索引对象的名称，取值为string或None closed：可以理解成在closed=None情况下返回的结果中，若closed=‘left’表示在返回的结果基础上，再取左开右闭的结果，若closed=‘right’表示在返回的结果基础上，再取做闭右开的结果 显然，s2 比 s 包含的信息更多，这是 s2 的索引是一组日期对象，数据类型是 datetime64，频率是 D (天)。 s2.index DatetimeIndex(['2019-04-01', '2019-04-02', '2019-04-03', '2019-04-04'], dtype='datetime64[ns]', freq='D') 甚至还可以给 s2 命名，就叫海底捞股价如何？ s2.name = '海底捞股价' s2 2019-04-01 27.20 2019-04-02 27.65 2019-04-03 27.70 2019-04-04 28.00 Freq: D, Name: 海底捞股价, dtype: float64 用 numpy 数组 除了用列表，还可以用 numpy 数组来生成 Series。在下例中，加入缺失值 np.nan，并分析一下 Series 中另外 5 个属性或内置函数的用法： len: s 里的元素个数 shape: s 的形状 (用元组表示) count: s 里不含 nan 的元素个数 unique: 返回 s 里不重复的元素 value_counts: 统计 s 里非 nan 元素的出现次数 对照上面函数的用法，下面的输出一看就懂了吧。 空值的产生只有np.nan() 总结一下： np.nan不是一个“空”对象，用 i is None判断是False； 对某个值是否为空值进行判断，只能用np.isnan(i)函数，万万不可用 i == np.nan()来做，否则你会死的很惨的，因为空值并不能用判断相等的“==”正确识别（上例前两条）； np.nan非空对象，其类型为基本数据类型float（是不是很神奇，我也不知道为什么要这样设计） import numpy as np s = pd.Series( np.array([27.2, 27.65, 27.70, 28, 28, np.nan]) ) print( 'The length is', len(s) ) print( 'The shape is', s.shape ) print( 'The count is', s.count() ) The length is 6 The shape is (6,) The count is 5 s.unique() array([27.2 , 27.65, 27.7 , 28. , nan]) s.value_counts() 28.00 2 27.70 1 27.65 1 27.20 1 dtype: int64 用字典 创建 Series 还可以用字典。字典的「键值对」的「键」自动变成了 Series 的索引 (index)，而「值」自动变成了Series 的值 (values)。代码如下 (下列用 name 参数来对 s3 命名) data_dict = { 'BABA': 187.07, 'PDD': 21.83, 'JD': 30.79, 'BIDU': 184.77 } s3 = pd.Series(data_dict, name='中概股') s3.index.name = '股票代号' s3 股票代号 BABA 187.07 PDD 21.83 JD 30.79 BIDU 184.77 Name: 中概股, dtype: float64 给 s3 起名中概股是因为阿里巴巴 (BABA)、拼多多 (PDD)、京东 (JD) 和百度 (BIDU) 都是中国公司但在美国上市的。此外还可以给 index 命名为 ‘股票代号’。 现在假设这里的股票代号为 stock = ['FB', 'BABA', 'PDD', 'JD'] s4 = pd.Series( s3, index=stock ) s4 FB NaN BABA 187.07 PDD 21.83 JD 30.79 Name: 中概股, dtype: float64 代号里多加了脸书 (FB)，而 sdata 字典中没有 FB 这个键，因此生成的 s4 在 FB 索引下对应的值为 NaN。再者，代号里没有百度 (BIDU)，因此 s4 里面没有 BIDU 对应的值 (即便 sdata 里面有)。 当两个 Series 进行某种操作时，比如相加，Python 会自动对齐不同 Series 的 index，如下面代码所示： s3 + s4 BABA 374.14 BIDU NaN FB NaN JD 61.58 PDD 43.66 Name: 中概股, dtype: float64 Series 是 Pandas 里面最基本的数据结构，但是对应每个索引只有一个元素 (比如一个日期对应一个股价)，因此 Series 处理不了每个索引对应多个元素 (比如一个日期对应一个开盘价、收盘价、交易量等等)。而 DataFrame 可以解决这个问题。 二维 DataFrame 创建 DataFrame 只需用下面一行代码 pd.DataFrame( x, index=idx, columns=col ) 其中 x 可以是 二维列表 (list) 二维 numpy 数组 (ndarray) 字典 (dict)，其值是一维列表、numpy 数组或 Series 另外一个 DataFrame 回顾Python编程基础中函数的定义，那么 x 是位置参数 index 是默认参数，默认值为 idx = range(0, x.shape[0]),行索引 columns 是默认参数，","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:4:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"2 数据表的存载 本节讲数据表的「保存」和「加载」，在 NumPy 一贴已经提到过，数据的存载没什么技术含量 保存只是为了下次再用处理好的 DataFrame 加载可以不用重新再定义 DataFrame DataFrame 可以被保存为 Excel, csv, SQL 和 HDF5 格式，其语句一看就懂，用 to_数据格式，具体如下： to_excel() to_csv() to_sql() to_hdf() 如果要加载某种格式的数据到 DataFrame 里，用 read_数据格式，具体如下： read_excel() read_csv() read_sql() read_hdf() 这里只用 excel 和 csv 格式举例。 Excel 格式 用 pd.to_excel 函数将 DataFrame 保存为 .xlsx 格式，并保存到 ‘Sheet1’ 中，具体写法如下： pd.to_excel( ‘文件名’，‘表名’ ) df = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6]])) df.to_excel('pd_excel.xlsx', sheet_name='Sheet2')#sheet_name :字符串,默认“Sheet1”，将包含DataFrame的表的名称。 df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 0 1 2 3 1 4 5 6 用 pd.read_excel( ‘文件名’，‘表名’ ) 即可加载该文件并存成 DataFrame 形式 df1 = pd.read_excel('pd_excel.xlsx', sheet_name='Sheet2') df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 0 1 2 0 0 1 2 3 1 1 4 5 6 csv 格式 用 pd.to_csv 函数将 DataFrame 保存为 .csv 格式，注意如果 index 没有特意设定，最后不要把 index 值存到 csv 文件中。具体写法如下： pd.to_csv( ‘文件名’，index=False ) data = {'Code': ['BABA', '00700.HK', 'AAPL', '600519.SH'], 'Name': ['阿里巴巴', '腾讯', '苹果', '茅台'], 'Market': ['US', 'HK', 'US', 'SH'], 'Price': [185.35, 380.2, 197, 900.2], 'Currency': ['USD', 'HKD', 'USD', 'CNY']} df = pd.DataFrame(data) df.to_csv('pd_csv.csv', index=False) 用 pd.read_csv( ‘文件名’ ) 即可加载该文件并存成 DataFrame 形式 df2 = pd.read_csv('pd_csv.csv') df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Code Name Market Price Currency 0 BABA 阿里巴巴 US 185.35 USD 1 00700.HK 腾讯 HK 380.20 HKD 2 AAPL 苹果 US 197.00 USD 3 600519.SH 茅台 SH 900.20 CNY 如果一开始储存 df 的时候用 index=True，会发现加载完后的 df2 是以下的样子。 df2 里面第一栏是 df 的 index，由于没有具体的 columns 名称，系统给它一个 “Unamed: 0”。因此在存储 df 的时候，如果 df.index 没有特意设定，记住要在 to_csv() 中把 index 设置为 False。 ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:5:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3 数据表的索引和切片 由于索引/切片 Series 跟 numpy 数组很类似，因此本节只专注于对 DataFrame 做索引和切片。本节以下面 df 为例做展示。 symbol = ['BABA', 'JD', 'AAPL', 'MS', 'GS', 'WMT'] data = {'行业': ['电商', '电商', '科技', '金融', '金融', '零售'], '价格': [176.92, 25.95, 172.97, 41.79, 196.00, 99.55], '交易量': [16175610, 27113291, 18913154, 10132145, 2626634, 8086946], '雇员': [101550, 175336, 100000, 60348, 36600, 2200000]} df = pd.DataFrame( data, index=symbol ) df.name='美股' df.index.name = '代号' df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 BABA 电商 176.92 16175610 101550 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 MS 金融 41.79 10132145 60348 GS 金融 196.00 2626634 36600 WMT 零售 99.55 8086946 2200000 用不同颜色标注了 df 的 index, columns 和 values，可视图如下： DataFrame 的索引或切片可以基于标签 (label-based) ，也可以基于位置 (position-based)，不像 numpy 数组的索引或切片只基于位置。 DataFrame 的索引或切片有四大类： 索引单元素： 基于标签的 at 基于位置的 iat 切片 columns： 用 . 来切片单列 用 [] 来切片单列或多列 基于标签的 loc 基于位置的 iloc 切片 index： 用 [] 来切片单行或多行 基于标签的 loc 基于位置的 iloc 切片 index 和 columns： 基于标签的 loc 基于位置的 iloc 总体规律，基于标签就用 at 和 loc，基于位置就用 iat 和 iloc。下面来一类类分析： ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.1 索引单元素 两种方法来索引单元素，情况 1 基于标签 at，情况 2 基于位置 iat。 情况 1 - df.at[‘idx_i’, ‘attr_j’] 情况 2 - df.iat[i, j] Python 里的中括号 [] 会代表很多意思，比如单元素索引，多元素切片，布尔索引等等，因此让 Python 猜你用的 [] 意图会很低效。如果想索引单元素，明明白白的用 at 和 iat 效率最高。 情况 1 df.at['AAPL','价格'] 172.97 用 at 获取「行标签」为 ‘AAPL’ 和「列标签」为 ‘价格’ 对应的元素。 情况 2 df.iat[2,1] 172.97 用 iat 获取第 3 行第 2 列对应的元素。 索引单元素的总结图： ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:1","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.2 切片 columns 切片单个 columns 切片单个 columns 会返回一个 Series，有以下四种情况。情况 1 用点 .；情况 2 用中括号 []；情况 3 基于标签 loc，情况 4 基于位置 iloc。 情况 1 - df.attr_i 情况 2 - df[‘attr_i’] 情况 3 - df.loc[:, ‘attr_i’] 情况 4 - df.iloc[:, i] 情况 1 记住就可以了，没什么可说的。 情况 2 非常像二维 numpy 数组 arr 的切片，用 arr[i] 就能获取 arr 在「轴 0」上的第 i 个元素 (一个 1darray)，同理 df[‘attr_i’] 也能获取 df 的第 i 个 Series。 情况 3 和 4 的 loc 和 iloc 可类比于上面的 at 和 iat。带 i 的基于位置 (位置用整数表示，i 也泛指整数)，不带 i 的基于标签。里面的冒号 : 代表所有的 index (和 numpy 数组里的冒号意思相同)。 个人建议，如果追求简洁和方便，用 . 和 []；如果追求一致和清晰，用 loc 和 iloc。 情况 1 df.价格 代号 BABA 176.92 JD 25.95 AAPL 172.97 MS 41.79 GS 196.00 WMT 99.55 Name: 价格, dtype: float64 用 . 获取「价格」那一栏下的 Series。 情况 2 df['价格'] 代号 BABA 176.92 JD 25.95 AAPL 172.97 MS 41.79 GS 196.00 WMT 99.55 Name: 价格, dtype: float64 用 [] 获取「价格」属性下的 Series。 情况 3 df.loc[:, '交易量'] 代号 BABA 16175610 JD 27113291 AAPL 18913154 MS 10132145 GS 2626634 WMT 8086946 Name: 交易量, dtype: int64 用 loc 获取「交易量」属性下的 Series。 情况 4 df.iloc[:, 0] 代号 BABA 电商 JD 电商 AAPL 科技 MS 金融 GS 金融 WMT 零售 Name: 行业, dtype: object 用 iloc 获取第 1 列下的 Series。 切片单个 columns 的总结图： 切片多个 columns 切片多个 columns 会返回一个 sub-DataFrame (原 DataFrame 的子集)，有以下三种情况。情况 1 用中括号 []；情况 2 基于标签 loc，情况 3 基于位置 iloc。 情况 1 - df[[‘attr_i’, ‘attr_j’]] 情况 2 - df.loc[:, ‘attr_i’:‘attr_j’] 情况 3 - df.iloc[:, i:j] 和切片单个 columns 相比： 情况 1 用一个列表来储存一组属性 ‘attr_i’, ‘attr_j’，然后在放进中括号 [] 里获取它们 情况 2 用 ‘attr_i’:‘attr_j’ 来获取从属性 i 到属性 j 的 sub-DataFrame 情况 3 用 i:j 来获取从列 i+1 到列 j 的 sub-DataFrame 个人建议，如果追求简洁和方便，用 []；如果追求一致和清晰，用 loc 和 iloc。 情况 1 df[ ['雇员', '价格'] ]#两个中括号 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 雇员 价格 代号 BABA 101550 176.92 JD 175336 25.95 AAPL 100000 172.97 MS 60348 41.79 GS 36600 196.00 WMT 2200000 99.55 用 [] 获取「雇员」和「价格」两个属性下的 sub-DataFrame。 情况 2 df.loc[:, '行业':'交易量'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 代号 BABA 电商 176.92 16175610 JD 电商 25.95 27113291 AAPL 科技 172.97 18913154 MS 金融 41.79 10132145 GS 金融 196.00 2626634 WMT 零售 99.55 8086946 用 loc 获取从属性 ‘行业’ 到 ‘交易量‘ 的 sub-DataFrame。 情况 3 df.iloc[:, 0:2] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 代号 BABA 电商 176.92 JD 电商 25.95 AAPL 科技 172.97 MS 金融 41.79 GS 金融 196.00 WMT 零售 99.55 用 iloc 获取第 1 和 2 列下的 sub-DataFrame。 切片多个 columns 的总结图： ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:2","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.3 切片 index 切片单个 index 切片单个 index 有时会返回一个 Series，有以下两种情况。情况 1 基于标签 loc，情况 2 基于位置 iloc。 情况 1 - df.loc[‘idx_i’, :] 情况 2 - df.iloc[i, :] 切片单个 index 有时会返回一个只有一行的 DataFrame，有以下两种情况。情况 3 用中括号 [] 加「位置」，情况 4 用中括号 [] 加「标签」。 情况 3 - df[i:i+1] 情况 4 - df[‘idx_i’:‘idx_i’] 情况 1 和 2 的 loc 和 iloc 可类比于上面的 at 和 iat。带 i 的基于位置 (位置用整数表示，i 也泛指整数)，不带 i 的基于标签。里面的冒号 : 代表所有的 columns (和 numpy 数组里的冒号意思相同)。 情况 3 用中括号 [] 加「位置」，位置 i:i+1 有前闭后开的性质。如果要获取第 i+1 行，需要用 i:i+1。 情况 4 用中括号 [] 加「标签」，标签没有前闭后开的性质。如果要获取标签 i，只需要用 ‘idx_i’:‘idx_i’。为什么不能只用 ‘idx_i’ 呢？原因是 Python 会把 df[‘idx_i’] 当成切片 columns，然后发现属性中没有 ‘idx_i’ 这一个字符，会报错的。 个人建议，只用 loc 和 iloc。情况 3 太麻烦，获取一行还要用 i:i+1。情况 4 的 df[‘idx_i’] 很容易和切片 columns 中的语句 df[‘attr_j’] 混淆。 情况 1 df.loc[ 'GS', : ] 行业 金融 价格 196 交易量 2626634 雇员 36600 Name: GS, dtype: object 用 loc 获取标签为 ‘GS‘ 的 Series。(GS = Goldman Sachs = 高盛) 情况 2 df.iloc[ 3, : ] 行业 金融 价格 41.79 交易量 10132145 雇员 60348 Name: MS, dtype: object 用 iloc 获取第 4 行下的 Series。(MS = Morgan Stanley = 摩根斯坦利) 情况 3 df[1:2] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 JD 电商 25.95 27113291 175336 用 [1:2] 获取第 2 行的 sub-DataFrame (只有一行)。 情况 4 df['JD':'JD']#一个头一个尾 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 JD 电商 25.95 27113291 175336 df['JD':'MS'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 MS 金融 41.79 10132145 60348 用 [‘JD’:‘JD’] 获取标签为 ‘JD’ 的 sub-DataFrame (只有一行)。 切片单个 index 的总结图： 切片多个 index 切片多个 index 会返回一个 sub-DataFrame，有以下四种情况。情况 1 用中括号 [] 加「位置」，情况 2 用中括号 [] 加「标签」，情况 3 基于标签 loc，情况 4 基于位置 iloc。 情况 1 - df[i:j] 情况 2 - df[‘idx_i’:‘idx_j’] 情况 3 - df.loc[‘idx_i’:‘idx_j’, :] 情况 4 - df.iloc[i:j, :] 和切片单个 index 相比： 情况 1 用 [i:j] 来获取行 i+1 到行 j 的 sub-DataFrame 情况 2 用 [‘idx_i’:‘idx_j’] 来获取标签 i 到标签 j 的 sub-DataFrame 情况 3 用 loc 加 ‘idx_i’:‘idx_j’ 来获取从标签 i 到标签 j 的 sub-DataFrame 情况 4 用 iloc 加 i:j 来获取从行 i+1 到行 j 的 sub-DataFrame 个人建议，只用 loc 和 iloc。情况 1 和 2 的 df[] 很容易混淆中括号 [] 里的到底是切片 index 还是 columns。 情况 1 df[ 1:4 ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 MS 金融 41.79 10132145 60348 用 [1:4] 获取第 2 到 4 行的 sub-DataFrame。 情况 2 df[ 'GS':'WMT' ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 GS 金融 196.00 2626634 36600 WMT 零售 99.55 8086946 2200000 用 [‘GS’:‘WMT’] 获取标签从’GS’ 到 ‘WMT’ 的 sub-DataFrame。(WMT = Walmart = 沃尔玛) 情况 3 df.loc[ 'MS':'GS', : ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 MS 金融 41.79 10132145 60348 GS 金融 196.00 2626634 36600 用 loc 获取标签从 ‘MS‘ 到 ‘GS’ 的 sub-DataFrame。注意 ‘MS’:’GS’ 要按着 index 里面元素的顺序，要不然会返回一个空的 DataFrame，比如： df.loc[ 'MS':'JD', : ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 情况 4 df.iloc[ 1:3, : ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 用 iloc 获取第 2 到 3 行的 sub-DataFrame。 切片多个 index 的总结图： ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:3","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.4 切片 index 和 columns 切片多个 index 和 columns 会返回一个 sub-DataFrame，有以下两种情况。情况 1 基于标签 loc，情况 2 基于位置 iloc。 情况 1 - df.loc[‘idx_i’:‘idx_j’, ‘attr_k’:‘attr_l’] 情况 2 - df.iloc[i:j, k:l] 清清楚楚，明明白白，用 loc 和 iloc。 情况 1 df.loc[ 'GS':'WMT', '价格': ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 价格 交易量 雇员 代号 GS 196.00 2626634 36600 WMT 99.55 8086946 2200000 用 loc 获取行标签从 ‘GS‘ 到 ‘WMT’，列标签从’价格’到最后的 sub-DataFrame。 情况 2 df.iloc[ :2, 1:3 ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 价格 交易量 代号 BABA 176.92 16175610 JD 25.95 27113291 用 iloc 获取第 1 到 2 行，第 1 到 2 列的 sub-DataFrame。 切片 index 和 columns 的总结图： ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:4","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.5 高级索引 高级索引 (advanced indexing) 可以用布尔索引 (boolean indexing) 和调用函数 (callable function) 来实现，两种方法都返回一组“正确”的索引，而且可以和 loc , iloc , [] 一起套用，具体形式有以下常见几种： df.loc[布尔索引, :] df.iloc[布尔索引, :] df[布尔索引] df.loc[调用函数, :] df.iloc[调用函数, :] df[调用函数] 还有以下罕见几种： df.loc[:, 布尔索引] df.iloc[:, 布尔索引] df.loc[:, 调用函数] df.iloc[:, 调用函数] 读者可以想一想为什么第一组形式「常见」而第二组形式「罕见」呢？(Hint: 看看两组里冒号 : 在不同位置，再想想 DataFrame 每一行和每一列中数据的特点) 布尔索引 在〖数组计算之 NumPy (上)〗提过，布尔索引就是用一个由布尔类型值组成的数组来选择元素的方法。 当要过滤掉雇员小于 100,000 人的公司，可以用 loc 加上布尔索引。 print( df.雇员 \u003e= 100000 ) df.loc[ df.雇员 \u003e= 100000, : ] 代号 BABA True JD True AAPL True MS False GS False WMT True Name: 雇员, dtype: bool .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 BABA 电商 176.92 16175610 101550 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 WMT 零售 99.55 8086946 2200000 一种更简便的表达形式是用 df[]，但是个人不喜欢 []，总觉得会引起「到底在切片 index 还是 columns」的歧义。 df[ df.雇员 \u003e= 100000 ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 BABA 电商 176.92 16175610 101550 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 WMT 零售 99.55 8086946 2200000 现在来看一个「罕见」例子，假如想找到所有值为整数型的 columns print( df.dtypes == 'int64' ) df.loc[ :, df.dtypes == 'int64' ] 行业 False 价格 False 交易量 True 雇员 True dtype: bool .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 交易量 雇员 代号 BABA 16175610 101550 JD 27113291 175336 AAPL 18913154 100000 MS 10132145 60348 GS 2626634 36600 WMT 8086946 2200000 调用函数 调用函数是只能有一个参数 (DataFrame, Series) 并返回一组索引的函数。因为调用函数定义在 loc , iloc , [] 里面，因此它就像在〖Python编程基础〗提过的匿名函数。 当要找出交易量大于平均交易量的所有公司，可以用 loc 加上匿名函数 (这里 x 代表 df)。 df.loc[ lambda x: x.交易量 \u003e x.交易量.mean() , : ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 BABA 电商 176.92 16175610 101550 JD 电商 25.95 27113291 175336 AAPL 科技 172.97 18913154 100000 在上面基础上再加一个条件 – 价格要在 100 之上 (这里 x 还是代表 df) df.loc[ lambda x: (x.交易量 \u003e x.交易量.mean()) \u0026 (x.价格 \u003e 100), : ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 行业 价格 交易量 雇员 代号 BABA 电商 176.92 16175610 101550 AAPL 科技 172.97 18913154 100000 最后来看看价格大于 100 的股票 (注意这里 x 代表 df.价格) df.价格.loc[ lambda x: x \u003e 100 ] 代号 BABA 176.92 AAPL 172.97 GS 196.00 Name: 价格, dtype: float64 ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:5","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.6 多层索引 层次化索引（hierarchical indexing）也叫多层索引，是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。多层索引可以将「低维数据」升维到「高维数据」。抽象点说，它使你能以低维度形式处理高维度数据。 多层索引 Series 首先定义一个 Series，注意它的 index 是一个二维列表，列表第一行 dates 作为第一层索引，第二行 codes 作为第二层索引。 price = [190,32,196,192,200,189,31,30,199] dates = ['2019-04-01']*3 + ['2019-04-02']*2+['2019-04-03']*2 + ['2019-04-04']*2 codes = ['BABA','JD','GS','BABA','GS','BABA','JD','JD','GS'] data = pd.Series( price, index=[ dates, codes ]) data 2019-04-01 BABA 190 JD 32 GS 196 2019-04-02 BABA 192 GS 200 2019-04-03 BABA 189 JD 31 2019-04-04 JD 30 GS 199 dtype: int64 这个 Series 存储了四天里若干股票的价格，2019-04-01 储存了阿里巴巴、京东和高盛的股价，2019-04-04 只储存了京东和高盛的股价。试想，如果不用多层索引的 Series，则需要用一个 DataFrame 来存储在这样的数据，把 index 设置成 dates，把 colums 设置成 codes。 来看看 Series 的多层 index 是如何表示的 data.index MultiIndex([('2019-04-01', 'BABA'), ('2019-04-01', 'JD'), ('2019-04-01', 'GS'), ('2019-04-02', 'BABA'), ('2019-04-02', 'GS'), ('2019-04-03', 'BABA'), ('2019-04-03', 'JD'), ('2019-04-04', 'JD'), ('2019-04-04', 'GS')], ) 输出是一个 MultiIndex 的对象，里面有 levels 和 labels 二类信息。 知识点 索引既然分多层，那么肯定分「内层」和「外层」把，levels 就是描述层的先后的。levels 是一个二维列表，每一行只存储着「唯一」的索引信息： dates 是第一层索引，有 4 个「唯一」元素 codes 是第二层索引，有 3 个「唯一」元素 但是 data 里面有九行啊，4 个 dates 和 3 个 codes 怎么能描述这九行信息呢？这就需要 labels 了。labels 也是一个二维列表： 第一行储存 dates 每个元素在 data 里的位置索引 第二行储存 codes 每个元素在 data 里的位置索引 用 [] 加第一层索引可以获取第一层信息。 data['2019-04-02'] BABA 192 GS 200 dtype: int64 同理，用 loc 加第一层索引也可以切片获取第一层信息。 data.loc['2019-04-02':'2019-04-04'] 2019-04-02 BABA 192 GS 200 2019-04-03 BABA 189 JD 31 2019-04-04 JD 30 GS 199 dtype: int64 此外，切片还可以在不同层上进行，下面 loc 中的冒号 : 表示第一层所有元素，‘GS’ 表示第二层标签为 ‘GS’。 data.loc[ :, 'GS' ]#[第一层索引，第二层索引] 2019-04-01 196 2019-04-02 200 2019-04-04 199 dtype: int64 多层索引 DataFrame Series 只有 index，上面刚介绍完多层 index，DataFrame 有 index 和 columns，它们可以设置成多层吗？下面代码用 MultiIndex 函数创建「多层 index 」midx 和「多层columns」mcol。 midx 和 mcol 都是对象，各种都有 levels, labels, names 等性质。 data = [ ['电商', 101550, 176.92, 16175610], ['电商', 175336, 25.95, 27113291], ['金融', 60348, 41.79, 10132145], ['金融', 36600, 196.00, 2626634] ] midx = pd.MultiIndex( levels=[['中国','美国'], ['BABA', 'JD', 'GS', 'MS']], codes=[[0,0,1,1],[0,1,2,3]], names=['地区', '代号']) #codes是levals的排序 mcol = pd.MultiIndex( levels=[['公司数据','交易数据'], ['行业','雇员','价格','交易量']], codes=[[0,0,1,1],[0,1,2,3]], names=['概括','细分']) df = pd.DataFrame(data, index=midx, columns=mcol) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } 概括 公司数据 交易数据 细分 行业 雇员 价格 交易量 地区 代号 中国 BABA 电商 101550 176.92 16175610 JD 电商 175336 25.95 27113291 美国 GS 金融 60348 41.79 10132145 MS 金融 36600 196.00 2626634 这个 DataFrame 的 index 和 columns 都有两层，严格来说是个四维数据。下面看看如何进行「多层索引」的操作吧。 在第一层 columns 的 ‘公司数据’ 和第二层 columns 的 ‘行业’ 做索引，得到一个含两层 index 的 Series。 # 1st level-1 column, 2nd level-2 column df['公司数据','行业'] 地区 代号 中国 BABA 电商 JD 电商 美国 GS 金融 MS 金融 Name: (公司数据, 行业), dtype: object 在第一层 index 的 ‘中国’ 做切片，得到一个含两层 columns 的 DataFrame。 df.loc['中国'].loc['BABA':'JD'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } 概括 公司数据 交易数据 细分 行业 雇员 价格 交易量 代号 BABA 电商 101550 176.92 16175610 JD 电商 175336 25.95 27113291 调位 level 如果不喜欢 index level 的顺序，可用 swaplevel 将它们调位。 df.swaplevel('地区', '代号') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } 概括 公司数据 交易数据 细分 行业 雇员 价格 交易量 代号 地区 BABA 中国 电商 101550 176.92 16175610 JD 中国 电商 175336 25.95 27113291 GS 美国 金融 60348 41.79 10132145 MS 美国 金融 36600 196.00 2626634 df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { t","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:6:6","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"4 总结 Pandas 里面的数据结构是多维数据表，细化为一维的 Series，二维的 DataFrame。 pd 多维数据表 = np 多维数组 + 描述 其中 Series = 1darray + index DataFrame = 2darray + index + columns pd 多维数据表和 np 多维数组之间的类比关系如下图所示。 【创建数据表】创建 Series, DataFrame 用下面语句 pd.Series(x, index=idx) pd.DataFrame(x, index=idx, columns=col) DataFrame 由多个 Series 组成，而 Series 非常类似于一维的 DataFrame，因此学 Pandas 把注意力放在 DataFrame 上即可。 【索引和切片数据表】在索引或切片 DataFrame，有很多种方法。最好记的而不易出错的是用基于位置的 at 和 loc，和基于标签的 iat 和 iloc，具体来说，索引用 at 和 iat，切片用 loc 和 iloc。带 i 的基于位置，不带 i 的基于标签。 用 MultiIndex 可以创建多层索引的对象，获取 DataFrame df 的信息可用 df.loc[1st].loc[2nd] df.loc[1st].iloc[2nd] df.iloc[1st].loc[2nd] df.iloc[1st].iloc[2nd] 要调换 level 可用 df.index.swaplevel(0,1) df.columns.swaplevel(0,1) 要设置和重设 index 可用 df.set_index( columns ) df.reset_index 下篇讨论 Pandas 系列的后三节，分别是 「数据表的合并和连接」 「数据表的重塑和透视」 「数据表的分组和整合」 Stay Tuned! ","date":"2020-06-02","objectID":"/2020-05-26-pandas%E4%B8%8A/:7:0","tags":["python","数学建模"],"title":"Pandas (上)","uri":"/2020-05-26-pandas%E4%B8%8A/"},{"categories":["数据库"],"content":"函数 概念:类似于java的方法，将-组逻辑语句封装在方法体中，对外暴露方法名 好处: 1、隐藏了实现细节 2、 提高代码的重用性 调用: select 函数名(实参列表) [ from 表] ; 特点: 1.叫什么(函数名) 2.干什么(函数功能) 分类: 1、单行函数 如concat、 length、 ifnull等 2、分组函数 功能:做统计使用，又称为统计函数、聚合函数、组函数 ","date":"2020-05-31","objectID":"/mysql03/:0:0","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"length获取参数值的字节个数 SELECT LENGTH('john') ; SELECT LENGTH(' 张三丰hahaha') ; SHOW VARIABLES LIKE '%char%'\r ","date":"2020-05-31","objectID":"/mysql03/:0:1","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"concat拼接字符串 SELECT CONCAT (last_ name, '_ ' , first_ name) 姓名 FROM employees;\r ","date":"2020-05-31","objectID":"/mysql03/:0:2","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"upper、lower SELECT UPPER('john') ; SELECT LOWER( 'joHn') ; 示例:将姓变大写，名变小写，然后拼接 SELECT CONCAT (UPPER(last_ name) , LOWER(first_ name) )姓名 FROM employees; ","date":"2020-05-31","objectID":"/mysql03/:0:3","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"substr、substring 注意:索引从1开始 #截取从指定索引处后面所有字符 SELECT SUBSTR('欢迎来到二叉树的博客',7)out_put; #截取从指定索引处指定字符长度的字符 SELECT SUBSTR('欢迎来到二叉树的博客',5,7) out_put; 案例:姓名中首字符大写，其他字符小写然后用_拼接，显示出来 SELECT CONCAT (UPPER (SUBSTR(last_ name,1,1)) ,'_ ' , LOWER (SUBSTR(last_ name,2)) ) out_put FROM employees ;\r ","date":"2020-05-31","objectID":"/mysql03/:0:4","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"instr 返回子串第一次出现的索引，如果找不到返回0 SELECT INSTR('欢迎来到二叉树的博客', '二叉树') AS out_ put;\r ","date":"2020-05-31","objectID":"/mysql03/:0:5","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"trim SELECT LENGTH (TRIM('二叉树')) AS out_put;\rSELECT TRIM('aa' FROM 'aaaaaaaa二aaaaaaaaaaa叉树aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ')\rAS out_put;\r ","date":"2020-05-31","objectID":"/mysql03/:0:6","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"lpad 用指定的字符实现左填充指定长度 SELECT LPAD('二叉树',2, 1*1) AS out_ put;\r ","date":"2020-05-31","objectID":"/mysql03/:0:7","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"rpad 用指定的字符实现右填充指定长度 SELECT RPAD('二叉树',12, 'ab') AS out_ put;\r ","date":"2020-05-31","objectID":"/mysql03/:0:8","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"replace 替换 SELECT REPLACE('欢迎你来到二叉树的博客', '你'，'大家') AS out_ put;\r 数学函数 ","date":"2020-05-31","objectID":"/mysql03/:0:9","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"round 四舍五入 SELECT ROUND(-1.55) ; SELECT ROUND(1.567,2) ; ","date":"2020-05-31","objectID":"/mysql03/:0:10","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"ceil 向上取整,返回\u003e=该参数的最小整数 SELECT CEIL(-1.02) ;\r ","date":"2020-05-31","objectID":"/mysql03/:0:11","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"floor 向下取整，返回\u003c=该参数的最大整数 SELECT FLOOR(-9.99) ;\r ","date":"2020-05-31","objectID":"/mysql03/:0:12","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"truncate 截断 SELECT TRUNCATE (1.69999,1) ;\r ","date":"2020-05-31","objectID":"/mysql03/:0:13","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"mod 取余 /* mod(a,b) ; a-a/b*b\rmod(-10,-3) :-10- (-10)/ (-3)* (-3) =-1\r */ SELECT MOD(10,-3) ; SELECT 10号3; 日期函数 ","date":"2020-05-31","objectID":"/mysql03/:0:14","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"now 返回当前系统日期+时间 SELECT NOW() ; ","date":"2020-05-31","objectID":"/mysql03/:0:15","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"curdate 返回当前系统日期，不包含时间 SELECT CURDATE() ;\r ","date":"2020-05-31","objectID":"/mysql03/:0:16","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"curtime 返回当前时间，不包含日期 SELECT CURTIME () ;\r ","date":"2020-05-31","objectID":"/mysql03/:0:17","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"可以获取指定的部分年、月、日、小时、分钟、秒 SELECT YEAR (NOW())年; SELECT YEAR('1998-1-1') 年; SELECT YEAR (hiredate)年FROM employees; SELECT MONTH (NOW())月; SELECT MONTHNAME (NOW())月; ","date":"2020-05-31","objectID":"/mysql03/:0:18","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"补充 now:获取当前日期 str_to_date: 将日期格式的字符转换成指定格式的日期\r示例：STR_TO_DATE('9-13-1999','%m-%d-%Y')\r结果：1999-09-13\r date_ format:将日期转换成字符 DATE_ FORMAT('2018/6/6','%Y年%m月 %d日)\r结果：2018年06月06日\r 对照图： (https://pic.liesio.com/2020/06/02/71c8a64dc5fee.png) 流程控制函数 ","date":"2020-05-31","objectID":"/mysql03/:0:19","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"if函数: if else的效果 SELECT IF(10\u003c5, '大', '小'); SELECT last_ name, commission_ _pct, IF (commission_ pct Is NULL, '没奖金', '有奖金')备注 FROM employees; ","date":"2020-05-31","objectID":"/mysql03/:0:20","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"case when条件1 then 要显示的值1或语句1 when条件2 then 要显示的值2或语句2 else要显示的值n或语句n end 案例:查询员工的工资的情况 如果工资\u003e20000,显示A级别 如果工资\u003e15000,显示B级别 如果工资\u003e10000，显示c级别 SELECT salary, CASE WHEN salary\u003e20000 THEN 'A' WHEN salary\u003e15000 THEN 'B' WHEN salary\u003e10000 THEN 'C' ELSE 'D' END AS 工资级别 FROM employees ; ","date":"2020-05-31","objectID":"/mysql03/:0:21","tags":["MySQL"],"title":"MySQL数据库03(常见函数)","uri":"/mysql03/"},{"categories":["数据库"],"content":"前言 图形界面客户端下载链接 https://spiritlhl.lanzous.com/id5vuji 客户端安装 1.配置证书 2.新建用户配置 3.启用 4.询问(navaicate)窗口是命令行窗口 5.ctrl+s保存指令 6.ctrl+鼠标滚动轴调整字体大小 7.指令末尾加分号 DQL语言(Data Query Language) ","date":"2020-05-30","objectID":"/mysql02/:0:0","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"基础查询 ues 上级表名; (打开你要查询的上级表/库名) (这里点击查询的库也能进入，但不推荐使用这种方法，尽量用SQL命令执行) select 查询列表 from 表名; (查询列表可以是表中字段，常量值，表达式，函数) (查询结果是一个虚拟表格) 查询表中字段 1.查询单个字段 select xxx from 上级表名;\r 2.查询多个字段 select 字段1,字段2,字段3 from 表名; (这里的顺序与表内顺序无关，只是显示顺序) 3.查询表中所有字段 select (双击表名，此处会显示`所选表名`) from 上级表名; (这里的表名顺序无要求，是展示的顺序) (格式切换是选中所有指令后按Fn+F12，格式化) select * from 上级表名; (这种方式选中的表顺序与源顺序一样) (这里的`是着重号不是单引号，着重号主要用于区分表名为保留字，其他时候可有可无) (执行命令选中指令按Fn+F9或者按栏目里的执行按钮) 查询常量值 select 数字常量; select 字段常量;\r 查询表达式 select 100*333; (数字运算)\r 查询函数 select version();\r ","date":"2020-05-30","objectID":"/mysql02/:0:1","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"为字段起别名 方式一 使用as select 100*333 as 结果;\rselect last_name as 姓,first_name as 名 from 上级表名;\rselect xxx as yyy, kkk from 上级表名\r 好处： 1.便于理解 2.如果要查询的字段有重名，使用别名区分开来 3.别名在表头显示\r 方式二 使用空格 select last_name 姓,first_name 名 from 上级表名;\r 这里建议别名与保留字重复时用双引号或单引号括起来 ","date":"2020-05-30","objectID":"/mysql02/:0:2","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"去重 select distinct 表中字段 from 上级表名;\r ","date":"2020-05-30","objectID":"/mysql02/:0:3","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"+号作用 仅仅表示运算符 select 100+90; 两个操作数都为数值型，则做加法运算 select '123'+90; 其中一方为字符型，试图将字符型数值转换成数值型 select 'john'+90; 如果转换成功，则继续做加法运算，如果转换失败，则将字符型数值转换成0 select nu11+10; 只要其中一方为nu11，则结果肯定为nu11 ","date":"2020-05-30","objectID":"/mysql02/:0:4","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"拼接 调用concat函数 select concat('a','b','c')\r ","date":"2020-05-30","objectID":"/mysql02/:0:5","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"判断是否为空 select ifnull(表名,返回值)\r ","date":"2020-05-30","objectID":"/mysql02/:0:6","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"条件查询 语法 select\r查询列表\rfrom\r表名\rwhere\r筛选条件\r 分类 1.按条件表达式筛选 条件运算符: \u003e \u003c = \u003c= \u003e= != \u003c\u003e (最后一个是不等号) 2.按逻辑表达式筛选 逻辑运算符： \u0026与 ||或 !非 and or not 3.模糊查询\rlike between and in is null 按条件表达式筛选 案例1:查询收入大于10000的人员信息 指令如下 select\r*\rfrom\remployees\rwhere\rsalary\u003e10000;\r 案例2:查询部门编号不等于90的员工名称 指令如下 select\rlast_name,\rdepartment_id\rfrom\remployees\rwhere\rdepartment_id != 90;\r 按逻辑表达式筛选 \u0026\u0026和and:两个条件都为true,结果为true，反之为false ||或or: 只要有一个条件为true,结果为true, 反之为false |或not:_如果连按的条件本身为false, 结果为true,反之为falsd 案例3：查询工资z在10000到20000之.间的员工名、工资以及奖金 SELECT\rlast_ name ,\rsalary,\rcommission_ pct\rFROM\remployees\rWHERE\rsalary\u003e=10000 AND salary\u003c=2 0000;\r 案例4:查询部门编号不是在90到110之间，或者工资高于15000的员工信息 SELECT\r*\rFROM\remployees\rWHERE\rNOT (department_ id\u003e=90 AND department_ id\u003c=110) OR salary\u003e15000;\r ","date":"2020-05-30","objectID":"/mysql02/:0:7","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"模糊查询 like 特点: 一般和通配符搭配使用 通配符: % 任意多个字符,包含0个字符 _ 任意单个字符 案例5:查询员工名中包含字符a的员工信息 SELECT\r*\rFROM\remployees\rWHERE\rlast_ name LIKE '%a%' ;#abc\r 案例6:查询员工名中第三个字符为e，第五个字符为a的员工名和工资 SELECT\rlast_ name,\rsalary\rFROM\remployees\rWHERE\rlast_ name LIKE '__n_l%';|\r 案例7:查询员工名中第二个字符为_的员工名 SELECT\rlast_ name\rFROM\remployees\rWHERE\rlast_ name LIKE '_ $_%' ESCAPE '$' ;\r 或者 '_\\_%'也能转义_\r between and I 案例3:查询员工编号在100到120之间的员工信息 SELECT\r*\rFROM\remployees\rWHERE\remployee_ _id \u003e= 100 AND employee_ id\u003c=120;\r #———————-等同于 SELECT\r*\rFROM\remployees\rWHERE\remployee_ id BETWEEN 100 AND 120; .\r 这里的 employee_ id BETWEEN 大于等于的值 AND 小于等于的值;\r in 含义:判断某字段的值是否属于in列表中的某一项 特点: 1.使用in提高语句简洁度\r2.in列表的值类型必须一致或兼容\r3.不能和通配符混用\r 案例8:查询员工的工种编号是IT_PROG、 AD_VP、 AD_PRES中的一个员工名和工种编号 SELECT\rlast_ name,\rjob_ id\rFROM\remployees\rWHERE\rjob_ id = 'IT_ PROT' OR job_ id = 'AD_ VP' OR JOB_ ID ='AD_ PRES' ;\r 这里的 job_id = 'IT_ PROT' OR job_id = 'AD_ VP' OR JOB_ID ='AD_ PRES' ;\r 等同于 job_id IN('T_PROT','AD_ VP', 'AD_ PRES');\r is null =或\u003c\u003e不能用于判断null值 is null或is not null 可以判断null值 案例9：查询没有奖金的员工名和奖金率 SELECT\rlast_ name，.\rcommission_pct\rFROM\remployees\rWHERE\rcommission_pct IS NULL;\r 如果是查询有奖金的，写is not null 安全等于 \u003c==\u003e \u003c==\u003e可以判断null值也可以判断一般数值 Is NULL: 仅仅可以判断NULL值，可读性较高，建议使用 \u003c=\u003e: 既可以判断NULL值，又可以判断普通的数值，可读性较低 排序查询 引入: select * from employees ;\r 语法: select 查询列表\rfrom 表\r[where筛选条件]\rorder by 排序列表 [asc|desc]\r 案例:查询员工信息，要求工资从高到低排序 SELECT * FROM employees ORDER BY salary DESC;\r 案例:查询员工信息，要求工资从低到高排序 SELECT * FROM employees ORDER BY salary ASC; 特点: 1.asc代表的是升序，desc代表的是降序 2.如果不写，默认是升序 3.支持按表达式，别名，函数排序 4.order by子句一般是放在查询语句的最后面，limit子句除外 案例:按姓名的长度显示员工的姓名和工资[按函数排序] SELECT LENGTH(last_ name) 字节长度,last_ name, salary\rFROM employees\rORDER BY LENGTH (last_ name) DESC;\r 案例:查询员工信息，要求先按工资升序，再按员工编号降序[按多个字段排序] SELECT * FROM employees ORDER BY salary ASC, employee_ _id DESC; ","date":"2020-05-30","objectID":"/mysql02/:0:8","tags":["MySQL"],"title":"MySQL数据库02(图形界面客户端基本运行指令)","uri":"/mysql02/"},{"categories":["数据库"],"content":"前言 MySQL数据库下载链接(5.5版本) https://spiritlhl.lanzous.com/id5vt2f 常用指令 1.查看当前所有的数据库 show dat abases; 2.打开指定的库 use 库名; 3.查看当前库的所有表 show_ tables; 4.查看其它库的所有表 show tables from 库名; 5.创建表 create table 表名( 列名 列类型， 列名 列类型， ... ) 6.查看表结构 desc表名; 启动与退出 #cmder 管理员模式下 C:\\Users\\祈LHL\\Desktop $ net stop mysql MySQL 服务正在停止. MySQL 服务已成功停止。 C:\\Users\\祈LHL\\Desktop $ net start mysql MySQL 服务正在启动 . MySQL 服务已经启动成功。 或者直接打开控制面板，搜索服务在服务中找到MySQL右键属性选择手动或开机自启，右键选择打开或关闭服务 登录与退出登录 #cmder 管理员模式下 C:\\Users\\祈LHL\\Desktop $ mysql -h localhost -P3306 -u root -p Enter password: 你的root账号密码 #这里的【-h主机名 -P端口号】在本地客户端里可以不输入， -u用户名 -p密码 Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.5.62 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql\u003e exit Bye 或直接在左下角开始图标里找到MySQL 5.5 Command Line Client点击打开输入root密码，退出输入exit或ctrl+c 显示存在的目录 mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | test | +--------------------+ 4 rows in set (0.01 sec) mysql\u003e use test;#进入test库 Database changed mysql\u003e show tables;#展示表 Empty set (0.01 sec) mysql\u003e show tables from mysql; #这里还在test库，只是去查看mysql库，没有离开test库 +---------------------------+ | Tables_in_mysql | +---------------------------+ | columns_priv | | db | | event | | func | | general_log | | help_category | | help_keyword | | help_relation | | help_topic | | host | | ndb_binlog_index | | plugin | | proc | | procs_priv | | proxies_priv | | servers | | slow_log | | tables_priv | | time_zone | | time_zone_leap_second | | time_zone_name | | time_zone_transition | | time_zone_transition_type | | user | +---------------------------+ 24 rows in set (0.00 sec) mysql\u003e select database(); #查看在哪个库 +------------+ | database() | +------------+ | NULL | +------------+ 1 row in set (0.00 sec) 创建表 mysql\u003e create table stuinfo( -\u003e id int, -\u003e name varchar(20)); Query OK, 0 rows affected (0.02 sec) 查看表 # desc 加 空格 加 表名 mysql\u003e desc stuinfo; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 2 rows in set (0.02 sec) 查看表内数据 select * from stuinfo; 小技巧 如果你之前输入过相同命令且与你的输入行接近，按键盘上下键可以切换你输入过的命令，可以避免重复输入相同命令消耗时间，cmder下可以选中命令后右键点击，自动复制该命令到输入的行 查看数据库版本 #已经登陆时输入(SQL指令) mysql\u003e select version(); +-----------+ | version() | +-----------+ | 5.5.62 | +-----------+ 1 row in set (0.01 sec) #未登录时输入(windows指令) $ mysql --version mysql Ver 14.14 Distrib 5.5.62, for Win64 (AMD64) #或者输入(windows指令) mysql -V mysql Ver 14.14 Distrib 5.5.62, for Win64 (AMD64) ","date":"2020-05-29","objectID":"/mysql01/:0:0","tags":["MySQL"],"title":"MySQL数据库01(cmder基本运行指令)","uri":"/mysql01/"},{"categories":["python","爬虫"],"content":"前言 最好有Selenium的Web自动化的实际经验 运行基础：client库(0.52版本)，Appium Server，安卓SDK(含JDK环境)，USB调试模式下的手机(开发者模式) 定位元素 从示例代码就可以发现，和Selenium Web自动化一样，要操作界面元素，必须先定位(选择)元素。 Appium是基于Selenium的，所以和Selenium代码定位元素的基本规则相同： find_element_by_XXX方法，返回符合条件的第一个元素，找不到抛出异常 find_elements_by_XXX方法，返回符合条件的所有元素的列表，找不到返回空列表 通过WebDriver对象调用这样的方法，查找范围是整个界面 通过WebElement对象调用这样的方法，查找范围是该节点的子节点 界面元素查看工具 做Selenium Web自动化的时候，要找到元素，我们是通过浏览器的开发者工具栏来查看元素的特性，根据这些特性（属性和位置），来定位元素 Appium要自动化手机应用，同样需要工具查看界面元素的特征。 常用的查看工具： Android Sdk中的uiautomateviewer Appium Desktop中的Appium Inspector ","date":"2020-05-24","objectID":"/2020-05-24-appium02/:0:0","tags":["python","爬虫"],"title":"Appium自动化操作02(元素定位及查看工具)","uri":"/2020-05-24-appium02/"},{"categories":["python","爬虫"],"content":"uiautomateviewer 安卓查看APP界面元素，最常用的就是Android SDK中的工具uiautomateviewer，它在SDK目录目录的tools\\bin目录中 和Selenium一样，我们要定位选择元素，也是根据元素的特征，包括: 元素的属性\r元素的相对位置（相对父元素、兄弟元素等）\r具体细节，参考视频里面的讲解。\r ","date":"2020-05-24","objectID":"/2020-05-24-appium02/:1:0","tags":["python","爬虫"],"title":"Appium自动化操作02(元素定位及查看工具)","uri":"/2020-05-24-appium02/"},{"categories":["python","爬虫"],"content":"Appium Inspector Appium Desktop中的Appium Inspector也可以查看元素。 它的一个优点是可以直接验证选择表达式是否能定位到元素 ","date":"2020-05-24","objectID":"/2020-05-24-appium02/:2:0","tags":["python","爬虫"],"title":"Appium自动化操作02(元素定位及查看工具)","uri":"/2020-05-24-appium02/"},{"categories":["python","爬虫"],"content":"定位元素的方法 1.根据ID 在Selenium Web自动化里，如果能根据ID选择定位元素，最好根据ID，因为通常来说ID是唯一的，所以根据ID选择 效率高。 在安卓应用自动化的时候，同样可以根据ID查找。 但是这个ID，是安卓应用元素的resource-id属性 具体代码： driver.find_element_by_id('') 2.根据CLASS NAME 安卓界面元素的class属性其实就是根据元素的类型，类似web里面的tagname， 所以通常不是唯一的。 通常，我们根据class属性来选择元素，是要选择多个而不是一个。 当然如果你确定要查找的界面元素的类型 在当前界面中只有一个，就可以根据class来唯一选择。 具体代码： driver.find_elements_by_class_name('') 3.根据ACCESSIBILITY ID 元素的content-desc属性是用来描述该元素的作用的。 如果要查询的界面元素有content-desc属性，我们可以通过它来定位选择元素。 具体代码： driver.find_element_by_accessibility_id('') 4.Xpath Appium也支持通过Xpath选择元素。 但是其可靠性和性能不如Selenium Web自动化。因为Web自动化对Xpath的支持是由浏览器实现的，而Appium Xpath的支持是Appium Server实现的。 毕竟，浏览器产品的成熟度比Appium要高很多。 当然，Xpath是标准语法，所以这里表达式的语法规则和Selenium里面Xpath的语法是一样的，比如 driver.find_element_by_xpath('//ele0/ele1[@attr=\"value\"]') 注意： selenium自动化中，xpath表达式中每个节点名是html的tagname。 但是在appium中，xpath表达式中每个节点名是元素的class属性值。 比如：要选择所有的文本节点，就用如下代码: driver.find_element_by_xpath('//android.widget.TextView') ","date":"2020-05-24","objectID":"/2020-05-24-appium02/:3:0","tags":["python","爬虫"],"title":"Appium自动化操作02(元素定位及查看工具)","uri":"/2020-05-24-appium02/"},{"categories":["python","爬虫"],"content":"参考文档 根据id，classname， accessibilityid，xpath这些方法选择元素，其实底层都是利用了安卓uiautomator框架的API功能实现的。 这里是谷歌安卓官方文档介绍： https://developer.android.google.cn/training/testing/ui-automator 也就是说，程序的这些定位请求，被Appium server转发给手机自动化代理程序，就转化为为uiautomator里面相应的定位函数调用。 其实，自动化程序，可以直接告诉手机上的自动化代理程序，让它调用UI Automator API的java代码，实现最为直接的自动化控制。 主要是通过UiSelector这个类里面的方法实现元素定位的，比如 code = 'new UiSelector().text(\"热门\").className(\"android.widget.TextView\")' ele = driver.find_element_by_android_uiautomator(code) ele.click() 就是通过text属性和className的属性两个条件来定位元素。 UiSelector里面有些元素选择的方法可以解决前面解决不了的问题。 比如 text方法 可以根据元素的文本属性查找元素\r textContains 根据文本包含什么字符串\r textStartsWith 根据文本以什么字符串开头\r textmartch方法 可以使用正则表达式选择一些元素，如下\r```python\rcode = 'new UiSelector().textMatches(\"^我的.*\")'\r```\r UiSelector的instance和index也可以用来定位元素，都是从0开始计数，他们的区别： instance是匹配的结果所有元素里面 的第几个元素\rindex则是其父元素的几个节点，类似xpath里面的*[n]\r UiSelector的childSelector可以选择后代元素，比如 code = 'new UiSelector().resourceId(\"tv.danmaku.bili:id/recycler_view\").childSelector(new UiSelector().className(\"android.widget.TextView\"))' ele = driver.find_element_by_android_uiautomator(code) 注意：childSelector后面的引号要框住整个uiSelector的表达式 ","date":"2020-05-24","objectID":"/2020-05-24-appium02/:4:0","tags":["python","爬虫"],"title":"Appium自动化操作02(元素定位及查看工具)","uri":"/2020-05-24-appium02/"},{"categories":["python","爬虫"],"content":"前言 最好有Selenium的Web自动化的实际经验 运行基础：client库(0.52版本)，Appium Server，安卓SDK(含JDK环境)，USB调试模式下的手机(开发者模式) 所用apk包(wv.apk)链接： https://spiritlhl.lanzous.com/icxhm7g 界面操作和adb命令 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:0","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"click点击 最常见的操作之一，使用WebElement对象的click方法。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:1","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"tap点按 WebElement对象的tap方法和click类似，都是点击界面。 但是最大的区别是，tap是针对坐标而不是针对找到的元素。 为了保证自动化代码在所有分辨率的手机上都能正常执行，我们通常应该使用click方法。 但有的时候，我们难以用通常的方法定位元素，可以用这个tap方法，根据坐标来点击 用inspect查看该元素的属性中，有一个bounds属性吗？ 它就是表示元素的左上角，右下角坐标的坐标。 我们还可以使用UIAutomatorviewer直接十字光标移动，看右边的属性提示。 tap方法可以像这样进行调用 driver.tap([(1100,1080),],700) 它有两个参数： 第一个参数是个列表，表示点击的坐标。 注意最多可以有5个元素，代表5根手指点击5个坐标。所以是list类型。 如果我们只要模拟一根手指点击屏幕，list中只要一个元素就可以了 第二个参数表示tap点按屏幕后停留的时间（毫秒）。 如果点按时间过长，就变成了长按操作了。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:2","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"输入 最常见的操作之一，使用WebElement对象的send_keys方法。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:3","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"获取界面文本信息 可以通过WebElement对象的.text属性获取该对象的文本信息。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:4","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"滑动 做移动app测试的时候，经常需要滑动界面。 这需要使用WebDriver对象的swipe方法。 driver.swipe(start_x=x, start_y=y1, end_x=x, end_y=y2, duration=800) 前面4个参数是滑动起点和终点的x、y坐标。 第5个参数duration是滑动从起点到终点坐标所耗费的时间（毫秒）。 注意这个时间非常重要，在屏幕上滑动同样的距离，如果时间设置的很短，就是快速的滑动。 例如：一个翻动新闻的界面，快速的滑动，就会是扫动的动作，会导致内容随惯性滚动很多。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:5","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"按键 调用press_keycode方法，就能模拟按键动作，包括安卓手机的实体按键和键盘按钮。 具体代码如下： from appium.webdriver.extensions.android.nativekey import AndroidKey # 输入回车键，确定搜索 driver.press_keycode(AndroidKey.ENTER) 按键的定义，可以参考这篇文档https://github.com/appium/python-client/blob/master/appium/webdriver/extensions/android/nativekey.py ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:6","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"长按、双击、移动 Appium的TouchAction类提供了更多的手机操作方法，如：长按、双击、移动 参考源代码中的注释https://github.com/appium/python-client/blob/master/appium/webdriver/common/touch_action.py 下面有一个长按的例子 from appium.webdriver.common.touch_action import TouchAction actions = TouchAction(driver) actions.long_press(element) actions.perform() ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:7","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"打开通知栏 安卓手机，查看通知栏的动作可以是从屏幕顶端下滑来查看通知。 也可以使用如下代码，直接打开通知栏 driver.open_notifications() 通知栏里面的元素，自动化的方法和前面介绍的App界面元素自动化是一样的。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:8","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"收起通知栏 收起通知栏，可以使用前面介绍的模拟按键，发出返回按键的方法。 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:9","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"adb 命令 android sdk里面有一个命令行工具adb。 adb全称Android Debug Bridge，这个adb使用非常广泛。 它可以与Android手机设备进行通信，它可进行各种设备操作。 如：安装应用和调试应用，传输文件，甚至登录到手机设备上shell的进行访问，就像远程登录一样 这个adb在sdk的platform-tools目录下面，请大家确保路径在Path环境变量中。 Appium对anroid的自动化非常依赖这个adb工具。执行自动化过程中，有很多内部操作，比如获取设备信息，传送文件到手机，安装apk，启动某些程序等，都是通常这个adb实现的。 adb命令既然是个命令，就可以使用Python的os.system()或者subprocess来自动化调用它，完成我们的各种自动化需求。 而自动化过程中，可能需要截屏手机，并且下载到指定目录中，可以在Python程序中这样写 import os os.system('adb shell screencap /sdcard/screen3.png \u0026\u0026 adb pull /sdcard/screen3.png') 特别的，还可以通过adb使用am(activity manager)和pm(package manager)两个工具，可以启动Activity、强行停止进程、广播intent、修改设备屏幕属性、列出应用、卸载应用等。 adb命令的官方文档：https://developer.android.google.cn/studio/command-line/adb.html#devicestatus 一些常见的adb命令： 查看连接的设备 adb devices -l\r 查看文件目录 adb shell ls /sdcard\r 上传文件 adb push wv.apk /sdcard/wv.apk\r 下载文件 adb pull /sdcard/new.txt\r 截屏 adb shell screencap /sdcard/screen.png\r 截屏后的文件存在手机上，可以使用adb pull下载下来 ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:10","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"shell 登录到手机设备上shell的进行访问，就像远程登录一样，可用来在连接的设备上运行各种命令。 输入adb shell然后执行各种安卓支持的Linux命令，比如ps、netstat、netstat -an|grep 4724、pwd、ls、cd、rm等。 执行quit退出shell ","date":"2020-05-24","objectID":"/2020-05-24-appium03/:0:11","tags":["python","爬虫"],"title":"Appium自动化操作03(界面操作和adb命令)","uri":"/2020-05-24-appium03/"},{"categories":["python","爬虫"],"content":"前言 最好有Selenium的Web自动化的实际经验 本篇用到的相关软件链接： 链接: https://pan.baidu.com/s/126x-AgLKvM7qSJqdOzAAHA 提取码: h9b2 Appium 基础知识 Appium 用途和特点 Appium 是一个移动 App （手机应用）自动化工具。 手机APP自动化有什么用？ 自动化完成一些重复性的任务\r 比如 微信客服机器人\r爬虫\r自动化测试\r 爬虫就是通过手机自动化爬取信息。 为什么不通过网页、HTTP 爬取呢？ 有的系统没有网页，也不方便通过HTTP爬取\r 自动化测试 很多软件开发里面有这样的需求\r Appium 自动化方案的特点： 开源免费\r支持多个平台\riOS （苹果）、安卓 App 的自动化都支持。\r支持多种类型的自动化\r支持 苹果、安卓 应用 原生界面 的自动化\r支持 应用 内嵌 WebView 的自动化\r支持 手机浏览器 中的 web网站自动化\r支持 flutter 应用的自动化\r支持多种编程语言\r 像 Selenium 一样，Appium可以用多种编程语言调用它开发自动化程序。 自动化原理 Appium自动化的原理图: 它和Selenium原理图很像。因为Appium自动化架构借鉴了Selenium。 它包含了3个主体部分：自动化程序、Appium Server、移动设备 自动化程序 自动化程序是由我们来开发的，实现具体的手机自动化功能。 要发出具体的指令控制手机，也需要使用客户端库。 和Selenium一样，Appium 组织也提供了多种编程语言的客户端库，包括 java，python，js， ruby等，方便不同编程语言的开发者使用。 首先需要安装好客户端库，调用这些库，就可以发出自动化指令给手机。 Appium Server Appium Server 是 Appium 组织开发的程序，它负责管理手机自动化环境，并且转发自动化程序的控制指令给手机，并且转发手机给自动化程序的响应消息。 手机设备 这里说的手机设备，其实不仅仅是手机，包括所有苹果、安卓的移动设备，比如：手机、平板、智能手表等。 为了直观方便的讲解，这里我们简称：手机 当然手机上也包含了我们要自动化控制的手机应用APP。 手机设备为什么能接收并且处理自动化指令呢？ 因为，Appium Server 会在手机上安装一个自动化代理程序，代理程序会等待自动化指令，并且执行自动化指令 PS:这里使用手机端的自动化代理后你的键盘会无法弹出，只能接受电脑控制输入，手机键盘输入与电脑输入不能并存 比如：要模拟用户点击界面按钮，Appium自动化系统的流程是这样的： 自动化程序调用客户端库相应的函数，发送点击元素的指令（封装在HTTP消息里）给Appium Server Appium Server再转发这个指令给手机上的自动化代理 手机上的自动化代理接收到指令后，调用手机平台的自动化库，执行点击操作，返回点击成功的结果给 Appium Server Appium Server转发给自动化程序 自动化程序了解到本操作成功后，继续后面的自动化流程 其中，自动化代理控制，使用的什么库来实现自动化的呢？ 如果测试的是苹果手机， 用的是苹果的 XCUITest 框架 （IOS9.3版本以后） 如果测试的是安卓手机，用的是安卓的 UIAutomator 框架 (Android4.2以后) 这些自动化框架提供了在手机设备上运行的库，可以让程序调用这些库，像人一样自动化操控设备和APP，比如：点击、滑动，模拟各种按键消息等。 自动化环境搭建 这里以安卓APP的自动化为例。 环境搭建需要下载安装不少软件，而且还有不少是国外网站下载的。 这些软件安装包都放在前言的百度网盘链接中了，请自行下载。 1.安装client第三方库 首先需要在开发环境下下载appium-python-client库，也可以用pip安装，如下(pip默认下载最新库，要指定特殊版本，要在后面加上==特殊版本名) PS:这里的appium-python-client库有特殊版本要求，需要安装的是0.52版本，不是1.0版本以上，否则会报错，建议使用Pycharm环境 pip install appium-python-client==0.52 2.安装Appium Server Appium Server 是用 nodejs 运行的，基于js开发出来的。 Appium组织为了方便软件安装使用，制作了一个可执行程序 Appium Desktop，把nodejs 运行环境、Appium Server 和一些工具打包在里面了，只需要简单的下载安装就可以了。 可以从前言给出的百度网盘里下载安装： Appium-windows-1.15.1.exe Appium Desktop官方下载链接： https://github.com/appium/appium-desktop/releases/tag/v1.15.1 3.安装JDK 安卓APP的自动化，必须要安装安卓SDK(后面会提到)，而安卓SDK需要JDK环境。 可以从前言给出的百度网盘里下载安装： jdk-8u211-windows-x64.exe 安装好之后，还需要添加一个环境变量JAVA_HOME，指定值为jdk安装目录，比如 JAVA_HOME D:\\Javajdk 实际情况如下： 4.安装Android SDK 对于安卓APP的自动化，Appium Server是需要Android SDK的。 因为要用到里面的一些工具，比如要执行命令设置手机、传送文件、安装应用、查看手机界面等。 可以从前言给出的百度网盘里下载Android SDK文件包： androidsdk.zip，并且解压，即可。 解压完成后，需要配置一下添加一个环境变量 ANDROID_HOME，设置值为sdk包解压目录，比如 D:\\androidsdk添加步骤参照第三步的图 另外，还推荐大家配置环境变量PATH，加入adb所在目录， D:\\安卓dk\\androidsdk\\androidsdk\\platform-tools\\ 实际情况如下： 注意：是添加该目录到环境变量PATH中，不是替换!否则会导致系统命令都找不到的严重后果，双击2处使用新建添加！。 5.连接手机 上述的软件环境都准备好以后，要自动化手机APP，需要： 在你运行程序的电脑上用USB线连接上你的安卓手机 进入手机设置 -\u003e 关于手机，不断点击版本号菜单（大概7次以上）进入开发者模式 退出到上级菜单，在设置首页里点系统与更新，在系统与更新的开发者模式中，启动USB调试 如果手机连接USB线后，手机界面弹出是否选择允许USB调试，请选择是。 注意： 有的手机系统，可能需要一些额外的选项需要设置好。 比如，有的手机，开发者选项里需要打开允许通过USB安装应用等。 总之，给USB开发调试尽可能方便的控制手机。 连接好以后，打开命令行窗口，执行adb devices -l命令来列出连接在电脑上的安卓设备。 如果输出类似如下的内容： List of devices attached MGFNW19731015276 device product:HLK-AL00 model:HLK_AL00 device:HWHLK-H transport_id:1 表示电脑上可以查看到连接的设备，就可以运行自动化程序了。 第一个例子 运行代码前，首先得运行Appium Desktop from appium import webdriver from appium.webdriver.extensions.android.nativekey import AndroidKey desired_caps = { 'platformName': 'Android', # 被测手机是安卓 'platformVersion': '10', # 手机安卓版本，这个需要在设置里的关于手机里查找，注意是Android版本，不是MIUI等系统版本 'deviceName': 'HLK-AL00', # 设备名，安卓手机可以随意填写 'appPackage': 'tv.danmaku.bili', # 启动APP Package名称 'appActivity': '.ui.splash.SplashActivity', # 启动Activity名称 'unicodeKeyboard': True, # 使用自带输入法，输入中文时填True 'resetKeyboard': True, # 执行完程序恢复原来输入法 'noReset': True, # 不要重置App 'newCommandTimeout': 6000, #服务自动断开时间 'automationName' : 'UiAutomator2'#服务协议 } # 连接Appium Server，初始化自动化环境 driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) # 设置等待时间 driver.implicitly_wait(5) # 如果有`青少年保护`界面，点击`我知道了` iknow = driver.find_elements_by_id(\"text3\") if iknow: iknow.click() # 根据id定位搜索位置框，点击 driver.find_element_by_id(\"expand_search\").click() # 根据id定位搜索输入框，点击 sb","date":"2020-05-23","objectID":"/2020-05-23-appium01/:0:0","tags":["python","爬虫"],"title":"Appium自动化操作01(环境安装与初始结构)","uri":"/2020-05-23-appium01/"},{"categories":["python","数学建模"],"content":"前言 ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:0:0","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"本篇鸣谢 马川-燕大 的增删整理， 王圣元 ——原创文章，与原文不同之处包含我的学习记录。 匹配Jupyter Notebook的ipynb文档链接下载地址如下 源文档 接着上篇继续后面两个章节，数组变形和数组计算。 提纲： ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:0:1","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4 数组的变形 本节介绍四大类数组层面上的操作，具体有 重塑 (reshape) 和打平 (ravel, flatten) 合并 (concatenate, stack) 和分裂 (split) 重复 (repeat) 和拼接 (tile) 其他操作 (sort, insert, delete, copy) ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:1:0","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4.1 重塑和打平 重塑 (reshape) 和打平 (ravel, flatten) 这两个操作仅仅只改变数组的维度 重塑是从低维到高维 打平是从高维到低维 重塑 用reshape()函数将一维数组 arr 重塑成二维数组。 import numpy as np arr = np.arange(12) print( arr ) print( arr.reshape(4,3) ) [ 0 1 2 3 4 5 6 7 8 9 10 11] [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] 思考：为什么重塑后的数组不是 [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] 当你重塑高维矩阵时，不想花时间算某一维度的元素个数时，可以用「-1」取代，程序会自动帮你计算出来。比如把 12 个元素重塑成 (2, 6)，你可以写成 (2,-1) 或者 (-1, 6)。 print( arr.reshape((2,-1)) ) print( arr.reshape((-1,6)) ) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] 打平 用 ravel() 或flatten() 函数将二维数组 arr 打平成一维数组。 arr = np.arange(12).reshape((4,3)) print( arr ) ravel_arr = arr.ravel() print( ravel_arr ) flatten_arr = arr.flatten() print( flatten_arr ) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] [ 0 1 2 3 4 5 6 7 8 9 10 11] [ 0 1 2 3 4 5 6 7 8 9 10 11] 思考：为什么打平后的数组不是 [ 0 3 6 9 1 4 7 10 2 5 8 11] 要回答本节两个问题，需要了解 numpy 数组在内存块的存储方式。 行主序和列主序 行主序 (row-major order) 指每行的元素在内存块中彼此相邻，而列主序 (column-major order) 指每列的元素在内存块中彼此相邻。 在众多计算机语言中， 默认行主序的有 C 语言(下图 order=‘C’ 等价于行主序) 默认列主序的有 Fortran 语言(下图 order=‘F’ 等价于列主序) 在 numpy 数组中，默认的是行主序，即 order =‘C’。现在可以回答本节那两个问题了。 如果你真的想在「重塑」和「打平」时用列主序，只用把 order 设为 ‘F’，以重塑举例： print( np.arange(12).reshape((4,3), order='F') ) [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] 细心的读者可能已经发现为什么「打平」需要两个函数 ravel() 或 flatten()？它们的区别在哪里？ 知识点 函数 ravel() 或 flatten() 的不同之处是 1. ravel() 按「行主序」打平时没有复制原数组，按「列主序」在打平时复制了原数组 2. flatten() 在打平时复制了原数组 用代码验证一下，首先看 flatten()，将打平后的数组 flatten 第一个元素更新为 10000，并没有对原数组 arr 产生任何影响 (证明 flatten() 是复制了原数组) arr = np.arange(6).reshape(2,3) print( arr ) flatten = arr.flatten() print( flatten ) flatten_arr[0] = 10000 print( arr ) [[0 1 2] [3 4 5]] [0 1 2 3 4 5] [[0 1 2] [3 4 5]] 再看 ravel() 在「列主序」打平，将打平后的数组 ravel_F 第一个元素更新为 10000，并没有对原数组 arr 产生任何影响 (证明 ravel(order=‘F’) 是复制了原数组) ravel_F = arr.ravel( order='F' ) ravel_F[0] = 10000 print( ravel_F ) print( arr ) [10000 3 1 4 2 5] [[0 1 2] [3 4 5]] 最后看 ravel() 在「行主序」打平，将打平后的数组 ravel_C 第一个元素更新为 10000，原数组 arr[0][0] 也变成了 10000 (证明 ravel() 没有复制原数组) ravel_C = arr.ravel() ravel_C[0] = 10000 print( ravel_C ) print( arr ) [10000 1 2 3 4 5] [[10000 1 2] [ 3 4 5]] ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:1:1","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4.2 合并和分裂 合并 (concatenate, stack) 和分裂 (split) 这两个操作仅仅只改变数组的分合 合并是多合一 分裂是一分多 合并 使用「合并」函数有两种选择 有通用的 concatenate 有专门的 vstack, hstack, dstack 用下面两个数组来举例： arr1 = np.array([[1, 2, 3], [4, 5, 6]]) arr2 = np.array([[7, 8, 9], [10, 11, 12]]) concatenate np.concatenate([arr1, arr2], axis=0) array([[ 1, 2, 3], [ 4, 5, 6], [ 7, 8, 9], [10, 11, 12]]) np.concatenate([arr1, arr2], axis=1) array([[ 1, 2, 3, 7, 8, 9], [ 4, 5, 6, 10, 11, 12]]) 在 concatenate() 函数里通过设定轴，来对数组进行竖直方向合并 (轴 0) 和水平方向合并 (轴 1)。 vstack, hstack, dstack 通用的东西是好，但是可能效率不高，NumPy 里还有专门合并的函数 vstack：v 代表 vertical，竖直合并，等价于 concatenate(axis=0) hstack：h 代表 horizontal，水平合并，等价于 concatenate(axis=1) dstack：d 代表 depth-wise，按深度合并，深度有点像彩色照片的 RGB 通道 一图胜千言： 用代码验证一下： print( np.vstack((arr1, arr2)) ) print( np.hstack((arr1, arr2)) ) print( np.dstack((arr1, arr2)) ) [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] [[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] [[[ 1 7] [ 2 8] [ 3 9]] [[ 4 10] [ 5 11] [ 6 12]]] 和 vstack, hstack 不同，dstack 将原数组的维度增加了一维。 np.dstack((arr1, arr2)).shape (2, 3, 2) 分裂 使用「分裂」函数有两种选择 有通用的 split 有专门的 hsplit, vsplit 用下面数组来举例： arr = np.arange(25).reshape((5,5)) print( arr ) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] split 和 concatenate() 函数一样，我们可以在 split() 函数里通过设定轴，来对数组沿着竖直方向分裂 (轴 0) 和沿着水平方向分裂 (轴 1)。 first, second, third = np.split(arr,[1,3]) print( 'The first split is', first ) print( 'The second split is', second ) print( 'The third split is', third ) The first split is [[0 1 2 3 4]] The second split is [[ 5 6 7 8 9] [10 11 12 13 14]] The third split is [[15 16 17 18 19] [20 21 22 23 24]] split() 默认沿着轴 0 分裂，其第二个参数 [1, 3] 相当于是个切片操作，将数组分成三部分： 第一部分 - :1 (即第 1 行) 第二部分 - 1:3 (即第 2 到 3 行) 第二部分 - 3: (即第 4 到 5 行) hsplit, vsplit vsplit() 和 split(axis=0) 等价，hsplit() 和 split(axis=1) 等价。一图胜千言： 为了和上面不重复，我们只看 hsplit。 first, second, third = np.hsplit(arr,[1,3]) print( 'The first split is', first ) print( 'The second split is', second ) print( 'The third split is', third ) The first split is [[ 0] [ 5] [10] [15] [20]] The second split is [[ 1 2] [ 6 7] [11 12] [16 17] [21 22]] The third split is [[ 3 4] [ 8 9] [13 14] [18 19] [23 24]] ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:1:2","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4.3 重复和拼接 重复 (repeat) 和拼接 (tile) 这两个操作本质都是复制 重复是在元素层面复制 拼接是在数组层面复制 重复 函数 repeat() 复制的是数组的每一个元素，参数有几种设定方法： 一维数组：用标量和列表来复制元素的个数 多维数组：用标量和列表来复制元素的个数，用轴来控制复制的行和列 标量 arr = np.arange(3) print( arr ) print( arr.repeat(3) ) [0 1 2] [0 0 0 1 1 1 2 2 2] 标量参数 3 - 数组 arr 中每个元素复制 3 遍。 列表 print( arr.repeat([2,3,4]) ) [0 0 1 1 1 2 2 2 2] 列表参数 [2,3,4] - 数组 arr 中每个元素分别复制 2, 3, 4 遍。 标量和轴 arr2d = np.arange(6).reshape((2,3)) print( arr2d ) print( arr2d.repeat(2, axis=0) ) [[0 1 2] [3 4 5]] [[0 1 2] [0 1 2] [3 4 5] [3 4 5]] 标量参数 2 和轴 0 - 数组 arr2d 中每个元素沿着轴 0 复制 2 遍。 列表和轴 print( arr2d.repeat([2,3,4], axis=1) ) [[0 0 1 1 1 2 2 2 2] [3 3 4 4 4 5 5 5 5]] 列表参数 [2,3,4] 和轴 1 - 数组 arr2d 中每个元素沿着轴 1 分别复制 2, 3, 4 遍。 拼接 函数 tile() 复制的是数组本身，参数有几种设定方法： 标量：把数组当成一个元素，一列一列复制 形状：把数组当成一个元素，按形状复制 标量 arr2d = np.arange(6).reshape((2,3)) print( arr2d ) print( np.tile(arr2d,2) ) [[0 1 2] [3 4 5]] [[0 1 2 0 1 2] [3 4 5 3 4 5]] 标量参数 2 - 数组 arr 按列复制 2 遍。 形状 tile 是瓷砖的意思，顾名思义，这个函数就是把数组像瓷砖一样铺展开来。 arr2d2 = np.array([[1,2], [3, 4]]) print( arr2d2 ) [[1 2] [3 4]] 横向 np.tile(arr2d2, (1,4)) # 与 np.tile(arr2d2, 4) 等价 array([[1, 2, 1, 2, 1, 2, 1, 2], [3, 4, 3, 4, 3, 4, 3, 4]]) 纵向 np.tile(arr2d2, (3,1)) array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]]) 横向+纵向 print( np.tile(arr2d2, (3,4)) ) [[1 2 1 2 1 2 1 2] [3 4 3 4 3 4 3 4] [1 2 1 2 1 2 1 2] [3 4 3 4 3 4 3 4] [1 2 1 2 1 2 1 2] [3 4 3 4 3 4 3 4]] 形状参数 (3,4) - 数组 arr 按形状复制 12 (3×4) 遍，并以 (3,4) 的形式展现。 ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:1:3","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"4.4 其他操作 本节讨论数组的其他操作，包括排序 (sort)，插入 (insert)，删除 (delete) 和复制 (copy)。 排序 排序包括直接排序 (direct sort) 和间接排序 (indirect sort)。 直接排序 arr = np.array([5,3,2,6,1,4]) print( 'Before sorting', arr ) arr.sort() print( 'After sorting', arr ) Before sorting [5 3 2 6 1 4] After sorting [1 2 3 4 5 6] sort()函数是按升序 (ascending order) 排列的，该函数里没有参数可以控制 order，因此你想要按降序排列的数组，只需 print( arr[::-1] ) [6 5 4 3 2 1] 现在让人困惑的地方来了。 知识点 用来排序 numpy 用两种方式： arr.sort()#原址排序 np.sort( arr )#副本排序 第一种 sort 会改变 arr，第二种 sort 在排序时创建了 arr 的一个复制品，不会改变 arr。看下面代码，用一个形状是 (3, 4) 的「二维随机整数」数组来举例，用整数是为了便于读者好观察排序前后的变化： arr = np.random.randint( 40, size=(3,4) ) print( arr ) [[10 3 38 38] [27 32 14 11] [11 5 11 0]] 第一种 arr.sort()，对第一列排序，发现 arr 的元素改变了。 arr[:, 0].sort() print( arr ) [[10 3 38 38] [11 32 14 11] [27 5 11 0]] 第二种 np.sort(arr)，对第二列排序，但是 arr 的元素不变。 np.sort(arr[:,1]) array([ 3, 5, 32]) print( arr ) [[10 3 38 38] [11 32 14 11] [27 5 11 0]] 此外也可以在不同的轴上排序，对于二维数组，在「轴 0」上排序是「跨行」排序，在「轴 1」上排序是「跨列」排序。 arr.sort(axis=1) print( arr ) [[ 3 10 38 38] [11 11 14 32] [ 0 5 11 27]] 间接排序 有时候我们不仅仅只想排序数组，还想在排序过程中提取每个元素在原数组对应的索引(index)，这时 argsort() 就派上用场了。以排列下面五个学生的数学分数为例： score = np.array([100, 60, 99, 80, 91]) idx = score.argsort()#得到排序索引 print( idx ) [1 3 4 2 0] 这个 idx = [1 3 4 2 0] 怎么理解呢？很简单，排序完之后分数应该是 [60 80 91 99 100]， 60，即 score[1] 排在第0位， 因此 idx[0] =1 80，即 score[3] 排在第1 位， 因此 idx[1] =3 91，即 score[4] 排在第2 位， 因此 idx[2] =4 99，即 score[2] 排在第3 位， 因此 idx[3] =2 100，即 score[0] 排在第4 位， 因此 idx[4] =0 用这个 idx 对 score 做一个「花式索引」得到 (还记得上贴的内容吗？) print( score[idx] ) [ 60 80 91 99 100] 再看一个二维数组的例子。 arr = np.random.randint( 40, size=(3,4) ) print( arr ) [[38 14 23 19] [15 8 38 37] [ 4 0 21 23]] 对其第一行 arr[0] 排序，获取索引，在应用到所用行上。 arr[:, arr[0].argsort()] array([[14, 19, 23, 38], [ 8, 37, 38, 15], [ 0, 23, 21, 4]]) 这不就是「花式索引」吗？来我们分解一下以上代码，先看看索引。传入[索引] print( arr[0].argsort() ) [1 3 2 0] 「花式索引」来了，结果和上面一样的。 arr[:, [2, 0, 3, 1]] array([[23, 38, 19, 14], [38, 15, 37, 8], [21, 4, 23, 0]]) 插入和删除 和列表一样，我们可以给 numpy 数组 用insert()函数在某个特定位置之前插入元素 用delete()函数删除某些特定元素 a = np.arange(6) print( a ) print( np.insert(a, 1, 100) ) print( np.delete(a, [1,3]) ) [0 1 2 3 4 5] [ 0 100 1 2 3 4 5] [0 2 4 5] 复制 用copy()函数来复制数组 a 得到 a_copy，很明显，改变 a_copy 里面的元素不会改变 a。 a = np.arange(6) a_copy = a.copy() print( 'Before changing value, a is', a ) print( 'Before changing value, a_copy is', a_copy ) a_copy[-1] = 99 print( 'After changing value, a_copy is', a_copy ) print( 'After changing value, a is', a ) Before changing value, a is [0 1 2 3 4 5] Before changing value, a_copy is [0 1 2 3 4 5] After changing value, a_copy is [ 0 1 2 3 4 99] After changing value, a is [0 1 2 3 4 5] ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:1:4","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"5数组的计算 本节介绍两大类数组计算，具体有 元素层面 (element-wise) 计算 广播机制 (broadcasting) 计算 ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:2:0","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"5.1 元素层面计算 Numpy 数组元素层面计算包括： 二元运算 (binary operation)：加减乘除 数学函数：倒数、平方、指数、对数 比较运算 (comparison) 先定义两个数组 arr1 和 arr2。 arr1 = np.array([[1., 2., 3.], [4., 5., 6.]]) arr2 = np.ones((2,3)) * 2 print( arr1 ) print( arr2 ) [[1. 2. 3.] [4. 5. 6.]] [[2. 2. 2.] [2. 2. 2.]] 加、减、乘、除 print( arr1 + arr2 + 1 ) print( arr1 - arr2 ) print( arr1 * arr2 ) print( arr1 / arr2 ) [[4. 5. 6.] [7. 8. 9.]] [[-1. 0. 1.] [ 2. 3. 4.]] [[ 2. 4. 6.] [ 8. 10. 12.]] [[0.5 1. 1.5] [2. 2.5 3. ]] 倒数、平方、指数、对数 print( 1 / arr1 ) print( arr1 ** 2 ) print( np.exp(arr1) ) print( np.log(arr1) ) [[1. 0.5 0.33333333] [0.25 0.2 0.16666667]] [[ 1. 4. 9.] [16. 25. 36.]] [[ 2.71828183 7.3890561 20.08553692] [ 54.59815003 148.4131591 403.42879349]] [[0. 0.69314718 1.09861229] [1.38629436 1.60943791 1.79175947]] 比较 arr1 \u003e arr2 arr1 \u003e 3 array([[False, False, False], [ True, True, True]]) 从上面结果可知 「数组和数组间的二元运算」都是在元素层面上进行的 「作用在数组上的数学函数」都是作用在数组的元素层面上的。 「数组和数组间的比较」都是在元素层面上进行的 但是在「数组和标量间的比较」时，python 好像先把 3 复制了和 arr1 形状一样的数组 [[3,3,3], [3,3,3]]，然后再在元素层面上作比较。上述这个复制标量的操作叫做「广播机制」，是 NumPy 里最重要的一个特点，在下一节会详细讲到。 ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:2:1","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"5.2 广播机制计算 广播的引出 当两个数组的形状并不相同的时候，我们可以通过扩展数组的方法来实现相加、相减、相乘等操作，这种机制叫做广播（broadcasting）。 比如，一个二维数组减去列平均值，来对数组的每一列进行距平化处理： arr = np.random.randn(4,3) #shape(4,3) arr_mean = arr.mean(0) #shape(3,) demeaned = arr -arr_mean print(arr) print(arr_mean) print(demeaned) [[ 0.48226402 1.20876697 -0.67351982] [ 0.65606798 -1.16182488 -1.68726346] [-0.92629614 0.49865982 -0.07100581] [ 0.73134776 -0.28327924 0.14857151]] [ 0.23584591 0.06558067 -0.5708044 ] [[ 0.24641812 1.1431863 -0.10271542] [ 0.42022208 -1.22740555 -1.11645907] [-1.16214204 0.43307915 0.49979858] [ 0.49550185 -0.34885991 0.71937591]] 很明显上式arr和arr_mean维度并不形同，但是它们可以进行相减操作，这就是通过广播机制来实现的。 广播的原则 如果两个数组的后缘维度（trailing dimension，即从末尾开始算起的维度）的轴长度相符，或其中的一方的长度为1，则认为它们是广播兼容的。广播会在缺失和（或）长度为1的维度上进行。 这句话乃是理解广播的核心。广播主要发生在两种情况，一种是两个数组的维数不相等，但是它们的后缘维度的轴长相符，另外一种是有一方的长度为1。 数组维度不同，后缘维度的轴长相符 我们来看一个例子： import numpy as np arr1 = np.array([[0, 0, 0],[1, 1, 1],[2, 2, 2], [3, 3, 3]]) #arr1.shape = (4,3) arr2 = np.array([1, 2, 3]) #arr2.shape = (3,) arr_sum = arr1 + arr2 print(arr_sum) [[1 2 3] [2 3 4] [3 4 5] [4 5 6]] 上例中arr1的shape为（4,3），arr2的shape为（3，）。可以说前者是二维的，而后者是一维的。但是它们的后缘维度相等，arr1的第二维长度为3，和arr2的维度相同。arr1和arr2的shape并不一样，但是它们可以执行相加操作，这就是通过广播完成的，在这个例子当中是将arr2沿着0轴进行扩展。 上面程序当中的广播如下图所示(一维数据在轴0上的广播): 同样的例子还有(三维数据在轴0上的广播)： 从上面的图可以看到，（3,4,2）和（4,2）的维度是不相同的，前者为3维，后者为2维。但是它们后缘维度的轴长相同，都为（4,2），所以可以沿着0轴进行广播。 同样，还有一些例子：（4,2,3）和（2,3）是兼容的，（4,2,3）还和（3）是兼容的，后者需要在两个轴上面进行扩展。 数组维度相同，其中有个轴为1 我们来看下面的例子： import numpy as np arr1 = np.array([[0, 0, 0],[1, 1, 1],[2, 2, 2], [3, 3, 3]]) #arr1.shape = (4,3) arr2 = np.array([[1],[2],[3],[4]]) #arr2.shape = (4, 1) arr_sum = arr1 + arr2 print(arr_sum) [[1 1 1] [3 3 3] [5 5 5] [7 7 7]] arr1的shape为（4,3），arr2的shape为（4,1），它们都是二维的，但是第二个数组在1轴上的长度为1，所以，可以在1轴上面进行广播，如下图所示(二维数组在轴1上的广播)： 在这种情况下，两个数组的维度要保证相等，其中有一个轴的长度为1，这样就会沿着长度为1的轴进行扩展。这样的例子还有：（4,6）和（1,6） 。（3,5,6）和（1,5,6）、（3,1,6）、（3,5,1），后面三个分别会沿着0轴，1轴，2轴进行广播。 人们经常需要通过算术运算过程将较低维度的数组在除0轴以外的其他轴向上广播。根据广播的原则，较小数组的“广播维”必须为1。 对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。下图说明了要在三维数组各维度上广播的形状需求(能在该三维数组上广播的二维数组的形状)。 ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:2:2","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","数学建模"],"content":"6 总结 NumPy 篇终于完结！即上贴讨论过的数组创建、数组存载和数组获取，本贴讨论了数组变形、数组计算。 数组变形有以下重要操作： 改变维度的重塑和打平 改变分合的合并和分裂 复制本质的重复和拼接 其他排序插入删除复制 数组计算有以下重要操作： 元素层面：四则运算、函数，比较 广播机制：太重要了，大量用于科学计算和机器学习中！ ","date":"2020-05-22","objectID":"/2020-05-22-numpy-%E4%B8%8B/:3:0","tags":["python","数学建模"],"title":"NumPy (下)","uri":"/2020-05-22-numpy-%E4%B8%8B/"},{"categories":["python","爬虫"],"content":"前言 需要下载Chrome或Firefox的driver，Chrome内核81.440与Firefox内核74.0下载链接如下： Firefox Chrome 其他版本请在搜索引擎查找，本篇使用该版本，注意，driver下载后需要配置对应内核的游览器，电脑本身需要有该内核的游览器。 ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:1:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"正文 ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:2:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"Xpath语法简介 可以发现CSS选择元素非常灵活、强大。 还有一种灵活、强大的选择元素的方式，就是使用Xpath表达式。 XPath (XML Path Language) 是由国际标准化组织W3C指定的，用来在XML和HTML文档中选择节点的语言。 目前主流浏览器 (chrome、firefox，edge，safari) 都支持XPath语法，xpath有 1 和 2 两个版本，目前浏览器支持的是 xpath 1的语法。 既然已经有了CSS，为什么还要学习Xpath呢？因为 有些场景用css选择web元素很麻烦，而xpath却比较方便。 另外Xpath还有其他领域会使用到，比如爬虫框架Scrapy，手机App框架Appium。 测试网址：http://cdn1.python3.vip/files/selenium/test1.html 按F12打开调试窗口，点击Elements标签。 要验证Xpath语法是否能成功选择元素，也可以像验证CSS语法那样，按组合键Ctrl + F就会出现搜索框 xpath语法中，整个HTML文档根节点用’/‘表示，如果我们想选择的是根节点下面的html节点，则可以在搜索框输入 /html 如果输入下面的表达式 /html/body/div 这个表达式表示选择html下面的body下面的div元素。 注意/有点像CSS中的\u003e,表示直接子节点关系。 ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"绝对路径选择 从根节点开始的，到某个节点，每层都依次写下来，每层之间用/分隔的表达式，就是某元素的绝对路径 上面的xpath表达式/html/body/div，就是一个绝对路径的xpath表达式，等价于css表达式html\u003ebody\u003ediv 自动化程序要使用Xpath来选择web元素，应该调用WebDriver对象的方法find_element_by_xpath或者find_elements_by_xpath，像这样： elements = driver.find_elements_by_xpath(\"/html/body/div\") ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"相对路径选择 有的时候，我们需要选择网页中某个元素，不管它在什么位置 。 比如，选择示例页面的所有标签名为div的元素，如果使用css表达式，直接写一个div就行了。 那xpath怎么实现同样的功能呢？xpath需要前面加//, 表示从当前节点往下寻找所有的后代元素,不管它在什么位置。 所以xpath表达式，应该这样写：//div ‘//’ 符号也可以继续加在后面,比如，要选择所有的div元素里面的所有的p元素 ，不管div在什么位置，也不管p元素在div下面的什么位置，则可以这样写//div//p 对应的自动化程序如下 elements = driver.find_elements_by_xpath(\"//div//p\") 如果使用CSS选择器，对应代码如下 elements = driver.find_elements_by_css_selector(\"div p\") 如果，要选择所有的div元素里面的直接子节点p，xpath就应该这样写了//div/p 如果使用CSS选择器，则为div \u003e p ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:2","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"通配符 如果要选择所有div节点的所有直接子节点，可以使用表达式//div/* *是一个通配符，对应任意节点名的元素，等价于CSS选择器div \u003e * 代码如下： elements = driver.find_elements_by_xpath(\"//div/*\") for element in elements: print(element.get_attribute('outerHTML')) ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:3","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"根据属性选择 Xpath 可以根据属性来选择元素。 根据属性来选择元素是通过这种格式来的[@属性名='属性值'] 注意： 属性名注意前面有个@ 属性值一定要用引号，可以是单引号，也可以是双引号 根据id属性选择 选择id为west的元素，可以这样//*[@id='west'] 根据class属性选择 选择所有select元素中class为single_choice的元素，可以这样//select[@class='single_choice'] 如果一个元素class有多个，比如 \u003cp id=\"beijing\" class='capital huge-city'\u003e 北京 \u003c/p\u003e 如果要选它，对应的xpath就应该是//p[@class=\"capital huge-city\"] 不能只写一个属性，像这样//p[@class=\"capital\"]则不行 根据其他属性 同样的道理，我们也可以利用其它的属性选择 比如选择具有multiple属性的所有页面元素，可以这样//*[@multiple] 属性值包含字符串 要选择style属性值包含color字符串的页面元素，可以这样//*[contains(@style,'color')] 要选择style属性值以color字符串开头的页面元素，可以这样//*[starts-with(@style,'color')] style属性值以某个字符串结尾的页面元素，大家可以推测是//*[ends-with(@style,'color')]，但是很遗憾，这是xpath 2.0 的语法，目前浏览器都不支持。 按次序选择 前面学过css表达式可以根据元素在父节点中的次序选择，非常实用。 xpath也可以根据次序选择元素。语法比css更简洁，直接在方括号中使用数字表示次序 比如 某类型第几个子元素 比如 要选择p类型第2个的子元素，就是 //p[2] 注意，选择的是p类型第2个的子元素，不是第2个子元素，并且是p类型 。 再比如，要选取父元素为div中的p类型第2个子元素 //div/p[2] ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:4","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"第几个子元素 也可以选择第2个子元素，不管是什么类型，采用通配符 比如 选择父元素为div的第2个子元素，不管是什么类型 //div/*[2] ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:5","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"某类型倒数第几个子元素 当然也可以选取倒数第几个子元素 比如： 选取p类型倒数第1个子元素 —\u003e //p[last()] 选取p类型倒数第2个子元素 —\u003e //p[last()-1] 选择父元素为div中p类型倒数第3个子元素 —\u003e//div/p[last()-2] ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:6","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"范围选择 xpath还可以选择子元素的次序范围。 比如， 选取option类型第1到2个子元素 //option[position()\u003c=2] 或者 //option[position()\u003c3] 选择class属性为multi_choice的前3个子元素 //*[@class='multi_choice']/*[position()\u003c=3] 选择class属性为multi_choice的后3个子元素 //*[@class='multi_choice']/*[position()\u003e=last()-2] 为什么不是 last()-3 呢？因为 last()本身代表最后一个元素 last()-1本身代表倒数第2个元素 last()-2本身代表倒数第3个元素 ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:7","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"组选择、父节点、兄弟节点 组选择 css有组选择，可以同时使用多个表达式，多个表达式选择的结果都是要选择的元素 css组选择，表达式之间用逗号隔开 xpath也有组选择，是用竖线隔开多个表达式 比如，要选所有的option元素和所有的h4元素，可以使用 #xpath //option | //h4 等同于CSS选择器 #css option , h4 再比如，要选所有的class为single_choice和class为multi_choice的元素，可以使用 #xpath //*[@class='single_choice'] | //*[@class='multi_choice'] 等同于CSS选择器 #css .single_choice , .multi_choice ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:8","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"选择父节点 xpath可以选择父节点，这是css做不到的。 某个元素的父节点用/..表示 比如，要选择id为china的节点的父节点，可以这样写//*[@id='china']/.. 。 当某个元素没有特征可以直接选择，但是它有子节点有特征， 就可以采用这种方法，先选择子节点，再指定父节点。 还可以继续找上层父节点，比如//*[@id='china']/../../.. ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:9","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"兄弟节点选择 前面学过css选择器，要选择某个节点的后续兄弟节点，用波浪线 xpath也可以选择后续兄弟节点，用这样的语法following-sibling:: 比如，要选择class为single_choice的元素的所有后续兄弟节点//*[@class='single_choice']/following-sibling::* 等同于CSS选择器.single_choice ~ * 如果，要选择后续节点中的div节点，就应该这样写//*[@class='single_choice']/following-sibling::div xpath还可以选择前面的兄弟节点，用这样的语法preceding-sibling:: 比如，要选择class为single_choice的元素的所有前面的兄弟节点//*[@class='single_choice']/preceding-sibling::* 而CSS选择器目前还没有方法选择前面的兄弟节点 要了解更多Xpath选择语法，可以点击这里，打开Xpath选择器参考手册 ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:10","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"selenium 注意点 原代码： 先选择示例网页中，id是china的元素\r然后通过这个元素的WebElement对象，使用find_elements_by_xpath，选择里面的p元素，\r # 先寻找id是china的元素 china = wd.find_element_by_id('china') # 再选择该元素内部的p元素 elements = china.find_elements_by_xpath('//p') # 打印结果 for element in elements: print('----------------') print(element.get_attribute('outerHTML')) 运行发现，打印的不仅仅是china内部的p元素，而是所有的p元素。 要在某个元素内部使用xpath选择元素，需要在xpath表达式最前面加个点。 像这样 elements = china.find_elements_by_xpath('.//p') ","date":"2020-05-17","objectID":"/2020-05-17-selenium03/:3:11","tags":["python","爬虫"],"title":"Selenium的web自动化操作03(语法补充)","uri":"/2020-05-17-selenium03/"},{"categories":["python","爬虫"],"content":"前言 需要下载Chrome或Firefox的driver，Chrome内核81.440与Firefox内核74.0下载链接如下： Firefox Chrome 其他版本请在搜索引擎查找，本篇使用该版本，注意，driver下载后需要配置对应内核的游览器，电脑本身需要有该内核的游览器。 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:1:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"正文 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"radio框 radio框选择选项，直接用WebElement的click方法，模拟用户点击就可以了。 比如, 我们要在下面的html中： 先打印当前选中的 # 获取当前选中的元素 element = wd.find_element_by_css_selector( '#s_radio input[checked=checked]') print('当前选中的是: ' + element.get_attribute('value')) # 点选 wd.find_element_by_css_selector( '#s_radio input[value=\"小雷老师\"]').click() ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"checkbox框 对checkbox进行选择，也是直接用WebElement的click方法，模拟用户点击选择。 需要注意的是，要选中checkbox的一个选项，必须先获取当前该复选框的状态。 如果该选项已经勾选了，就不能再点击。 否则反而会取消选择。 先把已经选中的选项全部点击一下，确保都是未选状态再点击要选的 # 先把 已经选中的选项全部点击一下 elements = wd.find_elements_by_css_selector( '#s_checkbox input[checked=\"checked\"]') for element in elements: element.click() wd.find_element_by_css_selector( \"#s_checkbox input[value='要选']\").click() ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:2","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"select框 radio框及checkbox框都是input元素，只是里面的type不同而已。 select框 则是一个新的select标签，大家可以对照浏览器网页内容查看一下 对于Select 选择框， Selenium 专门提供了一个 Select类 进行操作。 Select类 提供了如下的方法 select_by_value 根据选项的 value属性值 ，选择元素。 比如，下面的HTML \u003coption value=\"xxl\"\u003ecool\u003c/option\u003e 就可以根据 xxl 这个值选择该选项 s.select_by_value('xxl') select_by_index 根据选项的 次序 （从0开始），选择元素 select_by_visible_text 根据选项的 可见文本 ，选择元素。 比如，下面的HTML： \u003coption value=\"xxl\"\u003ecool\u003c/option\u003e 就可以根据 cool 这个内容，选择该选项 s.select_by_visible_text('cool') deselect_by_value 根据选项的value属性值， 去除选中元素 deselect_by_index 根据选项的次序，去除选中元素 deselect_by_visible_text 根据选项的可见文本，去除选中元素 deselect_all 去除选中所有元素 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:3","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"Select单选框 对于 select单选框，操作比较简单： 不管原来选的是什么，直接用Select方法选择即可。 例如，选择要选的，示例代码如下 # 导入Select类 from selenium.webdriver.support.ui import Select # 创建Select对象（实例化） select = Select(wd.find_element_by_id(\"要选id\")) # 通过 Select 对象选中 要选选项 select.select_by_visible_text(\"要选选项\") ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:4","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"Select多选框 对于select多选框，要选中某几个选项，要注意去掉原来已经选中的选项。 例如，我们选择示例多选框中的 x1 和 x2 可以用select类的deselect_all方法，清除所有 已经选中 的选项。 然后再通过select_by_visible_text方法选择 x1 和 x2。 示例代码如下： # 导入Select类 from selenium.webdriver.support.ui import Select # 创建Select对象 select = Select(wd.find_element_by_id(\"x\")) # 清除所有 已经选中 的选项 select.deselect_all() # 选择 x1 和 x2 select.select_by_visible_text(\"x1\") select.select_by_visible_text(\"x2\") ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:5","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"ActionChains类 鼠标右键点击、双击、移动鼠标到某个元素、鼠标拖拽等。 这些操作，可以通过Selenium提供的ActionChains类来实现。 ActionChains类里面提供了 一些特殊的动作的模拟，我们可以通过ActionChains类的代码查看到，如下所示 我们以移动鼠标到某个元素为例。 百度首页的右上角，有个选项 网址：https://www.baidu.com/ 如果我们把鼠标放在上边，就会弹出下面的各种图标。 使用ActionChains来模拟鼠标移动 操作的代码如下： (百度网站首页可能有变化，选择的类可能需要更改) from selenium import webdriver driver = webdriver.Chrome(r'f:\\chromedriver.exe') driver.implicitly_wait(5) driver.get('https://www.baidu.com/') from selenium.webdriver.common.action_chains import ActionChains ac = ActionChains(driver) # 鼠标移动到 元素上 ac.move_to_element( driver.find_element_by_css_selector('[name=\"tj_briicon\"]') ).perform() 直接执行javascript 我们可以直接让浏览器运行一段javascript代码，并且得到返回值，如下 # 直接执行 javascript，里面可以直接用return返回我们需要的数据 nextPageButtonDisabled = driver.execute_script( ''' ele = document.querySelector('.soupager \u003e button:last-of-type'); return ele.getAttribute('disabled') ''') # 返回的数据转化为Python中的数据对象进行后续处理 if nextPageButtonDisabled == 'disabled': # 是最后一页 return True else: # 不是最后一页 return False ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:6","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"冻结界面 有些网站上面的元素，我们鼠标放在上面，会动态弹出一些内容。 比如，百度首页的右上角，有个选项：https://www.baidu.com/ 如果我们把鼠标放在上边，就会弹出很多图标。 如果我们要用selenium自动化点击其中图标，就需要F12查看这个元素的特征。 但是当我们的鼠标从图标移开，这个栏目就整个消失了，就没法查看其对应的HTML。 怎么办？ 在开发者工具栏console里面执行如下js代码 setTimeout(function(){debugger}, 5000) 这句JavaScript代码什么意思呢？ 表示在 5000毫秒后，执行debugger命令 执行该命令会 浏览器会进入debug状态。debug状态有个特性，界面被冻住，不管我们怎么点击界面都不会触发事件。 所以，我们可以在输入上面代码并回车 执行后，立即鼠标放在界面右上角图标处。 这时候，就会弹出下面的各种图标。 然后，我们仔细等待5秒到了以后，界面就会因为执行了debugger命令而被冻住。 然后，我们就可以点击开发者工具栏的查看箭头，再去点击其中图标，查看其属性了。 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:7","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"弹出对话框 有的时候，我们经常会在操作界面的时候，出现一些弹出的对话框。 弹出的对话框有三种类型，分别是 Alert（警告信息）、confirm（确认信息）和prompt（提示输入） ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:8","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"Alert Alert 弹出框，目的就是显示通知信息，只需用户看完信息后，点击 OK（确定） 就可以了。 那么，自动化的时候，代码怎么模拟用户点击 OK 按钮呢？ selenium提供如下方法进行操作 driver.switch_to.alert.accept() 注意：如果我们不去点击它，页面的其它元素是不能操作的。 如果程序要获取弹出对话框中的信息内容，可以通过如下代码 driver.switch_to.alert.text 示例代码如下 from selenium import webdriver driver = webdriver.Chrome() driver.implicitly_wait(5) driver.get('http://cdn1.python3.vip/files/selenium/test4.html') # --- alert --- driver.find_element_by_id('b1').click() # 打印 弹出框 提示信息 print(driver.switch_to.alert.text) # 点击 OK 按钮 driver.switch_to.alert.accept() ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:2:9","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"Confirm Confirm弹出框，主要是让用户确认是否要进行某个操作。 比如：当管理员在网站上选择删除某个账号时，就可能会弹出Confirm弹出框，要求确认是否确定要删除。 Confirm弹出框 有两个选择供用户选择，分别是OK和Cancel，分别代表确定和取消操作。 那么，自动化的时候，代码怎么模拟用户点击OK或者Cancel按钮呢？ selenium提供如下方法进行操作 如果我们想点击OK按钮，还是用刚才的accept方法，如下 driver.switch_to.alert.accept() 如果我们想点击 Cancel 按钮， 可以用 dismiss方法，如下 driver.switch_to.alert.dismiss() 示例代码如下 from selenium import webdriver driver = webdriver.Chrome() driver.implicitly_wait(5) driver.get('http://cdn1.python3.vip/files/selenium/test4.html') # --- confirm --- driver.find_element_by_id('b2').click() # 打印 弹出框 提示信息 print(driver.switch_to.alert.text) # 点击 OK 按钮 driver.switch_to.alert.accept() driver.find_element_by_id('b2').click() # 点击 取消 按钮 driver.switch_to.alert.dismiss() ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:3:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"Prompt 出现 Prompt 弹出框 是需要用户输入一些信息，提交上去。 比如：当管理员在网站上选择给某个账号延期时，就可能会弹出 Prompt 弹出框， 要求输入延期多长时间。 可以调用如下方法 driver.switch_to.alert.send_keys() 示例代码如下 from selenium import webdriver driver = webdriver.Chrome() driver.implicitly_wait(5) driver.get('http://cdn1.python3.vip/files/selenium/test4.html') # --- prompt --- driver.find_element_by_id('b3').click() # 获取 alert 对象 alert = driver.switch_to.alert # 打印 弹出框 提示信息 print(alert.text) # 输入信息，并且点击 OK 按钮 提交 alert.send_keys('web自动化 - selenium') alert.accept() # 点击 Cancel 按钮 取消 driver.find_element_by_id('b3').click() alert = driver.switch_to.alert alert.dismiss() 注意： 有些弹窗并非浏览器的alert 窗口，而是html元素，这种对话框，只需要通过之前介绍的选择器选中并进行相应的操作就可以了。 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:3:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"其他技巧 下面是一些其他的 Selenium 自动化技巧 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"窗口大小 有时间我们需要获取窗口的属性和相应的信息，并对窗口进行控制 获取窗口大小 driver.get_window_size() 改变窗口大小 driver.set_window_size(x, y) ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"获取当前窗口标题 浏览网页的时候，我们的窗口标题是不断变化的，可以使用WebDriver的title属性来获取当前窗口的标题栏字符串。 driver.title 获取当前窗口URL地址 driver.current_url 例如，访问网易，并获取当前窗口的标题和URL from selenium import webdriver driver = webdriver.Chrome() driver.implicitly_wait(5) # 打开网站 driver.get('https://www.163.com') # 获取网站标题栏文本 print(driver.title) # 获取网站地址栏文本 print(driver.current_url) ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:2","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"截屏 有的时候，我们需要把浏览器屏幕内容保存为图片文件。 比如，做自动化测试时，一个测试用例检查点发现错误，我们可以截屏为文件，以便测试结束时进行人工核查。 可以使用WebDriver的get_screenshot_as_file方法来截屏并保存为图片。 from selenium import webdriver driver = webdriver.Chrome() driver.implicitly_wait(5) # 打开网站 driver.get('https://www.baidu.com/') # 截屏保存为图片文件 driver.get_screenshot_as_file('1.png') ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:3","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"手机模式 我们可以通过 desired_capabilities 参数，指定以手机模式打开chrome浏览器 参考代码，如下 from selenium import webdriver mobile_emulation = { \"deviceName\": \"Nexus 5\" } chrome_options = webdriver.ChromeOptions() chrome_options.add_experimental_option(\"mobileEmulation\", mobile_emulation) driver = webdriver.Chrome( desired_capabilities = chrome_options.to_capabilities()) driver.get('http://www.baidu.com') input() driver.quit() ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:4","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"上传文件 有时候，网站操作需要上传文件。 比如，著名的在线图片压缩网站： https://tinypng.com/ 通常，网站页面上传文件的功能，是通过 type 属性 为 file 的 HTML input 元素实现的。 如下所示： \u003cinput type=\"file\" multiple=\"multiple\"\u003e 使用selenium自动化上传文件，我们只需要定位到该input元素，然后通过 send_keys 方法传入要上传的文件路径即可。 如下所示： # 先定位到上传文件的 input 元素 ele = wd.find_element_by_css_selector('input[type=file]') # 再调用 WebElement 对象的 send_keys 方法 ele.send_keys(r'h:\\g02.png') 如果需要上传多个文件，可以多次调用send_keys，如下 ele = wd.find_element_by_css_selector('input[type=file]') ele.send_keys(r'h:\\g01.png') ele.send_keys(r'h:\\g02.png') ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:5","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"自动化Edge浏览器 自动化基于Chromium内核的微软最新Edge浏览器，首先需要查看Edge的版本。 点击菜单 帮助和反馈 \u003e 关于Microsoft Edge ，在弹出界面中，查看到版本，比如 Microsoft Edge 是最新版本。 版本 81.0.416.72 (官方内部版本) (64 位) 然后点击这里，打开Edge浏览器驱动下载网页 ，并选择下载对应版本的驱动。 在自动化代码中，指定使用Edge Webdriver类，并且指定Edge驱动路径，如下所示 from selenium import webdriver driver = webdriver.Edge(r'd:\\tools\\webdrivers\\msedgedriver.exe') driver.get('http://www.51job.com') ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:6","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"自动化Electron程序 Electron程序都是基于基于Chromium技术开发的，所以基本也可以用Chromedriver驱动自动化。 要自动化，首先需要得到内置Chromium的版本号。 向开发人员查询打开 Dev Tools 窗口的快捷键（通常是ctrl + Shift + I），打开Dev Tools 窗口后， 在 Console tab中输入 如下语句，查看版本 navigator.appVersion.match(/.*Chrome/([0-9.]+)/)[1] “79.0.3945.130” 然后去 chromedriver下载网址 ，下载对应版本的驱动。 在自动化程序中需要指定打开的可执行程序为Electron程序，而不是 Chrome浏览器。 如下所示 from selenium import webdriver from selenium.webdriver.chrome.options import Options ops = Options() # 指定Electron程序路径 ops.binary_location = r\"C:\\electronAPP.exe\" driver = webdriver.Chrome(r\"e:\\chromedriver.exe\", options = ops) ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:4:7","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"黑科技 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:5:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"使用代理 selenium 自动化谷歌浏览器可以这样使用代理 from selenium import webdriver from selenium.webdriver.common.proxy import Proxy, ProxyType prox = Proxy() prox.proxy_type = ProxyType.MANUAL prox.http_proxy = \"127.0.0.1:10800\" prox.ssl_proxy = \"127.0.0.1:10800\" # prox.socks_proxy = \"127.0.0.1:10800\" capabilities = webdriver.DesiredCapabilities.CHROME prox.add_to_capabilities(capabilities) driver = webdriver.Chrome(desired_capabilities=capabilities) driver.get('https://youtube.com') input() ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:5:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"使用缺省用户的profile运行浏览器 前面我们selenium打开浏览器，都是创建一个临时的新的用户，在新的用户环境中运行自动化。 如果我们想使用现有缺省用户的 profile运行浏览器自动化，可以这样 from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() # 缺省使用的是该目录下面的 Default目录里面保存的用户profile options.add_argument(r'user-data-dir=c:\\Users\\baiyh\\AppData\\Local\\Google\\Chrome\\User Data') driver = webdriver.Chrome(options=options) ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:5:2","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"自动化手工打开的Chrome浏览器 Selenium自动化打开的浏览器，每次都是使用全新的profile，有的网站用Selenium自动化，会有奇怪的问题（可能是profile的原因），比如不能登录，打开首页是空白等等。 这时，我们可以 1.关闭所有的Chrome浏览器 2.找到chrome的安装目录，打开命令行窗口，cd进入该目录， 3.输入如下命令，手动启动Chrome浏览器，指定debug端口。 chrome.exe --remote-debugging-port=9222 因为没有 –user-data-dir 参数，使用的是缺省用户profile。就是我们手动直接启动Chrome使用的profile。 这一步，也可以不这么麻烦，参考这篇文章，修改chrome桌面快捷图标启动参数，修改后双击打开Chrome 然后 手动操作浏览器网页，比如登录，进入到可以自动化的状态， 然后，自动化程序中这样写 from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() # 指定Chrome的debug地址 和前面命令行中启动参数一致 # 这样，就会直接自动化刚才启动的浏览器 options.add_experimental_option(\"debuggerAddress\", \"127.0.0.1:9222\") wd = webdriver.Chrome(options=options) wd.implicitly_wait(10) # 下面接着写自动化的代码 ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:5:3","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","爬虫"],"content":"无头模式 from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() # 设置为无头模式参数 options.add_argument(\"--headless\") driver = webdriver.Chrome(options=options) driver.implicitly_wait(10) driver.get('http://www.ahtba.org.cn/Category/Detail?id=568') eles = driver.find_elements_by_css_selector('#night_7460 li a') for ele in eles: print(ele.text) ","date":"2020-05-16","objectID":"/2020-05-16-selenium02/:5:4","tags":["python","爬虫"],"title":"Selenium的web自动化操作02(基本语法)","uri":"/2020-05-16-selenium02/"},{"categories":["python","数学建模"],"content":"前言 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:0:0","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"本篇鸣谢 马川——燕大 增删整理，王圣元——原创文章，与原文不同之处包含我的学习记录。 匹配Jupyter Notebook的ipynb文档链接下载地址如下 源文档 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:0:1","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"0 引言 Numpy 是 Python 专门处理高维数组 (high dimensional array) 的计算的包，每次使用它遇到问题都会它的官网 (www.numpy.org). 去找答案。 在使用 numpy 之前，需要引进它，语法如下： import numpy 这样你就可以用 numpy 里面所有的内置方法 (build-in methods) 了，比如求和与均值。 numpy.sum() numpy.mean() 但是每次写 numpy 字数有点多，通常我们给 numpy 起个别名 np，用以下语法，这样所有出现 numpy 的地方都可以用 np 替代。 import numpy as np 为什么要专门学习数组呢？看下面「numpy 数组」和「列表」之间的计算效率对比：两个大小都是 1000000，把每个元素翻倍，运行 10 次用 %time 记时。 my_arr = np.arange(1000000) my_list = list(range(1000000)) %time for _ in range(10): my_arr2 = my_arr * 2 Wall time: 34.3 ms %time for _ in range(10): my_list2 = [x * 2 for x in my_list] Wall time: 1.8 s 「numpy 数组」效率是「列表」效率的10到100倍（甚至更快），并且使用的内存更少。如果元素全是数值型变量 (numerical variable)，那么 numpy 数组明显是个很好的数据结构。 学习 numpy 还是遵循的 Python 里「万物皆对象」的原则，既然把数组当对象，我们就按着数组的创建、数组的存载、数组的获取、数组的变形、和数组的计算来盘一盘 NumPy，目录如下： 由于篇幅原因，NumPy 系列分两贴，上贴讲前三节的内容，下帖讲后两节的内容。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:1:0","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"1 数组的创建 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:0","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"1.1 初次印象 数组 (array) 是相同类型的元素 (element) 的集合所组成数据结构 (data structure)。numpy 数组中的元素用的最多是「数值型」元素，平时我们说的一维、二维、三维数组长下面这个样子 (对应着线、面、体)。四维数组很难被可视化。 注意一个关键字 axis，中文叫「轴」，一个数组是多少维度就有多少根轴。由于 Python 计数都是从 0 开始的，那么 第 1 维度 = axis 0 第 2 维度 = axis 1 第 3 维度 = axis 2 但这些数组只可能在平面上打印出来，那么它们 (高于二维的数组) 的表现形式稍微有些不同。 分析上图各个数组的在不同维度上的元素： 一维数组：轴 0 有 3 个元素 二维数组：轴 0 有 2 个元素，轴 1 有 3 个元素 三维数组：轴 0有 2 个元素 (2 块)，轴 1 有 2 个元素，轴 2 有 3 个元素 四维数组：轴 0 有 2 个元素 (2 块)，轴 1 有 2 个元素 (2 块)，轴 2 有 2 个元素，轴 3 有 3 个元素 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:1","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"1.2 创建数组 带着上面这个对轴的认识，接下来我们用代码来创建 numpy 数组，有三种方式： 按步就班的 np.array() 用在列表和元组上 定隔定点的 np.arange() 和 np.linspace() 一步登天的 np.ones(), np.zeros(), np.eye() 和 np.random.random() ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:2","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"按步就班法 给了「列表」和「元组」原材料，用 np.array() 包装一下便得到 numpy 数组。 l = [3.5, 5, 2, 8, 4.2] np.array(l) array([3.5, 5. , 2. , 8. , 4.2]) t = (3.5, 5, 2, 8, 4.2) np.array(t) array([3.5, 5. , 2. , 8. , 4.2]) 注意，numpy 数组的输出都带有 array() 的字样，里面的元素用「中括号 []」框住。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:3","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"定隔定点法 更常见的两种创建 numpy 数组方法： 定隔的 arange：固定元素大小间隔 定点的 linspace：固定元素个数 先看 arange 例子： print( np.arange(8) ) print( np.arange(2,8) ) print( np.arange(2,8,2)) [0 1 2 3 4 5 6 7] [2 3 4 5 6 7] [2 4 6] 函数 arange 的参数为起点 , 终点 , 间隔 arange(start , stop , step) 其中 stop 必须要有，start 为 0和 step 没有的话默认为 1。对着这个规则看看上面各种情况的输出。 注：用函数 print 打印 numpy 数组就没有 array() 的字样了，只用其内容，而且元素之间的「逗号」也没有了。 再看 linspace 的例子：第三个参数输入，等分段落 print( np.linspace(2,6,3) ) print( np.linspace(3,8,11,endpoint) ) #linescape里面有一个参数endpoint=False,意思是最后一个数字不取到，默认取到最后一个数字。 [2. 4. 6.] [3. 3.5 4. 4.5 5. 5.5 6. 6.5 7. 7.5 8. ] 函数 linspace 的参数为起点 , 终点 , 点数 (左右区间都是闭合的) linspace (start , stop , num) 其中 start 和 stop 必须要有，num 没有的话默认为 50。对着这个规则看看上面各种情况的输出。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:4","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"一步登天法 NumPy 还提供一次性 用 zeros(n) 创建全是 0 的 n 维数组 用 ones(n) 创建全是 1 的 n 维数组 用 random(n,行数,列数) 创建随机 n 维数组 用 eye() 创建对角矩阵 (二维数组) 对于前三种，由于输出是 n 为数组，它们的参数是一个「标量」或「元组类型的形状」，下面三个例子一看就懂了： print( np.zeros(5) ) # 标量5代表形状(5,) print( np.ones((2,3)) ) print( np.random.random((2,3,4)) ) [0. 0. 0. 0. 0.] [[1. 1. 1.] [1. 1. 1.]] [[[0.14428606 0.18096881 0.62007296 0.6772929 ] [0.1455759 0.8892189 0.62079121 0.11571584] [0.35057464 0.15843398 0.95314951 0.00487452]] [[0.2036554 0.77356948 0.70228873 0.62647952] [0.97942093 0.16552439 0.37465336 0.11141434] [0.75365885 0.20963809 0.87369812 0.47554261]]] 对于函数 eye()，它的参数就是一个标量，控制矩阵的行数或列数： np.eye(4) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 此外还可以设定 eye() 里面的参数 k 默认设置 k = 0 代表 1 落在对角线上 k = 1 代表 1 落在对角线右上方 k = -1 代表 1 落在对角线左下方 np.eye(4, k=1) array([[0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.], [0., 0., 0., 0.]]) ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:5","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"1.3 数组性质 还记得 Python 里面「万物皆对象」么？numpy 数组也不例外，那么我们来看看数组有什么属性 (attributes) 和方法 (methods)。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:6","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"一维数组 用按步就班的 np.array() 带列表生成数组 arr arr = np.array([3.5, 5, 2, 8, 4.2]) arr array([3.5, 5. , 2. , 8. , 4.2]) 现在你应该会用 dir(arr) 来查看数组的属性了吧，看完之后我们对 type, ndim, len(), size, shape, stride, dtype 几个感兴趣，打印出来看看： print( 'The type is', type(arr) ) print( 'The dimension is', arr.ndim ) print( 'The length of array is', len(arr) ) print( 'The number of elements is', arr.size ) print( 'The shape of array is', arr.shape ) print( 'The stride of array is', arr.strides ) print( 'The type of elements is', arr.dtype ) The type is \u003cclass 'numpy.ndarray'\u003e The dimension is 1 The length of array is 5 The number of elements is 5 The shape of array is (5,) The stride of array is (8,) The type of elements is float64 根据结果我们来看看上面属性到底是啥： type：数组类型，当然是 numpy.ndarray ndim：维度个数是 1 len()：数组长度为 5 (注意这个说法只对一维数组有意义) size：数组元素个数为 5 shape：数组形状，即每个维度的元素个数 (用元组来表示)，只有一维，元素个数为 5，写成元组形式是 (5,) strides：跨度，即在某一维度下为了获取到下一个元素需要「跨过」的字节数 (用元组来表示)，float64 是 8 个字节数 (bytes)，因此跨度为 8 dtype：数组元素类型，是双精度浮点 (注意和 type 区分) 注意 strides，这个概念对于解决引言的「转置高维数组」问题很重要。一图胜千言。 咦，为什么有个 Python View 和 Memory Block 啊？这两个不是一样的么？对一维数组来说，「Python 视图」看它和「内存块」存储它的形式是一样的，但对二维数组甚至高维数组呢？ ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:7","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"二维数组 还是用按步就班的 np.array() 带二维列表生成二维数组 arr2d l2 = [[1, 2, 3], [4, 5, 6]] arr2d = np.array(l2) arr2d array([[1, 2, 3], [4, 5, 6]]) 打印属性出来看看： print( 'The type is', type(arr2d) ) print( 'The dimension is', arr2d.ndim ) print( 'The length of array is', len(arr2d) ) print( 'The number of elements is', arr2d.size ) print( 'The shape of array is', arr2d.shape ) print( 'The stride of array is', arr2d.strides ) print( 'The type of elements is', arr2d.dtype ) The type is \u003cclass 'numpy.ndarray'\u003e The dimension is 2 The length of array is 2 The number of elements is 6 The shape of array is (2, 3) The stride of array is (12, 4) The type of elements is int32 同样，我们来分析一下上面属性： $\\color{red}{type}$：数组类型 numpy.ndarray $\\color{red}{ndim}$：维度个数是 2 $\\color{red}{len()}$：数组长度为 2 (严格定义 len 是数组在「轴 0」的元素个数) $\\color{red}{size}$：数组元素个数为 6 $\\color{red}{shape}$：数组形状 (2, 3） $\\color{red}{strides}$：跨度 (12, 4) 看完下图再解释 $\\color{red}{dtype}$：数组元素类型 int32 对于二维数组，「Python 视图」看它和「内存块」存储它的形式是不一样的，如下图所示： 在 numpy 数组中，默认的是行主序 (row-major order)，意思就是每行的元素在内存块中彼此相邻，而列主序 (column-major order) 就是每列的元素在内存块中彼此相邻。 回顾跨度 (stride) 的定义，即在某一维度下为了获取到下一个元素需要「跨过」的字节数。注：每一个 int32 元素是 4 个字节数。对着上图： 第一维度(轴0)：沿着它获取下一个元素需要跨过 3 个元素，即 12 = 3×4 个字节 第二维度 (轴 1)：沿着它获取下一个元素需要跨过 1 个元素，即 4 = 1×4 个字节 因此该二维数组的跨度为 (12, 4)。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:8","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"n 维数组 用 np.random.random() 来生成一个多维数组： arr4d = np.random.random( (2,2,2,3) ) print(arr4d) [[[[0.3655641 0.14651352 0.05611382] [0.09145433 0.66341311 0.93410998]] [[0.32589061 0.21609648 0.65855021] [0.01984889 0.29624348 0.38033199]]] [[[0.57298013 0.5646688 0.80097287] [0.00362119 0.59812186 0.9974391 ]] [[0.726032 0.29853497 0.66405837] [0.83010788 0.95585422 0.13115111]]]] 里面具体元素是什么不重要，arr4d 的属性比较重要： print( 'The type is', type(arr4d) ) print( 'The dimension is', arr4d.ndim ) print( 'The length of array is', len(arr4d) ) print( 'The number of elements is', arr4d.size ) print( 'The shape of array is', arr4d.shape ) print( 'The stride of array is', arr4d.strides ) print( 'The type of elements is', arr4d.dtype ) The type is \u003cclass 'numpy.ndarray'\u003e The dimension is 4 The length of array is 2 The number of elements is 24 The shape of array is (2, 2, 2, 3) The stride of array is (96, 48, 24, 8) The type of elements is float64 除了 stride，都好理解，请根据下图好好想想为什么 stride 是 (96, 48, 24, 8)？[Hint: 一个 float64 的元素占 8 个字节] 算了还是分析一下吧 (免得掉粉 )。回顾跨度 (stride) 的定义，即在某一维度下为了获取到下一个元素需要「跨过」的字节数。注：每一个 float64 元素是 8 个字节数 第一维度 (轴 0)：沿着它获取下一个元素需要跨过 12 个元素，即 96 = 12×8 个字节 第二维度 (轴 1)：沿着它获取下一个元素需要跨过 6 个元素，即 48 = 6×8 个字节 第三维度 (轴 2)：沿着它获取下一个元素需要跨过 3 个元素，即 24 = 3×8 个字节 第四维度 (轴 3)：沿着它获取下一个元素需要跨过 1 个元素，即 8 = 1×8 个字节 因此该四维数组的跨度为 (96, 48, 24, 8)。 留一道思考题，strides 和 shape 有什么关系？ strides = (96, 48, 24, 8) shape = (2, 2, 2, 3) 总不能每个高维数组都用可视化的方法来算 strides 吧。 3*8 3*2*8 3*2*2*8 3*2*2*2*8 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:2:9","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"2 数组的存载 本节讲数组的「保存」和「加载」，我知道它们没什么技术含量，但是很重要。假设你已经训练完一个深度神经网络，该网络就是用无数参数来表示的。比如权重都是 numpy 数组，为了下次不用训练而重复使用，将其保存成 .npy 格式或者 .csv 格式是非常重要的。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:3:0","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"numpy 自身的 .npy 格式 用 np.save 函数将 numpy 数组保存为 .npy 格式，具体写法如下： np.save(\"文件名\"，数组 ) arr_disk = np.arange(8) np.save(\"arr_disk\", arr_disk) arr_disk array([0, 1, 2, 3, 4, 5, 6, 7]) arr_disk.npy 保存在 Jupyter Notebook 所在的根目录下。要加载它也很简单，用 np.load( “文件名” ) 即可： np.load(\"arr_disk.npy\") array([0, 1, 2, 3, 4, 5, 6, 7]) ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:3:1","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"文本 .txt 格式 用 np.savetxt 函数将 numpy 数组保存为 .txt 格式，具体写法如下： np.savetxt(“文件名”,数组 ) arr_text = np.array([[1., 2., 3.], [4., 5., 6.]]) np.savetxt(\"arr_from_text.txt\", arr_text) arr_from_text.txt 保存在 Jupyter Notebook 所在的根目录下，用 Notepad 打开看里面确实存储着 [[1,2,3], [4,5,6]]。 用 np.loadtxt( “文件名” ) 即可加载该文件 np.loadtxt(\"arr_from_text.txt\") array([[1., 2., 3.], [4., 5., 6.]]) ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:3:2","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"文本 .csv 格式 另外，假设我们已经在 arr_from_csv 的 csv 文件里写进去了 [[1,2,3], [4,5,6]]，每行的元素是由「分号 ;」来分隔的，展示如下： 用 np.genfromtxt( “文件名” ) 即可加载该文件 np.genfromtxt(\"arr_from_csv.csv\") array([nan, nan]) 奇怪的是数组里面都是 nan，原因是没有设定好「分隔符 ;」，那么函数 genfromtxt 读取的两个元素是 1;2;3 4;5;6 它们当然不是数字拉，Numpy 只能用两个 nan (Not a Number) 来代表上面的四不像了。 带上「分隔符 ;」再用 np.genfromtxt( “文件名”，分隔符 ) 即可加载该文件 np.genfromtxt(\"arr_from_csv.csv\", delimiter=\";\") array([[1., 2., 3.], [4., 5., 6.]]) ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:3:3","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3 数组的获取 获取数组是通过索引 (indexing) 和切片 (slicing) 来完成的， 切片是获取一段特定位置的元素 索引是获取一个特定位置的元素 索引和切片的方式和列表一模一样。对于一维数组 arr, 切片写法是 arr[start : stop : step] 索引写法是 arr[index] 因此，切片的操作是可以用索引操作来实现的 (一个一个总能凑成一段)，只是没必要罢了。为了简化，我们在本章三节标题里把切片和索引都叫做索引。 索引数组有三种形式，正规索引 (normal indexing)、布尔索引 (boolean indexing) 和花式索引 (fancy indexing)。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:4:0","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.1 正规索引 虽然切片操作可以由多次索引操作替代，但两者最大的区别在于 切片得到的是原数组的一个视图 (view) ，修改切片中的内容会改变原数组 索引得到的是原数组的一个复制 (copy)，修改索引中的内容不会改变原数组 请看下面一维数组的例子来说明上述两者的不同。 一维数组 arr = np.arange(10) arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 用 arr[6] 索引第 7 个元素 (记住 Python 是从 0 开始记录位置的) arr[6] 6 把它赋给变量 a，并重新给 a 赋值 1000，但是元数组 arr 第 7 个元素的值还是 6，并没有改成 1000。 a = arr[6] a = 1000 arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 用 arr[5:8] 切片第 6 到 8 元素 (记住 Python 切片包头不包尾) arr[5:8] array([5, 6, 7]) 把它赋给变量 b，并重新给 b 的第二个元素赋值 12，再看发现元数组 arr 第 7 个元素的值已经变成 12 了。 b = arr[5:8] b[1] = 12 arr array([ 0, 1, 2, 3, 4, 5, 12, 7, 8, 9]) 这就证实了切片得到原数组的视图 (view)，更改切片数据会更改原数组，而索引得到原数组的复制 (copy)， 更改索引数据不会更改原数组。希望用下面一张图可以明晰 view 和 copy 的关系。 了解完一维数组的切片和索引，类比到二维和多维数组上非常简单。 二维数组 arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) arr2d array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 索引 情况一：用 arr2d[2] 来索引第三行，更严格的说法是索引「轴 0」上的第三个元素。 arr2d[2] array([7, 8, 9]) 情况二：用 arr2d[0][2] 来索引第一行第三列 arr2d[0][2] 3 索引二维数组打了两个中括号好麻烦，索引五维数组不是要打了五个中括号？还有一个简易方法，用 arr2d[0, 2] 也可以索引第一行第三列 arr2d[0,2] 3 切片 情况一：用 arr2d[:2] 切片前两行，更严格的说法是索引「轴 0」上的前两个元素。 arr2d[:2] array([[1, 2, 3], [4, 5, 6]]) 情况二：用 arr2d[:, [0,2]] 切片第一列和第三列 arr2d[:,[0,2]] array([[1, 3], [4, 6], [7, 9]]) 情况三：用 arr2d[1, :2] 切片第二行的前两个元素 arr2d[1, :2] array([4, 5]) 情况四：用 arr2d[:2, 2] 切片第三列的前两个元素 arr2d[:2, 2] array([3, 6]) ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:4:1","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.2 布尔索引 布尔索引，就是用一个由布尔 (boolean) 类型值组成的数组来选择元素的方法。 假设我们有阿里巴巴 (BABA)，脸书 (FB) 和京东 (JD) 的 股票代码 code 数组 股票价格 price 数组：每行记录一天开盘，最高和收盘价格。 code = np.array(['BABA', 'FB', 'JD', 'BABA', 'JD', 'FB']) price = np.array([[170,177,169],[150,159,153], [24,27,26],[165,170,167], [22,23,20],[155,116,157]]) price array([[170, 177, 169], [150, 159, 153], [ 24, 27, 26], [165, 170, 167], [ 22, 23, 20], [155, 116, 157]]) 假设我们想找出 BABA 对应的股价，首先找到 code 里面是 ‘BABA’ 对应的索引 (布尔索引)，即一个值为 True 和 False 的布尔数组。 code == 'BABA' array([ True, False, False, True, False, False]) 用该索引可以获取 BABA 的股价： price[ code == 'BABA' ] array([[170, 177, 169], [165, 170, 167]]) 用该索引还可以获取 BABA 的最高和收盘价格： price[ code == 'BABA', 1: ] array([[177, 169], [170, 167]]) 再试试获取 JD 和 FB 的股价： price[ (code == 'FB')|(code == 'JD') ] array([[150, 159, 153], [ 24, 27, 26], [ 22, 23, 20], [155, 116, 157]]) 虽然下面操作没有实际意义，试试把股价小于 25 的清零。 price[ price \u003c 25 ] = 0 price array([[170, 177, 169], [150, 159, 153], [ 0, 27, 26], [165, 170, 167], [ 0, 0, 0], [155, 116, 157]]) 注：这种布尔索引的操作在 Pandas 更常用也更方便，看完 pandas 那帖后就可以忽略这一节了。 ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:4:2","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"3.3 花式索引 花式索引是获取数组中想要的特定元素的有效方法。考虑下面数组： arr = np.arange(32).reshape(8,4) arr array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]]) 假设你想按特定顺序来获取第 5, 4 和 7 行时，用 arr[ [4,3,6] ] arr[ [4,3,6] ] array([[16, 17, 18, 19], [12, 13, 14, 15], [24, 25, 26, 27]]) 假设你想按特定顺序来获取倒数第 4, 3 和 6 行时 (即正数第 4, 5 和 2 行)，用 arr[ [-4,-3,-6] ] arr[ [-4,-3,-6] ] array([[16, 17, 18, 19], [20, 21, 22, 23], [ 8, 9, 10, 11]]) 此外，你还能更灵活的设定「行」和「列」中不同的索引，如下 arr[ [1,5,7,2], [0,3,1,2] ] array([ 4, 23, 29, 10]) 检查一下，上行代码获取的分别是第二行第一列、第六行第四列、第八行第二列、第三行第三列的元素，它们确实是 4, 23, 29 和 10。如果不用花式索引，就要写下面繁琐但等价的代码： np.array( [ arr[1,0], arr[5,3], arr[7,1], arr[2,2] ] ) array([ 4, 23, 29, 10]) 最后，我们可以把交换列，把原先的 [0,1,2,3] 的列换成 [0,3,1,2]。 arr[:,[0,3,1,2]] array([[ 0, 3, 1, 2], [ 4, 7, 5, 6], [ 8, 11, 9, 10], [12, 15, 13, 14], [16, 19, 17, 18], [20, 23, 21, 22], [24, 27, 25, 26], [28, 31, 29, 30]]) ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:4:3","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","数学建模"],"content":"4 总结 本帖讨论了 NumPy 的前三节，数组创建、数组存载和数组获取。同样把 numpy 数组当成一个对象，要学习它，无非就是学习怎么 创建它：按步就班法、定隔定点法、一步登天法 存载它：保存成 .npy, .txt 和 .csv 格式，下次加载即用 获取它：一段用切片，一个用索引；有正规法、布尔法、花式法 等等，你好像还没教什么 numpy 数组硬核的东西呢，下帖讨论 NumPy 的后两节就教怎么 变形它：重塑和打平，合并和分裂，元素重复和数组重复 计算它：元素层面计算，线性代数计算，广播机制计算 欧了！下篇讨论 NumPy 系列的「数组的变形」和「数组的计算」。Stay Tuned! ","date":"2020-05-12","objectID":"/2020-05-12-numpy-%E4%B8%8A/:5:0","tags":["python","数学建模"],"title":"NumPy (上)","uri":"/2020-05-12-numpy-%E4%B8%8A/"},{"categories":["python","爬虫"],"content":"前言 需要下载Chrome或Firefox的driver，Chrome内核81.440与Firefox内核74.0下载链接如下： Firefox Chrome 其他版本请在搜索引擎查找，本篇使用该版本，注意，driver下载后需要配置对应内核的游览器，电脑本身需要有该内核的游览器。 ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:0:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"web自动化操作流程 from selenium import webdriver import time wd = webdriver.Chrome(r'C:\\chromedriver.exe') ''' wd.get('https://www.baidu.com') #webdriver类选择的是整个页面 element = wd.find_element_by_id(\"kw\") #class，name，id(id比较精确) #通过webelement对象进行操作 element.send_keys('csdn')#输入 如果输入csdn\\n可以模拟回车键 element = wd.find_element_by_id('su')#点击搜索 element.click()#点击 ''' wd.get('https://blog.csdn.net/spiritLHL/article/details/105252792?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158864611119724848300006%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.57677%2522%257D\u0026request_id=158864611119724848300006\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1') #elements = wd.find_element_by_class_name(\"blog-content-box\") #time.sleep(2)#模拟点击等待的时间(找不找得到都会等待) wd.implicitly_wait(5)#更方便的等待时间(找不到元素才会等待) elements = wd.find_elements_by_tag_name(\"p\") for e in elements: print(e.text) #print(elements.get_attribute('href')) wd.close()#关闭游览器 ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:0:2","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"find_element和find_elements的区别 使用find_elements选择的是符合条件的所有元素，如果没有符合条件的元素，回空列表 使用find_element选择的是符合条件的第一个元素，如果没有符合条件的元素，抛出异常 获取属性值—\u003e element.get_attribute('href') 获取整个元素对应html—\u003e elements.get_attribute('outerHTML') 获取某元素内所有html文本内容—\u003e elements.get_attribute('innerHTML') 获取输入框内的文本内容—\u003e elements.get_attribute('value') 获取元素文本内容 通过WebElement对象的text属性，可以获取元素展示在界面上的文本内容。 但是，有时候，元素的文本内容没有展示在界面上，或者没有完全完全展示在界面上。这时用WebElement的text属性,获取文本内容，就会有问题。 出现这种情况，可以尝试使用 element.get_attribute('innerText') 或者 element.get_attribute('textContent') ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:0:3","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"css选择器 wd.find_element_by_css_selector() CSS Selector同样可以根据tag名、id 属性和class属性来选择元素`。 根据tag名选择元素的CSS Selector语法非常简单，直接写上tag名即可。 比如要选择所有的tag名为div的元素,就可以是这样 elements = wd.find_elements_by_css_selector('div') 等价于 elements = wd.find_elements_by_tag_name('div') ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:1:0","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"根据属性值定位 element = wd.find_element_by_css_selector('[href=\"http://ww.miitbeian.gov.cn\"]') ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:1:1","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"验证所找元素是否正确书写格式 在开发者工具中按ctrl+f，输入所写格式，若存在着会高亮显示 css选择某个class的所有，写 .class0 (表示选中名为class0的所有标签) css选择两个不同名class(都选中)(中间写英文逗号）写 .class1 , .class2 逗号左右的属性类型可以不同 ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:1:2","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"父元素 父元素的第几个某类型的子节点 我们可以指定选择的元素是父元素的第几个某类型的子节点(要选择元素的上一层级为父节点) 使用 nth-of-type 比如，我们要选择class1和class2的第几个元素， 可以像上面那样思考：选择的是第2个子元素，并且是span类型 所以这样可以这样写 span:nth-child(2) 还可以这样思考，选择的是第1个span类型的子元素 所以也可以这样写 span:nth-of-type(1) 父元素的倒数第几个某类型的子节点 当然也可以反过来，选择父元素的倒数第几个某类型的子节点 使用 nth-last-of-type 像这样 p:nth-last-of-type(2) 相邻兄弟节点选择 上面的例子里面，我们要选择我们要选择class1和class2的第几个元素， 还有一种思考方法，就是选择h3后面紧跟着的兄弟节点span。 这就是一种相邻兄弟关系，可以这样写h3 + span 表示元素紧跟关系的是加号 后续所有兄弟节点选择 如果要选择是选择 h3 后面所有的兄弟节点span可以这样写 h3 ~ span ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:1:3","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","爬虫"],"content":"内嵌 内嵌html页面的，使用wd.switch_to.frame(frame_reference)切换到内嵌 页面进行操作。 其中，frame_reference可以是frame元素的属性name或者ID。 比如这里，就可以填写iframe元素的id'frame1' 或者name属性值'innerFrame'。 像这样 wd.switch_to.frame('frame1') 或者 wd.switch_to.frame('innerFrame') 也可以填写frame所对应的WebElement对象。 我们可以根据frame的元素位置或者属性特性，使用find系列的方法，选择到该元素，得到对应的WebElement对象 比如，这里就可以写 wd.switch_to.frame(wd.find_element_by_tag_name(\"iframe\")) 然后，就可以进行后续操作frame里面的元素了。 上面的例子的正确代码如下 from selenium import webdriver wd = webdriver.Chrome(r'd:\\webdrivers\\chromedriver.exe') wd.get('http://cdn1.python3.vip/files/selenium/sample2.html') # 先根据name属性值 'innerFrame'，切换到iframe中 wd.switch_to.frame('innerFrame') # 根据 class name 选择元素，返回的是 一个列表 elements = wd.find_elements_by_class_name('plant') for element in elements: print(element.text) #如果我们已经切换到某个iframe里面进行操作了，那么后续选择和操作界面元素 就都是在这个frame里面进行的。 #这时候，如果我们又需要操作主html（我们把最外部的html称之为主html）里面的元素了呢？ #怎么切换回原来的主html呢？ #很简单，写如下代码即可 wd.switch_to.default_content() #例如，在上面 代码 操作完 frame里面的元素后， 需要 点击 主html 里面的按钮，就可以这样写 from selenium import webdriver wd = webdriver.Chrome(r'd:\\webdrivers\\chromedriver.exe') wd.get('http://cdn1.python3.vip/files/selenium/sample2.html') # 先根据name属性值 'innerFrame'，切换到iframe中 wd.switch_to.frame('innerFrame') # 根据 class name 选择元素，返回的是 一个列表 elements = wd.find_elements_by_class_name('plant') for element in elements: print(element.text) # 切换回 最外部的 HTML 中 wd.switch_to.default_content() # 然后再 选择操作 外部的 HTML 中 的元素 wd.find_element_by_id('outerbutton').click() wd.quit() 如果我们要到新的窗口里面操作，该怎么做呢？ 可以使用Webdriver对象的switch_to属性的window方法，如下所示： wd.switch_to.window(handle) 其中，参数handle需要传入什么呢？ WebDriver对象有window_handles属性，这是一个列表对象，里面包括了当前浏览器里面所有的窗口句柄。 所谓句柄，大家可以想象成对应网页窗口的一个ID， 那么我们就可以通过类似下面的代码， for handle in wd.window_handles: # 先切换到该窗口 wd.switch_to.window(handle) # 得到该窗口的标题栏字符串，判断是不是我们要操作的那个窗口 if 'Bing' in wd.title: # 如果是，那么这时候WebDriver对象就是对应的该该窗口，正好，跳出循环， break 上面代码的用意就是： 我们依次获取wd.window_handles里面的所有句柄对象，并且调用wd.switch_to.window(handle)方法，切入到每个窗口，然后检查里面该窗口对象的属性(可以是标题栏，地址栏)判断是不是我们要操作的那个窗口，如果是，就跳出循环。 同样的，如果我们在新窗口操作结束后， 还要回到原来的窗口，该怎么办？ 我们可以仍然使用上面的方法，依次切入窗口，然后根据标题栏之类的属性值判断。 还有更省事的方法: 因为我们一开始就在原来的窗口里面，我们知道进入新窗口操作完后，还要回来，可以事先保存该老窗口的句柄，使用如下方法 (mainWindow变量保存当前窗口的句柄) mainWindow = wd.current_window_handle 切换到新窗口操作完后，就可以直接像下面这样，将driver对应的对象返回到原来的窗口 (通过前面保存的老窗口的句柄，自己切换到老窗口) wd.switch_to.window(mainWindow) ","date":"2020-05-10","objectID":"/2020-05-10-selenium01/:1:4","tags":["python","爬虫"],"title":"Selenium的web自动化操作01(环境布置与标准流程)","uri":"/2020-05-10-selenium01/"},{"categories":["python","数学建模"],"content":"前言 本篇鸣谢 燕大——马川 的整理 匹配Jupyter Notebook的ipynb文档链接下载地址如下 源文档 Python编程基础 by 马川 燕大 代码胜于雄辩 Talks is cheap. Show me the code. —-Linus Torvalds(Linux操作系统的奠基者) 对于任何一种计算机语言，最重要的就是： 数据类型 控制结构 函数 这三方面一定要打牢基础。 此外 Python 非常简洁，具有很多**高级特性**，使得一行代码 (one-liner) 就能做很多事情，我们将重点介绍各种「解析式」和「高阶函数」。 shirft + Tab 看Jupyter Notebook解释文档 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:0:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"00 Python概览 #直接在当前文件里运行时会调用main，但是在其他文件里import这个文件，就不会执行这个文件的main（上图解释） ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"Python程序实例解析 温度转换程序 根据华氏和摄氏温度定义，转换公式如下： C = ( F – 32 ) / 1.8\rF = C * 1.8 + 32\r 其中，C表示摄氏温度，F表示华氏温度 #e1.1TempConvert.py TempStr = input(\"请输入带有符号的温度值: \") if TempStr[-1] in ['F','f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print(\"转换后的温度是{:.2f}C\".format(C)) elif TempStr[-1] in ['C','c']: F = 1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是{:.2f}F\".format(F)) else: print(\"输入格式错误\") ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"Python语法元素分析 格式框架、注释、变量、表达式、语句函数 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"缩进 1个缩进 = 4个空格 (1)用以在Python中标明代码的层次关系 (2)缩进是Python语言中表明程序框架的唯一手段 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:3","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"注释 单行注释以#开头 print(\"Hello world\") #打印显示 多行注释以 ‘‘‘开头和结尾 ‘‘‘python This is a multiline comment used in Python '’’ ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:4","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"命名与保留字 常量： 程序中值不发生改变的元素 变量：程序中值发生改变或者可以发生改变的元素 Python语言允许采用大写字母、小写字母、数字、下划线(_)和汉字等字符及其组合给变量命名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制 注意：标识符对大小写敏感，python和Python是两个不同的名字 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:5","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"字符串 Python语言中，字符串是用两个双引号“ ”或者单引号‘ ’括起来的一个或多个字符。 Python字符串的两种序号体系 str = \"Hello World\" print(str[0:-1]) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:6","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"赋值语句 Python语言中，= 表示“赋值”，即将等号右侧的值计算后将结果值赋给左侧变量，包含等号（=）的语句称为“赋值语句” 同步赋值 x=5 y=10 x,y=y,x print(x,y) x,y,z=1,4,5 print(x,y,z) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:7","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"input()函数 获得用户输入之前，input()函数可以包含一些提示性文字 \u003c变量\u003e = input(\u003c提示性文字\u003e) 字符型\r input(\"请输入: \") ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:8","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"eval() 函数 eval(\u003c字符串\u003e)函数是Python语言中一个十分重要的函数，它去掉字符串最外侧的引号并以Python表达式的方式解析并执行去掉引号后的字符串内容，将返回结果输出(会进行数值运算) tmp=\"102C\" print(eval(\"tmp\")) print(eval(tmp[0:-1])) value=eval(input(\"输入数值\")) print(value*2) s = \"11+5in\" print(eval(s[1:-2])) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:9","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"输出函数 #print()函数用来输出字符信息，或以字符形式输出变量。 F=10.258 print(F) print(\"转换后的温度是{:.2f}\".format(F)) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:10","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"Python 库的引入与调用 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:11","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"import关键字 import是一个关键字，用来引入一些外部库 引入方式1 import numpy print(numpy.arange(0,10)) 引入方式2 from numpy import * print(arange(0,10)) 引入方式3 import numpy as np print(np.arange(0,10)) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:1:12","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"01 数据 在 Python 中数据可分两大类： 基本数据类型(元素型)：整数、浮点数、复数、布尔型 组合数据类型(容器型)：字符串、元组、列表、字典、集合 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"1.1 基本数据类型（元素型） Python 里面有自己的内置数据类型 (build-in data type)，本节介绍四种数字类型(Numbers): 整型 (int) 浮点型 (float) 复数 (complex) 布尔型 (bool) 思维导图(图中左侧部分的字符串属于组合数据类型) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"数字类型 print( 1, type(1) ) print( 1., type(1.) ) print( 1 + 2j, type(1 + 2j) ) print( True, type( True )) 布尔型 (boolean) 布尔 (boolean) 型变量只能取两个值，True 和 False。当把布尔变量用在数字运算中，用 1 和 0 代表 True 和 False。 T = True F = False print( T + 2 ) print( F - 8 ) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"数字类型的转换 int(4.5) # = 4 ，直接去掉小数部分 float(4) # = 4.0，增加小数部分 complex(4) # = 4 + 0j bool(4.5) bool(x) 若x为基本数据类型，则只要x不是整型 0、浮点型 0.0，bool(x) 就是 True，其余就是 False。 若x为组合数据类型，则只要x不是空的变量，bool(x) 就是 True，其余就是 False。 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:3","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"类型的判断 type() 函数：type(x)，返回x的类型，适用于所有类型的判断 print(type(4+2j)) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:4","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"dir和help函数 dir() dir()用来查询一个类或者对象的所有属性 dir(list) help() help()函数帮助我们了解模块、类型、对象、方法、属性的详细信息 1.帮助查看类型详细信息，包含类的创建方式、属性、方法 help(list) 2.帮助查看方法的详细使用信息（使用时要注意输入完整路径，使用模块帮助时，需要先导入模块） import math help(math.sqrt) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:2:5","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"字符串类型及其操作 字符串是用双引号“”或者单引号‘’ 或’’’括起来的一个或多个字符。 字符串可以保存在变量中，也可以单独存在。 可以用type()函数测试一个字符串的类型 print('单引号表示可以使用\"双引号\"作为内容') print(\"双引号表示可以使用'单引号'作为内容\") print('''三引号表示可以使用\"双引号\" 单引号'作为内容'，还可以换行 ''') ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"常用的字符串处理函数 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"len len()函数返回一个字符串的长度 print(len(\"天行健，君子以自强不息\")) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"str 大多数数据类型都可以通过str()函数转换为字符串 str(123.456) str(123e+10) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:3","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"遍历字符串 可以通过 for 和 in 组成的循环来遍历字符串中每个字符 mystr=\"地势坤，君子以厚德载物\" for s in mystr: print(s) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:4","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"split 按指定字符分割字符串为数组 mystr=\"敕勒川，阴山下，天似穹庐，笼盖四野\" print(mystr.split(\"，\")) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:5","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"join 连接两个字符串序列 mystr = \"@\" ls = [\"天苍苍\",\"野茫茫\",\"风吹草低见牛羊\"] print(mystr.join(ls)) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:6","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"replace 字符串替换 myOldStr=\"今夕何夕溪，搴舟中流。今日何日溪，得与王子同舟。\" myNewStr=myOldStr.replace(\"溪\",\"兮\") print(myNewStr) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:7","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"format方法的基本使用 hero=\"乔峰\" department=\"丐帮\" skill=\"降龙十八掌\" print(\"{}大侠，{}人士，成名绝技{},此前已刻苦练功{}个时辰\".format(hero,department,skill,1234.5678)) #\"{0:*^30}大侠，{1}人士，成名绝技{2},此前已刻苦练功{3:,.2f}个时辰\".format(hero,department,skill,1234.5678) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:8","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"1.2 组合数据类型(容器型) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:9","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"思维导图 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:3:10","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"序列 序列是一组有顺序的元素向量，通过序号访问，元素之间不排他。 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"1. 字符串(具体细节见“基本数据类型”思维导图左侧部分) mystr=\"Hello world\" mystr[0:3] mystr[0:-1] print(\"Hello world\"[0:3]) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"2. 元组 creature = \"cat\", \"dog\", \"tiger\", \"human\" color = (\"red\", 0x001100, \"blue\", creature) color[2] color[-1][2]#索引可以索引两重 应用场景 def func(x): #函数多返回值 return x, x**3 a, b = 'dog', 'tiger' #多变量同步赋值 a, b = (b, a) #多变量同步赋值，括号可省略 func(3) import math for x, y in ((1,0), (2,5), (3,8)): #循环遍历 print(math.hypot(x,y)) #求多个坐标值到原点的距离 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"3. 列表 ls = [425, \"BIT\", [10, \"CS\"], 425] ls[2][-1][0]#多重索引 list((425, \"BIT\", [10, \"CS\"], 425)) list(\"中国是一个伟大的国家\") list() print(ls[2][-1][0]) ls = [425, \"BIT\", 1024] #用数据赋值产生列表ls lt = ls #lt是ls所对应数据的引用，lt并不包含真实数据 #lt = ls[:] #ls通过分片操作将列表ls的元素全部拷贝给lt ls[0] = 0 print(id(ls),id(lt)) vlist = list(range(5)) len(vlist[2:]) #计算从第3个位置开始到结尾的子串长度 2 in vlist #判断2是否在列表vlist中 vlist[3]=\"python\" #修改序号3的元素值和类型 vlist[1:3]=[\"bit\", \"computer\"] print(vlist) 多增少减 vlist[1:3]=[\"new_bit\", \"new_computer\", 123] vlist #vlist[1:3]=[\"fewer\"] print(vlist) #以k为步数 ls = [425, \"BIT\", [10, \"CS\"], 123, \"Hello Ysu\", 23 , (10,29)] lt=[\"1st\",\"2nd\",\"3rd\"] ls[0:5:2] = lt print(ls) del ls[0:5:2]#删去了024号元素 print(ls) ls = [\"1st\",\"2nd\",\"3rd\"] lt = [425, \"BIT\", [10, \"CS\"], 425, \"Hello Ysu\", 23, 425, (10,29)] #在列表ls最后增加一个元素x ls.append(\"4th\") print(ls) #删除ls中所有元素 ls.clear() print(ls) #生成一个新列表，复制lt中所有元素 ls = lt.copy() print(ls) #在列表ls第i位置增加元素x ls.insert(1,\"ysu\") print(ls) #将列表ls中第i项元素取出并删除该元素BIT ls.pop(2) #将列表中出现的第一个元素x删除 ls.remove(425) print(ls) #列表ls中元素反转 ls.reverse() print(ls) for e in vlist: print(e, end=\" \")#不换行显示 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:3","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"4. 集合 集合类型是一个元素集合，元素之间无序，相同元素在集合中唯一存在。 #元素类型只能是固定数据类型，例如：整数、浮点数、字符串、元组等 S = {425, \"BIT\", (10, \"CS\"), 424} T = {425, \"BIT\", (10, \"CS\"), 424, 425, \"BIT\"} #列表、字典和集合类型本身都是可变数据类型，不能作为集合的元素出现。 X = {425, \"BIT\", [10, \"CS\"], {\"蜀\":\"诸葛亮\"}, {234,(10,\"haha\")}} #set(x)函数可以用于生成集合 W = set('apple') V = set((\"cat\", \"dog\", \"tiger\", \"human\")) print(V) 应用场景 \"BIT\" in {\"PYTHON\", \"BIT\", 123, \"GOOD\"} #成员关系测试 tup = (\"PYTHON\", \"BIT\", 123, \"GOOD\", 123) tup1 = set(tup)#元素去重 newtup = tuple(set(tup)-{'PYTHON'}) # 去重同时删除数据项 print(tup1) 集合类型的4种基本操作，交集（\u0026）、并集（|）、差集（-）、补集（^），操作逻辑与数学定义相同 A = {425, \"BIT\", (10, \"CS\"), 424, 125, \"This is A\"} B = {425, \"BIT\", (10, \"CS\"), 424, 425, \"BIT\",\"This is B\"} print(A | B) print(A - B) print(A \u0026 B) print(A ^ B) s = [123,(45,\"Hello world\"),\"set\"] t = [123,(45,\"Hello world\"),\"set\",\"haha\"] print(s \u003c= t) print(s \u003e= t) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:4","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"5. 映射 映射类型是“键-值”数据项的组合，每个元素是一个键值对，表示为(key, value) 字典是集合类型的延续，各个元素并没有顺序之分 Dcountry={\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"} print(Dcountry) #访问 Dcountry[\"中国\"] #修改 Dcountry[\"中国\"]='大北京' print(Dcountry) #增加新元素 Dcountry={\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"} Dcountry[\"英国\"]=\"伦敦\" print(Dcountry) #直接使用大括号（{}）可以创建一个空的字典，并通过中括号（[]）向其增加元素 Dp={} Dp['2^10']=1024 print(Dp) 字典类型的操作 Dcountry={\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"} Dcountry.keys() list(Dcountry.values()) Dcountry.items() '中国' in Dcountry #只对键进行判断 Dcountry.get('美国', '悉尼') #'美国'在字典中存在 Dcountry.get('澳大利亚', '悉尼') #'澳大利亚'在字典中不存在 for key in Dcountry: print(key) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:4:5","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"02 程序的控制结构 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:5:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"思维导图 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:5:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"分支结构 #求两个数的最大值 x=int(input(\"请输入x:\")) y=int(input(\"请输入y:\")) if x\u003ey: print(x) else: print(y) #条件判断从左到右执行，并且在and或or两侧的条件会有\"短路\"现象 a = 5 b = 7 c = 8 d = 6 if a\u003cb or c\u003ed: print(\"True\") def suma(y): global a a=a+y return a if suma(2) or suma(3): print(\"a={}\".format(a)) 身体质量指数BMI #多分支 height, weight = eval(input(\"请输入身高(米)和体重(公斤)[逗号隔开]: \")) bmi = weight / pow(height, 2) print(\"BMI数值为：{:.2f}\".format(bmi)) wto, dom = \"\", \"\" if bmi \u003c 18.5: wto, dom = \"偏瘦\", \"偏瘦\" elif 18.5 \u003c= bmi \u003c 24: wto, dom = \"正常\", \"正常\" elif 24 \u003c= bmi \u003c 25: wto, dom = \"正常\", \"偏胖\" elif 25 \u003c= bmi \u003c 28: wto, dom = \"偏胖\", \"偏胖\" elif 28 \u003c= bmi \u003c 30: wto, dom = \"偏胖\", \"肥胖\" else: wto, dom = \"肥胖\", \"肥胖\" print(\"BMI指标为:国际'{0}', 国内'{1}'\".format(wto, dom)) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:5:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"循环结构 遍历循环：for语句 循环次数确定，循环次数采用遍历结构中元素的个数来体现 #判断一个数是否为素数 integer=int(input(\"请输入一个整数:\")) flag=False for i in range(2,integer):#从2到输入的整数求余数，若都为0就是素数 if integer%i==0: break else: # if i==integer-1 flag=True print(\"问：整数{}是素数吗？\\n答：{}\".format(integer,flag)) continue vs break for i in range(4): for j in range(4): if j==i: print('-',end='\\t') break # 试试continue print('*',end='\\t') print() 无限循环：while语句 循环次数不确定。无限循环一直保持循环操作，直到特定循环条件不被满足才结束 #猜密码 guess=0 #输入的数字 secret=7 #预设的数字 while guess!=secret: #条件 也可用True/barek构造无限循环 guess=int(input(\"@数字区间0-9，请输入你猜的数字:\")) if guess==secret: print(\"你猜对了，真厉害！\") else: print(\"很遗憾，猜错了！\") print(\"游戏结束\") #猜密码 secret=7 #预设的数字 while True: # 用True/barek构造无限循环 guess=int(input(\"@数字区间0-9，请输入你猜的数字:\")) if guess==secret: print(\"你猜对了，真厉害！\") break else: print(\"很遗憾，猜错了！\") print(\"游戏结束\") ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:5:3","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"03 函数 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:6:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"思维导图 def - 使用def关键字定义函数 function_name - 函数名，起名应有意义，见名知意 arg1 - 位置参数 ，这些参数在调用函数 (call function) 时位置要固定 arg2 = v - 默认参数 = 默认值，调用函数的时候，默认参数已经有值，可省略 *args - 可变参数，可以是从零个到任意个，自动组装成元组 ：- 冒号，在第一行最后要加个冒号，表示后面内容为函数体部分 “““docstring””” - 函数说明，用于介绍该函数，可省略，但写函数说明是一个好习惯，可使你写的代码可读性更好 statement - 函数体部分(函数内容) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:6:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"函数的参数传递 默认值 def dup(str, times = 2): print(str*times) dup(\"knock~\") dup(\"knock~\",4) 可选参数 def func(x1,y1,z1,x2,y2,z2): return (x1,y1,z1,x2,y2,z2) # 按位置给参数赋值 result = func(1,2,3,4,5,6) # 按参数名给参数赋值 result = func(x2=4, y2=5, z2=6, x1=1, y1=2, z1=3) 可变参数 def vfunc(a, *b): print(type(b)) for n in b: a += n return a vfunc(1,2,3,4,5) 注意： 在 Python 中定义函数时，若定义了位置参数、默认参数、可变参数，参数定义的顺序必须是： 位置参数、默认参数、可变参数 否则，程序会报错。 函数的返回值 def func(a, b): return a*b s = func(\"knock~\", 2) print(s) def func(a, b): return b,a s = func(\"knock~\", 2) #print(s, type(s)) 全局变量与局部变量 n = 1 #n是全局变量 def func(a, b): c = a * b #c是局部变量，a和b作为函数参数也是局部变量 return c s = func(\"knock~\", 2) print(c) print(s) n = 1 #n是全局变量 def func(a, b): n = b #这个n是在函数内存中新生成的局部变量 return a*b s = func(\"knock~\", 2) print(s, n) n = 1 #n是全局变量 def func(a, b): global n n = b #将局部变量b赋值给全局变量n return a*b s = func(\"knock~\", 2) print(s, n) ls = [] #建立ls全局列表变量 def func(a, b): ls.append(b) #将局部变量b增加到全局列表变量ls中 return a*b s = func(\"knock~\", 2) print(s, ls) #测试一下ls值是否改变 ls = [] #ls是全局列表变量 def func(a, b): ls = [] #创建了名称为ls的局部列表变量列 ls.append(b) #将局部变量b增加到局部列表变量ls中 return a*b s = func(\"knock~\", 3) print(s, ls) #测试一下ls值是否改变 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:6:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"函数的递归 def fact(n): if n == 0: return 1 else: return n * fact(n-1) num = eval(input(\"请输入一个整数: \")) print(fact(abs(int(num)))) def reverse(s): if s==\"\": return s else: return reverse(s[1:]) + s[0] lambda函数(匿名函数) lambda - 定义匿名函数的关键字 argument_list - 函数参数，可以是位置参数、默认参数、可变参数等，和正规函数里的参数类型一样 ：- 冒号，在函数参数和表达式中间要加个冒号 expression - 函数表达式，输入函数参数，输出一些值 注意 lambda 函数没有所谓的函数名，所以也叫匿名函数。下面是一些 lambda 函数示例： lambda所表示的匿名函数的内容应该是很简单的，如果复杂的话，干脆就重新定义一个函数了，使用lambda就有点过于执拗了。 # 输入 x 和 y，输出其积 x*y func = lambda x, y: x*y func(2, 3) 和下面的正规函数等价： def func(x,y): return x*y func(2,3) # 输入任意个数的参数，输出其和 func = lambda *args: sum(args) func( 1, 2, 3, 4, 5 ) 和下面的正规函数等价： def func(*args): return sum(args) func( 1, 2, 3, 4, 5 ) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:6:3","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"04 高级特性 在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。 因此，Python中有许多高级特性，这里仅介绍推导式和高阶函数。 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:7:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"推导式 推导式comprehensions（又称生成式、解析式），是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 共有三种推导，在Python2和3中都有支持： 列表(list)推导式 字典(dict)推导式 集合(set)推导式 基本格式 variable = [out_exp_res for out_exp in input_list if out_exp == 2] [要添加的元素 for循环 if判断条件] out_exp_res:　列表生成元素表达式，可以是有返回值的函数。 for out_exp in input_list：　迭代input_list将out_exp传入out_exp_res表达式中。 if out_exp == 2：　根据条件过滤哪些值可以。 问题： 如何从一个含整数列表中把奇数 (odd number) 挑出来？ lst = [1, 2, 3, 4, 5] odds = [] for n in lst: if n % 2 == 1: odds.append(n * 2) odds 任务完成了，但不够简洁，看看下面这一行代码： odds = [n * 2 for n in lst if n % 2 == 1] odds 乍一看从「for 循环」到「解析式」不直观，我来用不同颜色把这个过程可视化一下，如下图： 现在你可能会说上面「for 循环」只有一层，如果两层怎么转换「列表解析式」？具体来说怎么解决下面这个问题。 问题： 如何用「列表解析式」将一个二维列表中的元素按行一个个展平？ 没思路？先用「for 循环」试试？ lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] flattened = [] for row in lst: for n in row: flattened.append(n) flattened 套用一维「列表解析式」的做法 两点需要注意： 该例没有「if 条件」条件，或者认为有，写成「if True」。如果有「if 条件」那么直接加在「内 for 循环」后面。 「外 for 循环」写在「内 for 循环」前面。 lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] flattened = [n for row in lst for n in row] flattened 我们把「列表解析式」那一套举一反三的用到其他解析式上，用下面两图理解一下「字典解析式」和「集合解析式」。 再看一些例子： #列表生成式 #两层循环 [m + n for m in 'ABC' for n in 'XYZ'] #字典生成式 #大小写key合并 mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3} mcase_frequency = {v: k for k, v in mcase.items()} print(mcase_frequency) #集合生成式 squared = {x**2 for x in [1, 1, 2]} print(squared) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:7:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"高阶函数 高阶函数 (high-order function) 在函数化编程 (functional programming) 很常见，主要有两种形式： 参数是函数 (map, filter, reduce) 返回值是函数 (closure, partial, currying) 这里只介绍第一种。 Map, Filter, Reduce Python 里面的 map, filter 和 reduce 属于第一种高阶函数，参数是函数。这时候是不是很自然的就想起了 lambda 函数？ 作为内嵌在别的函数里的参数，lambda 函数就像微信小程序一样，即用即丢，非常轻便。 首先看看 map, filter 和 reduce 的语法： map(函数 f, 序列 x)： 对序列 x 中每个元素依次执行函数 f，将 f(x) 组成一个「map 对象」返回 (可以将其转换成 list 或 set) filter(函数 f, 序列 x)： 对序列 x 中每个元素依次执行函数 f，将 f(x) 为 True 的结果组成一个「filter 对象」返回 (可以将其转换成 list 或 set) f(x)是一个判断函数，取值为正的时候返回对象 reduce(函数 f, 序列 x)： 对序列 x 的第一个和第二个元素执行函数 f，得到的结果和序列 x 的下一个元素执行函数 f，一直遍历完的序列 x 所有元素。 map() 函数接收两个参数，一个是函数，一个是 Iterable (可迭代对象，如列表、元组、字典、字符串等可以用for遍历的数据结构)，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator(可以将其转换成 list 或 set)返回。 看个具体的平方示例，用 map 函数对列表每个元素平方。 lst = [1, 2, 3, 4, 5, 6, 7, 8, 9] map_iter = map( lambda x: x**2, lst ) print( map_iter ) print( list(map_iter) ) 接着再看看 filter 函数，顾名思义就是筛选函数，那么我们把刚才列表中的计数筛选出来吧。 filter_iter = filter(lambda n: n % 2 == 1, lst) print( filter_iter ) print( list(filter_iter) ) 在 filter 函数中 第一个参数是一个识别奇数的「匿名函数」 第二个参数是列表，即该「匿名函数」作用的对象 同样，filter_iter 作为 filter 函数的返回对象，也是一个迭代器，想要将其内容显示出来，需要用 list 将其转换成「列表」形式。 最后来看看 reduce 函数，顾名思义就是累积函数，把一组数减少 (reduce) 到一个数。 from functools import reduce reduce( lambda x,y: x+y, lst ) 在 reduce 函数中 第一个参数是一个求和相邻两个元素的「匿名函数」 第二个参数是列表，即该「匿名函数」作用的对象 在 reduce 函数的第三个参数还可以赋予一个初始值 reduce( lambda x,y: x+y, lst, 100 ) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:7:2","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"05 综合示例 ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:8:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"Jieba库的使用 #jieba库的安装 #pip install jieba import jieba jieba.lcut(\"中国是一个伟大的国家\") 精确模式：将句子最精确地切开，适合文本分析 jieba.lcut(\"中华人民共和国是一个伟大的国家\") 全模式：把句中所有可以成词的词语都扫描出来，速度快，但不能解决歧义 jieba.lcut(\"中华人民共和国是一个伟大的国家\", cut_all=True) 搜索引擎模式：在精确模式的基础上，对长词再次切分，适合搜索引擎分词 jieba.lcut_for_search(\"中华人民共和国是一个伟大的国家\") ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:9:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"《三国演义》人物出场统计 import jieba excludes = {\"将军\",\"却说\",\"荆州\",\"二人\",\"不可\",\"不能\",\"如此\"} txt = open(\"三国演义.txt\", \"r\", encoding='utf-8').read() words = jieba.lcut(txt) counts = {} for word in words: if len(word) == 1: continue elif word == \"诸葛亮\" or word == \"孔明曰\": rword = \"孔明\" elif word == \"关公\" or word == \"云长\": rword = \"关羽\" elif word == \"玄德\" or word == \"玄德曰\": rword = \"刘备\" elif word == \"孟德\" or word == \"丞相\": rword = \"曹操\" else: rword = word counts[rword] = counts.get(rword,0) + 1 for word in excludes: del(counts[word]) items = list(counts.items()) items.sort(key=lambda x:x[1], reverse=True) for i in range(10): word, count = items[i] print (\"{0:\u003c10}{1:\u003e5}\".format(word, count)) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:10:0","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python","数学建模"],"content":"Sort函数 列表有自己的sort方法，其对列表进行原址排序 x = [4, 6, 2, 1, 7, 9] x.sort() print(x) sort和sorted方法还有两个可选参数：key和reverse key接受一个函数，这个函数只接受一个元素，这个函数用于从每个元素中提取一个用于比较的关键字,默认为None x = ['mmm', 'mm', 'mm', 'm' ] x.sort(key = len) #指定key=len，就是比较len()之后的结果 print(x) reverse是一个布尔值。如果设置为True，列表元素将被倒序排列，默认为False y = [3, 2, 8 ,0 , 1] y.sort(reverse = False) print(y) ","date":"2020-05-09","objectID":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/:10:1","tags":["python","数学建模"],"title":"Python数据分析快速入门","uri":"/2020-05-09-python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["python"],"content":"直接放代码 from selenium import webdriver import time driver = webdriver.Chrome(r'C:\\chromedriver.exe') urllist = [ 'https://www.bilibili.com/video/BV15f4y1m7xH?from=search\u0026seid=9788956603997309480', 'https://www.bilibili.com/video/BV1WA411h76h?from=search\u0026seid=9738279009337231611', 'https://www.bilibili.com/video/BV13c411h7k7?from=search\u0026seid=9738279009337231611', 'https://www.bilibili.com/video/BV1x541147u8?from=search\u0026seid=9738279009337231611', 'https://www.bilibili.com/video/BV17p4y1C78w?from=search\u0026seid=9738279009337231611' ] #视频链接 timelist=[ 311, 598, 669, 568, 507, ] #放入自己各个视频的时长 t = 0 for url in urllist: try: driver.set_page_load_timeout(5) driver.get(url) time.sleep(10) except Exception : print(\"timeout\") element = driver.find_element_by_xpath('//*[@id=\"bilibiliPlayer\"]/div[1]/div[1]/div[10]/div[2]/div[2]/div[1]/div[1]/button[1]')#xpath抓取播放控件 time.sleep(5) print('控件抓取成功') driver.find_element_by_xpath('//*[@id=\"bilibiliPlayer\"]/div[1]/div[1]/div[10]/div[2]/div[2]/div[1]/div[1]/button[1]').click()#xpath定位成功后点击播放 print('播放成功') time.sleep(timelist[t]) print('下一个视频') t = t + 1 因为页面加载需要时间，抓取控件也需要时间，设计sleep时长看你的页面加载速度以及网速进行调整 链接https://b23.tv/D0a1BX是我完善后的源码效果视频，视频评论区里有完善后的源码链接，视频点赞自取。 ","date":"2020-05-05","objectID":"/40/:1:0","tags":["python"],"title":"比较简单的selenium自动化操作播放bilibili(b站)视频2020","uri":"/40/"},{"categories":["python","爬虫"],"content":"前言 xpath解析原理: 1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。 2.调用et ree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。 环境的安装: pip install Lxml 如何实例化一个etree对象: from Lxml import etree 1.将本地的html文档中的源码数据加载到etree对象中: etree.parse(fiLePath) 2.可以将从互联网上获取的源码数据加裁到该对象中 etree.HTML( 'page_ text' ) xpath('xpath表达式') #3.7版本后引入etree模块如下，3.5版本以下可以直接从lxml中引入 from lxml import html etree = html.etree parser = etree.HTMLParser(encoding=\"utf-8\") #实例化好了一个etree对象，且将被解析的源码加载到了该对象中 tree = etree.parse('bs4练习.html', parser=parser) # r = tree.xpath('/html/body/div') # r = tree.xpath('/html//div') # r = tree.xpath('//div') /表示的是从根节点开始定位，一个/x/表示一个层级，//表示跨越多个层级,可以表示从任意位置开始定位 r = tree.xpath('//div[@class=\"song\"]') 属性定位： //div[@class=\"song\"] tag[@attrName=\"attrValue\"] r = tree.xpath('//div[@class=\"song\"]/p[3]') 索引定位： '//div[@class=\"song\"]/p[3]' #这里索引以1开始 r = tree.xpath('//div[@class=\"tang\"]//li[5]/a/text()')[0] 取文本： /text() #获取的是标签中直系的文本内容 //text() #获取标签中非直系文本内容（所有文本内容） ```python r = tree.xpath('//div[@class=\"tang\"]/text()') 取属性： /@attrName ==\u003eimg/src r = tree.xpath('//div[@class=\"song\"]/img/@src') 实际案例： #3.7版本后引入etree模块如下，3.5版本以下可以直接从lxml中引入 from lxml import html import requests etree = html.etree a = True while a: #爬取页面源码数据 url = 'https://mm.58.com/ershoufang/' headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36' } page_text = requests.get(url=url, headers=headers).text #数据解析 tree = etree.HTML(page_text) li_list = tree.xpath('//ul[@class=\"house-list-wrap\"]/li') fp = open('58.txt', 'w', encoding='utf-8') for li in li_list: #页面数据局部解析 title = li.xpath('./div[2]/h2/a/text()')[0]#./表示从前面的li开始（局部开始） print(title) fp.write(title+'\\n') a = False ","date":"2020-05-03","objectID":"/2020-05-03-%E7%88%AC%E8%99%AB13/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法13(xpath解析页面)","uri":"/2020-05-03-%E7%88%AC%E8%99%AB13/"},{"categories":["python","爬虫"],"content":"前言 re库的实用实例如下 import requests import re import os a = True while a: #创建一个文件夹，保存所有图片 if not os.path.exists('./tupianLibs'): os.mkdir('./tupianLibs') headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36' } url = \"https://www.pexels.com/\" #使用通用爬虫对整张页面进行爬取 page_text = requests.get(url=url, headers=headers).text #使用聚焦爬虫将页面中所有的图片进行解析/提取 #正则.*?表示一切内容 #re.S单行匹配 ex = '\u003ca class=\"js-photo-link photo-item__link\" style.*? \u003e.*?\u003cimg srcset=\"(.*?)\" class.*?\u003e\u003c/div\u003e' image_src_list = re.findall(ex, page_text, re.S ) for src in image_src_list: src = 'https:'+ src #拼接出一个完整的图片url image_data = requests.get(url=src, headers=headers).content #请求到了图片的二进制数据 image_name = src.split('/')[-1] #生成图片名称 imgPath = './tupianlbs/' + image_name #图片最终存储的路径 with open(imgPath, 'W') as fp: fp.write(image_data) print('下载成功') a = False ","date":"2020-05-03","objectID":"/2020-05-03-%E7%88%AC%E8%99%AB14/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法14(正则表达式篇)","uri":"/2020-05-03-%E7%88%AC%E8%99%AB14/"},{"categories":["python","爬虫"],"content":"正则表达式详情 raw string类型区别于原生字符串类型（不包含转义字符） r'[1-9]\\d{5}' re.search(pattern, string, flags=0) 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象。 pattern:正则表达式的字符串或原生字符串表示 string:待匹配字符串 flags:正则表达式使用时的控制标记 re.split(pattern, string, maxsplit=0, flags=0) 将一个字符串按照正则表达式匹配结果进行分割,返回列表类型。 pattern:正则表达式的字符串或原生字符串表示 string:待匹配字符串 maxsplit:最大分割数，剩余部分作为最后一个元素输出 flags:正则表达式使用时的控制标记 re.finditer(pattern, string, flags=0) 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象。 pattern:正则表达式的字符串或原生字符串表示 string:待匹配字符串 flags:正则表达式使用时的控制标记 re.sub(pattern, repl, string, count=0, flags=0) 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。 pattern:正则表达式的字符串或原生字符串表示 repl:替换匹配字符串的字符串 string:待匹配字符串 flags:正则表达式使用时的控制标记 regex = re.compile(pattern, flags=0) 将正则表达式的字符串形式编译成正则表达式对象 pattern:正则表达式的字符串或原生字符串表示 flags:正则表达式使用时的控制标记 Match:对象的属性 match = re.search(r'PY.*N',' PYANBNCNDN' ) match.group(0) Re库默认采用贪婪匹配，即输出匹配最长的子串。 输出’PYANBNCNDN' match = re.search(r'PY. *?N', ' PYANBNCNDN') match group(0) 输出’PYAN ' import re restr=\"\u003ctd data-v-80203e10=\"\"\u003e（\\\\d+）\u003c/td\u003e\"#括号表示只取数据（数字） regex=re.compile(restr,re.IGNORECASE) mylist=regex.findall(province) ","date":"2020-05-03","objectID":"/2020-05-03-%E7%88%AC%E8%99%AB14/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法14(正则表达式篇)","uri":"/2020-05-03-%E7%88%AC%E8%99%AB14/"},{"categories":["python","爬虫"],"content":"前言 目的:在爬虫中使用异步实现高性能的数据爬取操作。 异步爬虫的方式: –多线程，多进程(不建议): 好处:可以为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行。 弊端:无法无限制的开启多线程或者多进程。 ps:get方法与post方法是阻塞的方法 –线程池、进程池(适当的使用)： 好处:我们可以降低系统对进程或者线程创建和销毁的一个频率，从而很好的降低系统的开销。 弊端:池中线程或进程的数量是有上限。| ","date":"2020-05-01","objectID":"/2020-05-01-%E7%88%AC%E8%99%AB12/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法12(高性能异步爬虫)","uri":"/2020-05-01-%E7%88%AC%E8%99%AB12/"},{"categories":["python","爬虫"],"content":"模拟多线程操作 单线程模拟： import time #使用单线程串行方式执行 def get_page(str): print(\"正在下载: \", str) time.sleep(2) print('下载成功: ', str) name_list = ['xiaozi', 'aa','bb','cc'] start_time = time.time() for i in range(len(name_list)): get_page(name_list[i]) end_time = time.time() print('%dsecond' % (end_time-start_time)) 结果:8s 线程池模拟： import time #导入线程池模块对应的类 from multiprocessing.dummy import Pool #使用线程池方式进行 #导入线程池所对应的pool start_time = time.time()#程序开始时计时 def get_page(str): print(\"正在下载: \", str) time.sleep(2) print('下载成功: ', str) name_list = ['xiaozi', 'aa','bb','cc']#可迭代对象 #实例化一个线程对象 pool = Pool(4)#线程池开启4个线程 #将列表中每一个列表元素传递给get_page进行处理 pool.map(get_page, name_list)#若有返回值返回的是列表，因为多次传入到map end_time = time.time()#程序结束时结束计时 print(end_time-start_time) 结果:2s ","date":"2020-05-01","objectID":"/2020-05-01-%E7%88%AC%E8%99%AB12/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法12(高性能异步爬虫)","uri":"/2020-05-01-%E7%88%AC%E8%99%AB12/"},{"categories":["python","爬虫"],"content":"实际案例 提取js动态加载内容，使用re正则匹配 js源码 var contId=\"1671755\",liveStatusUrl=\"liveStatus.jsp\",liveSta=\"\",playSta=\"1\",autoPlay=!1,isLiving=!1,isVrVideo=!1,hdflvUrl=\"\",sdflvUrl=\"\",hdUrl=\"\",sdUrl=\"\",ldUrl=\"\",srcUrl=\"https://video.pearvideo.com/mp4/third/20200429/cont-1671755-11742488-084919-hd.mp4\",vdoUrl=srcUrl,skinRes=\"//www.pearvideo.com/domain/skin\",videoCDN=\"//video.pearvideo.com\" 正则匹配 ex = ‘srcUrL=\"( .*? )”,vdoUrl’ 分组操作提取链接 import requests from bs4 import BeautifulSoup import re from multiprocessing import Pool def get_video_data(dic): headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\" } #使用线程池对视频数据进行请求（较为耗时的堵塞操作） url = dic['url'] print(dic['name'], '正在下载') data = requests.get(url=url, headers=headers, timeout=0.5).content #持久化存储操作 with open(dic['name'], 'wb') as fp: fp.write(data) print(dic['name'], '下载成功') if __name__ == '__main__': headers = { 'User-Agent':\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\" } url = 'https://www.pearvideo.com/category_5' page_text = requests.get(url=url, headers=headers).text soup = BeautifulSoup(page_text, 'lxml') li_urls = soup.select('.vervideo-bd') urls = []#存储所有视频的链接和名字 i = 1 for li in li_urls: try: i = i + 1 detail_url = 'https://www.pearvideo.com/' + li.a['href'] name = soup.select('.vervideo-title')[i].text+'.mp4' detail_page_text = requests.get(url=detail_url, headers=headers, timeout=0.5).text ex = 'srcUrl=\"(.*?)\",vdoUrl' video_url = re.findall(ex, detail_page_text)[0] dic = { 'name': name, 'url': video_url } urls.append(dic) except: continue pool = Pool(4) pool.map(get_video_data, urls) pool.close() pool.join() 总结： 1.windows环境下需要将主函数放在以下代码下方 if __name__ == '__main__': mac环境下不需要此操作 2.下载时下载二进制数据，使用’wb’而不是’w'。 3.如果下载视频过多(爬取大量数据)，网站要求验证证书，大量爬取需要使用其他方法应对ssl反爬策略。 ps：感谢csdn学院提供的案例支持 ","date":"2020-05-01","objectID":"/2020-05-01-%E7%88%AC%E8%99%AB12/:0:3","tags":["python","爬虫"],"title":"爬虫流程及方法12(高性能异步爬虫)","uri":"/2020-05-01-%E7%88%AC%E8%99%AB12/"},{"categories":["python","爬虫"],"content":"原网页链接萌新论坛 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:0","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"requests 伪装 headers 发送请求 headers中空着的可能有也可能无，user-agent基本得有 在chrome中找到网页的请求头，图片如下 headers = { \"Accept\": \" \", \"Accept-Encoding\": \" \", \"Accept-Language\": \" \", \"Host\": \" \", 'user-agent':'粘贴1处' } #在页面中点击右键选择检查，调出网页自带的抓包工具，打开Network后刷新当前页面抓包找到user-agent的项复制粘贴1 cookie的三种传参方法 headers = {\"User_Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\", \"Cookie\" : \" \", \"Refer\" : \" 从哪个网页来的(url)\" } #三种Cookie请求方式 '''第一种：cookie放在headers中''' headers = {\"User_Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\", \"Cookie\" : \" \" } '''第二种：cookie字典传给cookies参数''' '''第三种 先发送post请求，获取cookie，带上cookie请求登陆之后的页面''' # 如果没有的就要抓包了Network -\u003e preserve log -\u003e login包 -\u003erequesy seesion = requests.seesion() # 用户名作为键， 真正的密码作为值 模拟登陆 post_data = {\"email\":\"xxxx\", \"password\":\"xxxx\"} seesion.post(url=url, data=post_data, headers=headers) # 服务器设置在本地的cookie会保存在本地 seesion.get(url) # 会带上之前保存在seesion中的cookie，能够请求成功 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"requests 伪装 params 传输数据 params = { '某名字':'某值', '粘贴2': '黏贴2' } #在页面中点击右键选择检查，调出网页自带的抓包工具，打开Network后刷新当前页面抓包找到Query String Parameters的项复制粘贴2（记得加符号'粘贴2'） User-Agent：这里面存放浏览器的信息。可以看到上面的参数值，它表示我是通过Windows的Chrome浏览器，访问的这个服务器。如果我们不设置这个参数，用Python程序直接发送GET请求，服务器接受到的User-Agent信息就会是一个包含python字样的User-Agent。如果后台设计者验证这个User-Agent参数是否合法，不让带Python字样的User-Agent访问，这样就起到了反爬虫的作用。这是一个最简单的，最常用的反爬虫手段。 Referer：这个参数也可以用于反爬虫，它表示这个请求是从哪发出的。可以看到我们通过浏览器访问网站，这个请求是从哪个页面来的(那个页面包含该链接)，这个地址发出的。如果后台设计者，验证这个参数，对于不是从这个地址跳转过来的请求一律禁止访问，这样就也起到了反爬虫的作用。 ps: authorization：这个参数是基于AAA模型中的身份验证信息允许访问一种资源的行为。在我们用浏览器访问的时候，服务器会为访问者分配这个用户ID。如果后台设计者，验证这个参数，对于没有用户ID的请求一律禁止访问，这样就又起到了反爬虫的作用。 UserAgent伪装集合详见资源页面 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"selenium 模拟使用浏览器伪装 headers 使用自动化测试工具 selenium 可以模拟使用浏览器访问网站。使用的selenium版本大都支持 Chrome 和 Firefox 浏览器。要使用该库浏览器需要下载对应版本到电脑上。 使用 webdriver 访问本身自带浏览器的 headers。 import selenium import selenium.webdriver import ssl def get_url_text(url): driver = selenium.webdriver.Chrome()#模拟调用谷歌游览器（模拟你电脑有的游览器操作） driver.get(url)#访问链接 pagesource=driver.page_source#抓取网页源代码 #你要执行的预处理写这里 driver.close() return #返回值 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:3","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"ssl处理(仅针对使用urllib与urllib3) urllib库爬虫 import ssl context = ssl._create_unverified_context() #忽略安全 requests库爬虫 忽略ssl验证使得网页访问得以顺利通过 verify=False 代表不做证书验证 import requests from requests.packages import urllib3 urllib3.disable_warnings() #关闭警告 respone=requests.get('https://www.12306.cn',verify=False) print(respone.status_code) 不做证书验证的情况，在某些情况下是行不通的的，这需要其他处理方式 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:4","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"requests 使用 ip 代理发送请求 查询自己的ip，网址https://httpbin.org/ip import requests a = True while a: try: url = 'https://httpbin.org/ip' response = requests.get(url) print(response.text) except: print(\"爬取失败\") a = False 使用代理ip与伪装headers的方式相似,只需要传入proxies参数。 比如现在我有一个代理ip:111.164.20.86:8111，使用如下： import requests a = True while a: url = 'https://httpbin.org/ip' proxy = { 'http': '111.164.20.86:8111', } #或者填入https请求的'https': ' ' response = requests.get(url=url, proxies=proxy) print(response.text) #返回值是代理ip地址，更换url即可使用代理ip爬虫 a = False 支持socks代理,安装输入： pip install requests[socks] 实例： import requests proxies = { 'http': 'socks5://user:pass@host:port', 'https': 'socks5://user:pass@host:port' } respone=requests.get('https://www.12306.cn', proxies=proxies) print(respone.status_code) 如果没考虑好用http/https，建议两个都写入字典proxy里面，就不会报错 代理免费ip可能会时不时中断，建议淘宝购买(支持验证那种)，当然如果购买阿里云端口也是可以的 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:5","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"重复执行报错处理 import requests from retrying import retry #@retry(stop_max_attempt_number = 10) '''让被装饰的函数反复执行10次，10次全部报错才会报错， 中间有一次正常就继续往下走''' url = \"http://www.baidu.com\" response = requests.get(url,timeout=0.01)#timeout=0.01 代表请求+接收服务端数据的总时间 #如果想明确控制链接与等待接收服务端数据的时间则写 timeout=(1,2) #timeout=(1,2)---\u003e1代表链接超时时间 2代表接收数据的超时时间 print(response.content.decode()) headers = {\"User_Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\", } ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB10/:0:6","tags":["python","爬虫"],"title":"爬虫流程及方法10(爬虫伪装专题篇)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB10/"},{"categories":["python","爬虫"],"content":"前言 本篇鸣谢 清华——尹成 的整理收集 PyQuery文档https://www.osgeo.cn/pyquery/index.html PyQuery库也是一个非常强大又灵活的网页解析库，如果你有前端开发经验的，都应该接触过jQuery,那么PyQuery就是你非常绝佳的选择，PyQuery 是 Python 仿照 jQuery 的严格实现。语法与 jQuery 几乎完全相同，所以不用再去费心去记一些奇怪的方法了。 官网地址:http://pyquery.readthedocs.io/en/latest/ jQuery参考文档:http://jquery.cuishifeng.cn/ ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB11/:1:0","tags":["python","爬虫"],"title":"爬虫流程及方法11(PyQuery解析网页篇)(全)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB11/"},{"categories":["python","爬虫"],"content":"初始化 初始化的时候一般有三种传入方式：传入字符串，传入url,传入文件 字符串初始化 html = ''' \u003cdiv\u003e \u003cul\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) print(doc) print(type(doc)) print(doc('li')) 结果如下： 由于PyQuery写起来比较麻烦，所以我们导入的时候都会添加别名： from pyquery import PyQuery as pq 这里我们可以知道上述代码中的doc其实就是一个pyquery对象，我们可以通过doc可以进行元素的选择，其实这里就是一个css选择器，所以CSS选择器的规则都可以用，直接doc(标签名)就可以获取所有的该标签的内容，如果想要获取class 则doc('.class_name'),如果是id则doc('#id_name')…. URL初始化 from pyquery import PyQuery as pq doc = pq(url=\"http://www.baidu.com\",encoding='utf-8') print(doc('head')) 文件初始化 我们在pq()这里可以传入url参数也可以传入文件参数，当然这里的文件通常是一个html文件。 例如：pq(filename=‘index.html’) ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB11/:1:1","tags":["python","爬虫"],"title":"爬虫流程及方法11(PyQuery解析网页篇)(全)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB11/"},{"categories":["python","爬虫"],"content":"基本的CSS选择器 html = ''' \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) print(doc('#container .list li')) 这里我们需要注意的一个地方是doc('#container .list li')，这里的三者之间的并不是必须要挨着，只要是层级关系就可以,下面是常用的CSS选择器方法： ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB11/:1:2","tags":["python","爬虫"],"title":"爬虫流程及方法11(PyQuery解析网页篇)(全)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB11/"},{"categories":["python","爬虫"],"content":"查找元素 子元素 children,find 代码例子： html = ''' \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) items = doc('.list') print(type(items)) print(items) lis = items.find('li') print(type(lis)) print(lis) 运行结果如下 从结果里我们也可以看出通过pyquery找到结果其实还是一个pyquery对象，可以继续查找，上述中的代码中的items.find(‘li’) 则表示查找ul里的所有的li标签 当然这里通过children可以实现同样的效果,并且通过.children方法得到的结果也是一个pyquery对象 li = items.children() print(type(li)) print(li) 同时在children里也可以用CSS选择器 li2 = items.children('.active') print(li2) 父元素 parent,parents方法 通过.parent就可以找到父元素的内容，例子如下： html = ''' \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) items = doc('.list') container = items.parent() print(type(container)) print(container) 通过.parents就可以找到祖先节点的内容，例子如下： html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) items = doc('.list') parents = items.parents() print(type(parents)) print(parents) 结果如下： 从结果我们可以看出返回了两部分内容，一个是的父节点的信息，一个是父节点的父节点的信息即祖先节点的信息 同样我们通过.parents查找的时候也可以添加css选择器来进行内容的筛选 兄弟元素 siblings html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) li = doc('.list .item-0.active') print(li.siblings()) 代码中doc('.list .item-0.active') 中的.tem-0和.active是紧挨着的，所以表示是并的关系，这样满足条件的就剩下一个了：thired item的那个标签了 这样在通过.siblings就可以获取所有的兄弟标签，当然这里是不包括自己的 同样的在.siblings()里也是可以通过CSS选择器进行筛选 遍历 单个元素 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) li = doc('.item-0.active') print(li) lis = doc('li').items() print(type(lis)) for li in lis: print(type(li)) print(li) 运行结果如下： 从结果中我们可以看出通过items()可以得到一个生成器，并且我们通过for循环得到的每个元素依然是一个pyquery对象。 ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB11/:1:3","tags":["python","爬虫"],"title":"爬虫流程及方法11(PyQuery解析网页篇)(全)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB11/"},{"categories":["python","爬虫"],"content":"获取信息 获取属性 pyquery对象.attr(属性名) pyquery对象.attr.属性名 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) a = doc('.item-0.active a') print(a) print(a.attr('href')) print(a.attr.href) 所以这里我们也可以知道获得属性值的时候可以直接a.attr(属性名)或者a.attr.属性名 获取文本 在很多时候我们是需要获取被html标签包含的文本信息,通过.text()就可以获取文本信息 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) a = doc('.item-0.active a') print(a) print(a.text()) 结果如下： 获取html 我们通过.html()的方式可以获取当前标签所包含的html信息，例子如下 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) li = doc('.item-0.active') print(li) print(li.html()) 结果如下： ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB11/:1:4","tags":["python","爬虫"],"title":"爬虫流程及方法11(PyQuery解析网页篇)(全)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB11/"},{"categories":["python","爬虫"],"content":"DOM操作 addClass、removeClass 熟悉前端操作的话，通过这两个操作可以添加和删除属性 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) li = doc('.item-0.active') print(li) li.removeClass('active') print(li) li.addClass('active') print(li) attr,css 同样的我们可以通过attr给标签添加和修改属性， 如果之前没有该属性则是添加，如果有则是修改 我们也可以通过css添加一些css属性，这个时候，标签的属性里会多一个style属性 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) li = doc('.item-0.active') print(li) li.attr('name', 'link') print(li) li.css('font-size', '14px') print(li) 结果如下 remove 有时候我们获取文本信息的时候可能并列的会有一些其他标签干扰，这个时候通过remove就可以将无用的或者干扰的标签直接删除，从而方便操作 html = ''' \u003cdiv class=\"wrap\"\u003e Hello, World \u003cp\u003eThis is a paragraph.\u003c/p\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) wrap = doc('.wrap') print(wrap.text()) wrap.find('p').remove() print(wrap.text()) 结果如下： ","date":"2020-04-30","objectID":"/2020-04-30-%E7%88%AC%E8%99%AB11/:1:5","tags":["python","爬虫"],"title":"爬虫流程及方法11(PyQuery解析网页篇)(全)","uri":"/2020-04-30-%E7%88%AC%E8%99%AB11/"},{"categories":["python","爬虫"],"content":" import requests from bs4 import BeautifulSoup a = True while a: headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36' } params = { '_v': '5.12.0' } fp = open('./萌新论坛爬虫.text', 'w', encoding='utf-8') urls = 'http://www.lolichan.vip/' response = requests.get(url=urls, params=params, headers=headers).text soup = BeautifulSoup(response, 'lxml') class_list= soup.select('.node-title') for li in class_list: try: detail_url = 'http://www.lolichan.vip/' + li.a['href'] detail_page_text = requests.get(url=detail_url, params=params, headers=headers).text detail_soup = BeautifulSoup(detail_page_text, 'lxml') page_list = detail_soup.select('.structItem-title') print('抓取页面成功') except: page_list = '-----' for i in page_list: try: page_title = i.a.string page_url = 'http://www.lolichan.vip/' + i.a['href'] page_text = requests.get(url=page_url, headers=headers).text detail_soup = BeautifulSoup(page_text, 'lxml') div_tag = detail_soup.find('div', class_='bbWrapper') content = div_tag.text fp.write(page_title + ':' + content + '\\n') print('爬取页面成功') except: continue a = False ajax请求请参考爬虫流程及方法09(动态加载页面)(ajax请求)(Json实例) ","date":"2020-04-29","objectID":"/2020-04-29-%E7%88%AC%E8%99%AB08/:0:0","tags":["python","爬虫"],"title":"爬虫流程及方法08(BeautifulSoup实例)(非ajax请求)","uri":"/2020-04-29-%E7%88%AC%E8%99%AB08/"},{"categories":["python","爬虫"],"content":"动态加载数据ajax ","date":"2020-04-29","objectID":"/2020-04-29-%E7%88%AC%E8%99%AB09/:0:0","tags":["python","爬虫"],"title":"爬虫流程及方法09(动态加载页面)(ajax请求)(Json实例)","uri":"/2020-04-29-%E7%88%AC%E8%99%AB09/"},{"categories":["python","爬虫"],"content":"首页中对应企业数据通过ajax请求得到 详情页url只有id不同其余相同 id从json中获取，域名与id拼接新url 详情页的数据也是动态加载出来的 详情页的url也是相同的只有id不同 爬取的原网站药妆局 推荐使用chrome网页抓包工具查看请求类型 首页与详情页都使用post请求传输json数据包，需要json解析 import requests import json a = True while a: headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\" } #批量获取企业详情页对应id url = \"http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList\" id_list = [] # 存储企业id all_data_list = [] #参数封装 for page in range(1,6): data = { 'on': 'true', 'page': page, 'pageSize': ' 15', 'productName': '', 'conditionType': ' 1', 'applyname': '', 'applysn': '' } json_ids = requests.post(url=url, headers=headers,data=data).json() for i in json_ids['list']: id_list.append(i['ID']) # 存储所有企业详情数据 post_url = \"http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList\" for id in id_list: data = { 'id': id } detail_json = requests.post(url=post_url, headers=headers, data=data).json() all_data_list.append(detail_json) #持久化存储 fp = open('./alldata.json','w',encoding='utf-8') json.dump(all_data_list, fp=fp, ensure_ascii=False) print('over') a = False 总结：爬虫检查网页的传输方式，选择get请求还是post请求，注意是否为ajax请求，注意解析数据包的格式 ","date":"2020-04-29","objectID":"/2020-04-29-%E7%88%AC%E8%99%AB09/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法09(动态加载页面)(ajax请求)(Json实例)","uri":"/2020-04-29-%E7%88%AC%E8%99%AB09/"},{"categories":["博客建站相关"],"content":"1. 前言 本markdown文档初版下载链接： (建议看初版文档理解书写格式，书写标准以本网站本页面为主) https://pan.baidu.com/s/1z_2IsuaRh8cYmtssepvIXQ 提取码：0a83 本篇鸣谢胡国磊学长整理，由我进行加工发布 ","date":"2020-04-25","objectID":"/mdb/:1:0","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"2. 示例文章 橙心：终于等到你，公众号排版神器 姹紫：JavaScript 数据结构与算法之美 绿意：前端硬核面试专题之 CSS 55 问 红绯：日常 | 我用什么工具写作？ Wechat-Format：Markdown Nice 新特性：阿里云图床 科技蓝：2019 前端秋季社招面试经历总结（二年多经验） 效果及代码图如下: ","date":"2020-04-25","objectID":"/mdb/:2:0","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3 通用语法 ","date":"2020-04-25","objectID":"/mdb/:3:0","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.0 分割线 在markdown语法中,一行连用三个或者三个以上的星号,减号,或者下划线,就可以表示分割线。 例如:*** — __ 为方便记忆,只需记住三个减号\"—“可以表示分割线即可。 另外,分割线可以起到把分割线上下的内容分割成两个段落的作用。 ","date":"2020-04-25","objectID":"/mdb/:3:1","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.1 标题 在文字写书写不同数量的#可以完成不同的标题，一行开头打上不同数目的#最后在#末尾加上空格再书写标题内容，效果如下： 一级标题 ","date":"2020-04-25","objectID":"/mdb/:3:2","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"二级标题 ","date":"2020-04-25","objectID":"/mdb/:4:0","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"三级标题 ","date":"2020-04-25","objectID":"/mdb/:4:1","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.2 无序列表 无序列表的使用，在符号-后加空格使用。如下： 无序列表 1 无序列表 2 无序列表 3 如果要控制列表的层级，则需要在符号-前使用空格。如下： 无序列表 1 无序列表 2 无序列表 2.1 无序列表 2.2 ","date":"2020-04-25","objectID":"/mdb/:4:2","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.3 有序列表 有序列表的使用，在数字及符号.后加空格后再输入内容，如下： 有序列表 1 有序列表 2 有序列表 3 ","date":"2020-04-25","objectID":"/mdb/:4:3","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.4 引用 引用的格式是在符号\u003e后面书写文字。效果如下： 读一本好书，就是在和高尚的人谈话。 ——歌德 雇用制度对工人不利，但工人根本无力摆脱这个制度。 ——阮一峰 ","date":"2020-04-25","objectID":"/mdb/:4:4","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.5 粗体和斜体 粗体的使用是在需要加粗的文字前后各加两个*。 而斜体的使用则是在需要斜体的文字前后各加一个*。 如果要使用粗体和斜体，那么就是在需要操作的文字前后加三个*。效果如下： 这个是粗体 这个是斜体 这个是粗体加斜体 注：由于 commonmark 标准，可能会导致加粗与想象不一致，如下 **今天天气好晴朗，**处处好风光。 这个是正常现象，请参考加粗 Issue。 ","date":"2020-04-25","objectID":"/mdb/:4:5","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.6 链接 代码图： 效果如下： 文章链接你是《未来世界的幸存者》么？ ","date":"2020-04-25","objectID":"/mdb/:4:6","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.7 分割线 代码图： 可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。效果如下： ","date":"2020-04-25","objectID":"/mdb/:4:7","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.8 删除线 删除线的使用，在需要删除的文字前后各使用两个~，效果如下： 这是要被删除的内容。 ","date":"2020-04-25","objectID":"/mdb/:4:8","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.9 表格 可以使用冒号来定义表格的对齐方式，格式如下： 效果如下： 姓名 年龄 工作 小可爱 18 吃可爱多 小小勇敢 20 爬棵勇敢树 小小小机智 22 看一本机智书 ","date":"2020-04-25","objectID":"/mdb/:4:9","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"3.10 图片 插入图片，如果是行内图片则无图例，否则有图例，格式图如下： 效果如下： 支持 jpg、png、gif 等图片格式， 支持图片拖拽和截图粘贴到编辑器中上传，上传时使用当前选择的图床。 可使用格式-\u003e图片上传本地图片，网站仅支持「图壳」图床，失败率低可长久保存！ ","date":"2020-04-25","objectID":"/mdb/:4:10","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"4.1 代码块 如果在一个行内需要引用代码，只要用反引号引起来就好，如下： Use the printf() function. 在需要高亮的代码块的前一行及后一行使用三个反引号，同时第一行反引号后面表示代码块所使用的语言 格式图如下： 效果如下： // FileName: HelloWorld.java public class HelloWorld { // Java 入口程序，程序从此入口 public static void main(String[] args) { System.out.println(\"Hello,World!\"); // 向控制台打印一条语句 } } 支持以下语言种类： bash clojure，cpp，cs，css dart，dockerfile, diff erlang go，gradle，groovy haskell java，javascript，json，julia kotlin lisp，lua makefile，markdown，matlab objectivec perl，php，python r，ruby，rust scala，shell，sql，swift tex，typescript verilog，vhdl xml yaml 如果想要更换代码主题，可在上方挑选，不支持代码主题自定义。 ","date":"2020-04-25","objectID":"/mdb/:4:11","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"5 其他语法 ","date":"2020-04-25","objectID":"/mdb/:5:0","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"5.1 HTML 支持原生 HTML 语法，请写内联样式，格式图如下： 效果如下： 橙色居右 橙色居中 ","date":"2020-04-25","objectID":"/mdb/:5:1","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"5.2 UML 不支持，推荐使用开源工具https://draw.io/制作后再导入图片 ","date":"2020-04-25","objectID":"/mdb/:5:2","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"5.3 组件图床 组件目前共支持 3 种图床和 1 种自定义图床，主要特点如下： 图床 费用 有效期 失败率 SM.MS 免费 长期 高 阿里云 付费 自定义 低 七牛云 10G 免费 自定义 低 自定义 高昂 自定义 自定义 4 个图床的缺点： 图床 缺点 SM.MS 失败率高可用性很差 阿里云 配置繁琐，费用昂贵 七牛云 配置繁琐，需购买长期域名 自定义 搭建后台繁琐 这里我推荐我经常用的一个图源保存网站： https://pic.liesio.com/ ","date":"2020-04-25","objectID":"/mdb/:5:3","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"5.4 下拉列表(部分主题支持本格式) 代码如下 \u003cdetails\u003e \u003csummary\u003e展开查看\u003c/summary\u003e \u003cpre\u003e\u003ccode\u003e 内容 \u003c/code\u003e\u003c/pre\u003e \u003c/details\u003e 效果如下： \r展开查看\r\r内容\r\r\r","date":"2020-04-25","objectID":"/mdb/:5:4","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["博客建站相关"],"content":"5.5 更多文档 更多文档请参考 markdown-nice-docs ","date":"2020-04-25","objectID":"/mdb/:5:5","tags":["hugo"],"title":"撰写hugo博客的markdown格式","uri":"/mdb/"},{"categories":["python","爬虫"],"content":"Request类 class scrapy.http.Request() Request对象表示一个HTTP请求。 由Spider生成，由Downloader执行。 常用属性： ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"Response类 class scrapy.http.Response() Response对象表示一个HTTP响应。 由Downloader生成，由Spider处理。 常用属性与方法： ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"Item类 class scrapy.item.Item() Item对象表示一个从HTML页面中提取的信息内容。 由Spider生成，由Item Pipeline处理。 Item类似字典类型，可以按照字典类型操作。 ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:0:3","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"Scrapy爬虫支持多种HTML信息提取方法 Beautiful Soup lxml re XPath Selector CSS Selector CSS Selector的基本形式: ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:0:4","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"步骤 步骤1:建立工程和Spider模板 步骤2:编写Spider(实际爬虫) 步骤3:编写ITEM Pipelines(爬虫数据处理) 步骤3:编写Pipelines: 配置pipelines.py文件 定义对爬取项(Scraped Item)的处理类 配置ITEM PIPELINES选项(配置setting.py文件) ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:0:5","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"PS：以下代码仅供参考，不具备运行基础 #工程文档为以下内容 import scrapy import re class StocksSpider (scrapy . Spider) : name = \"stock s\" start_urls = ['http://quote.eastmoney.com/stocklist.html'] def parse(self, response): for href in response.css ('a: :attr (href) ').extract(): try: stock = re.findall(r\"[s][hz]\\d{6}\", href)[0] url = 'https://gupiao.baidu.com/stock/' + stock + '.html' yield scrapy.Request(url, callback=self.parse_stock) except: continue def parse_stock(self, response): infoDict = { } stockInfo = response.css('.stock-bets') name = stockInfo.css('.bets-name').extract()[0] keyList = stockInfo.css('dt').extract() valueList = stockInfo.css('dd').extract() for i in range(len(keyList)): key = re.findall(r'\u003e.*\u003c/dt\u003e', keyList[i])[0][1:-5] try: val = re.findall(r'\\d+\\.?.*\u003c/dd\u003e', valueList[1])[0][0:-5] except: val = '----' infoDict[key] = val infoDict.update({'股票名称': re.findall('\\s.*\\(', name)[0].split()[0] + re.findall('\\\u003e.*\\\u003c', name)[0][1:-1]}) yield infoDict #pipeline文档下的内容 class BaidustocksPipeline(object): def process_item(self, item, spider): return item class BaidustocksInfoPipeline(object): def open_spider(self, spider): self.f = open('BaidustockInfo.txt', 'W') def close_spider(self, spider): self.f.close() def process_item(self, item, spider): try: line = str(dict(item)) + '\\n' self.f.write(line) except: pass return item ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:1:0","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"总结： 技术路线： requests-bs4-re scrapy(5+2结构) scrapy + requests-bs4-re + PhantomJS —\u003e表单提交、爬取周期、入库存储(js处理) ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB05/:1:1","tags":["python","爬虫"],"title":"爬虫流程及方法05(Scrapy入门级爬虫)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB05/"},{"categories":["python","爬虫"],"content":"提高爬取速度的方法 1.在setting.py文件里修改并发选项 2.使用scrapy-*的高级补充库，特化某方面，提升速度 3.选择合适的技术路线进行爬虫 ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB06/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法06(Scrapy进阶爬虫)(实时更新)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB06/"},{"categories":["python","爬虫"],"content":"技术路线 1.requests-BeautifulSoup 2.scrapy(5+2结构) 3.scrapy + requests-Beautiful-re + PhantomJS —\u003e表单提交、爬取周期、入库存储(js处理) 4.requests-xpath 5.requests-ccs 6.requests库可与urllib库互换 ","date":"2020-04-19","objectID":"/2020-04-19-%E7%88%AC%E8%99%AB07/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法07(爬虫技术路线整理)(实时更新)","uri":"/2020-04-19-%E7%88%AC%E8%99%AB07/"},{"categories":["python","爬虫"],"content":"安装scrapy pycharm安装步骤: 1.打开左上角file 2.打开Other Setting下的Setting for New Project 3.在Project Interpreter选择Project Interpreter里你使用的编译器后，点击加号(+)添加包 4.修改Manage Repositories(参考第三方下载包修改篇) 5.在搜索框里搜索以下包名xxx(注意字母大小写不同) Scrapy Twisted pywin32 wheel 6.在terminal窗口输入scrapy确认出现版本信息及命令提示 ","date":"2020-04-17","objectID":"/2020-04-17-%E7%88%AC%E8%99%AB04/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法04(Scrapy框架)","uri":"/2020-04-17-%E7%88%AC%E8%99%AB04/"},{"categories":["python","爬虫"],"content":"step1: 建立工程文档 终端terminal输入： scrapy startproject 工程文档名 创建得到的文档结构： 工程文档名/ -----\u003e外层目录\rscrapy.cfg -----\u003e部署scrapy爬虫的配置文件\r工程文档名/ ----\u003escrapy框架的用户自定义的python代码\r_init_.py -----\u003e初始化脚本\ritems.py -----\u003eitems代码模块（继承类）\rmiddlewares.py -----\u003emiddlewares代码模块（继承类）\rpipelines.py ------\u003epipelines代码模板（继承类）\rsetting.py ------\u003escrapy爬虫的配置文件\rspiders/ ------\u003e代码模板目录(继承类)\r ","date":"2020-04-17","objectID":"/2020-04-17-%E7%88%AC%E8%99%AB04/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法04(Scrapy框架)","uri":"/2020-04-17-%E7%88%AC%E8%99%AB04/"},{"categories":["python","爬虫"],"content":"step2: 产生爬虫 终端terminal输入：(cmd内或pycharm里面的terminal) cd 工程文档名 scrapy genspider demo 爬取页面的url 或者： 直接在含spider的目录下新建demo.py文件 写入以下代码 import scrapy class DemoSpider(scrapy.Spider): name = \"demo\" allowed_domain = [\"python123.io\"]#爬取该域名下的链接 start_urls = ['https://python123.io/']#爬取页面的初始页面 def parse(self, response):#解析页面方法类，形成字典类型或发现新链接 pass ","date":"2020-04-17","objectID":"/2020-04-17-%E7%88%AC%E8%99%AB04/:0:3","tags":["python","爬虫"],"title":"爬虫流程及方法04(Scrapy框架)","uri":"/2020-04-17-%E7%88%AC%E8%99%AB04/"},{"categories":["python","爬虫"],"content":"step3: 配置产生的spider爬虫(具体修改demo文件) eg： def parse(self, response): fname = response.url.split('/')[-1] with open(fname, 'wb') as f: f.write(response.body) self.log('Saved file %s.' % fname) ","date":"2020-04-17","objectID":"/2020-04-17-%E7%88%AC%E8%99%AB04/:0:4","tags":["python","爬虫"],"title":"爬虫流程及方法04(Scrapy框架)","uri":"/2020-04-17-%E7%88%AC%E8%99%AB04/"},{"categories":["python","爬虫"],"content":"step4: 终端terminal运行： 输入以下代码 scrapy crawl 文件名 eg：scrapy crawl demo ps:(爬虫的另一种框架) import scrapy: class DemoSpider(scrapy.Spider): name = \"demo\" def start requests(se1f): urls = [ 'http://python123.io/ws/demo.html ' ] for url in urls: yield scrapy.Request(ur1=ur1,callback=self.parse) def parse(self,response): fname = response.url.split('/')[-1] with open (fname,'wb') as f: f. write (response.body) self.log('Saved file %s.' % fname) yield关键字 yield —-\u003e生成器 优势：占用存储少，响应速度快 生成器是一个不断产生值的函数，包含yield语句的函数是一个生成器 生成器每次产生一个值(yield语句)，函数被冻结，被唤醒后再产生一个值。 生成器写法 def gen(n): for i in range(n): yield i**2 for 1 in gen(5): print(1,\" \",end=\"\") 结果 \u003e\u003e\u003e0 1 4 9 16 一般写法 def square(n) : ls =[i**2 for i in range (n) ] return ls for i in square (5) : print(i,\" \",end=\"\") 结果 \u003e\u003e\u003e0 1 4 9 16 ","date":"2020-04-17","objectID":"/2020-04-17-%E7%88%AC%E8%99%AB04/:0:5","tags":["python","爬虫"],"title":"爬虫流程及方法04(Scrapy框架)","uri":"/2020-04-17-%E7%88%AC%E8%99%AB04/"},{"categories":["电脑技巧"],"content":"个人收集，网站有可能不安全 ","date":"2020-04-12","objectID":"/baidu/:1:0","tags":["windows"],"title":"百度云盘加速","uri":"/baidu/"},{"categories":["电脑技巧"],"content":"建议浏览器隐私模式下使用，避免用户信息被盗窃 该页面下载共享提取码： QLHL 该页面解析地址由个人收集，替代网页插件版的直链解析，原理是pandownload的网页版，需要百度云盘的文件共享链接。 解析后的直链用idm下载即可跑满网速，idm下载地址：点我跳转下载页面 下面这个下载包含IDM和解析页面使用教程(教程的解析用的插件，可以用该网页的解析页面代替) IDM教程与配套软件 ↑↑↑看在资源的份上，麻烦点赞投币收藏我的文章—\u003ehttps://www.bilibili.com/read/cv6826074↑↑↑ 下面是解析网站，点击后会跳转到自动解析页面，后续步骤请按提示操作 ","date":"2020-04-12","objectID":"/baidu/:2:0","tags":["windows"],"title":"百度云盘加速","uri":"/baidu/"},{"categories":["电脑技巧"],"content":"个人推荐前五个 ","date":"2020-04-12","objectID":"/baidu/:3:0","tags":["windows"],"title":"百度云盘加速","uri":"/baidu/"},{"categories":["电脑技巧"],"content":"后面的安全性未知，可能会盗取信息 高速解析，同一ip每日三次解析机会 普通解析，每个IP每天一次免费解析，解析后的下载地址会在数据库中保存8小时，在8小时内再次解析不消耗次数 普通解析，不限次数 ↑↑↑账户密码都是hostloc https://betterman.xyz/wp/ 密码：bettermanxyz https://betterman.xyz/pan/ 密码：bettermanxyz666 普通解析(盗版搭建)01，安全性未知 普通解析(盗版搭建)02，安全性未知 普通解析(盗版搭建)03，安全性未知 普通解析(盗版搭建)04，安全性未知 普通解析(盗版搭建)05，危险性高 普通解析(盗版搭建)06，危险性高 ","date":"2020-04-12","objectID":"/baidu/:4:0","tags":["windows"],"title":"百度云盘加速","uri":"/baidu/"},{"categories":["电脑技巧"],"content":"后言 上述链接失效，请在-\u003e我的文章评论区\u003c-里留言，我会及时更新解析地址。(2021.6开始上述网址已过期，剩下下面几个) 自己搭的直链解析，如果有会员欢迎联系我捐赠进行高速解析：百度云盘直链解析站点。 解析密码：spiritlhl 不安全的解析： 不安全站点1 恶意篡改后台并加密 不安全站点2 此网站盗用其他网站的接口获取下载地址 建议支持正版。 正版web解析的作者不做演示站点 正版的仓库链接如下 https://github.com/yuantuo666/baiduwp-php 可以按照作者仓库自己搭建个人版Pandownload网页版。 2021.4.17新增天翼云盘不限速解析 站点1 站点2 站点3 该页面的资源均由网络收集。 本人不负任何法律责任，仅作为个人学习使用。 ","date":"2020-04-12","objectID":"/baidu/:5:0","tags":["windows"],"title":"百度云盘加速","uri":"/baidu/"},{"categories":["博客建站相关"],"content":"本地搭建博客 创建新文章 hugo new 你的文档名/你的文章名.md ","date":"2020-04-11","objectID":"/hugogitee/:0:0","tags":["hugo"],"title":"hugo博客部署码云","uri":"/hugogitee/"},{"categories":["博客建站相关"],"content":"在码云中创建库 1.链接一定是：/(填你的用户名) 2.选择公开/私有都行 3.注意不要初始化库(三个选项都不要选) 4.创建库 5.复制库链接(https类型) ","date":"2020-04-11","objectID":"/hugogitee/:0:1","tags":["hugo"],"title":"hugo博客部署码云","uri":"/hugogitee/"},{"categories":["博客建站相关"],"content":"部署到云端 1.在config.toml中改参数:baseURL = “https://你的用户名.gitee.io” 2.生成public: (初始化你的博客) 打开文件根目录的cmd或git bash here输入 hugo --theme=你的主题 3.进入public的文档，在该文档下打开git bash here 4.相继输入以下代码： git init git add . git commit -m \"first commit\" git remote add origin (https://gitee.com/......)(刚才复制的网址填这里) (假如是我就会填入https://gitee.com/spiritlhl/spiritLHL.git) git push -u origin master (无响应则再次运行同一代码) 5.进入之前你创建的库所在页面，刷新 6.鼠标打开服务，选择Gitee Pages，点击进入 7.选择强制使用HTTPS 8.启用服务 9.等待你的博客链接创建出来 你的博客:https://你的用户名.gitee.io/ 假如是我的博客:https://spiritlhl.gitee.io/ ","date":"2020-04-11","objectID":"/hugogitee/:0:2","tags":["hugo"],"title":"hugo博客部署码云","uri":"/hugogitee/"},{"categories":["博客建站相关"],"content":"注意，你的每一次提交都需要在Gitee Pages中手动更新，自动更新需要购买，这一点上我推荐使用Github ","date":"2020-04-11","objectID":"/hugogitee/:1:0","tags":["hugo"],"title":"hugo博客部署码云","uri":"/hugogitee/"},{"categories":["博客建站相关"],"content":"Github只需要你上传就自动更新页面了，免费给你使用该功能 欢迎访问 10分钟教你简单搭建个人博客hugo篇 8分钟教你简单部署hugo博客到码云gitee–含github博客转码云gitee的方法 里面有我搭建博客和部署云端的流程及效果。 ","date":"2020-04-11","objectID":"/hugogitee/:2:0","tags":["hugo"],"title":"hugo博客部署码云","uri":"/hugogitee/"},{"categories":["Python"],"content":"教计算机识别手写数字 (转载自YouTube) 人工神经网络是在现代神经科学的基础上提出和发展起来的，旨在反映人脑结构及功能的一种抽象数学模型。自1943 年美国心理学家 W. McCulloch 和数学家 W. Pitts 提 出形式神经元的抽象数学模型—MP 模型以来，人工神经网络理论技术经过了 50 多年 曲折的发展。特别是 20 世纪 80 年代，人工神经网络的研究取得了重大进展，有关的理论和方法已经发展成一门界于物理学、数学、计算机科学和神经生物学之间的交叉学科。希望阅读本篇，能使你对神经网络有一个大概的了解，明白其大概的工作原理。 神经网络之名来源自人的大脑结构。为什么叫做神经网络？我们来剖析一下，它的神经元是什么，神经元又是如何链接起来的，相信你就能得到答案了。目前说到神经元，我希望你把它暂时理解成一个用来装数字的容器，装着一个0到1之间的数字，仅此而已。 看这个例子，这个网络一开始的地方有很多神经元，分别对应了28×28的输入图像里的每一个像素，总计784个神经元，神经元中装着的数字代表对应像素的灰度值，0表示纯黑橡素，1表示纯白像素，我们把神经元里装着的数叫做“激活值”。你可以想象这么一个画面，激活值越大，神经元就点着越亮。那么这些784个神经元就组成了网络的第一层，现在我们跳到网络的最后一层，这一层的十个神经元分别代表0到9这十个数字，它们的激活值，同理都处在0到1之间，这些值表示系统认为输入的图像对应着哪个数字的可能性，网络中还有几层“隐含层”，暂时我们就把它看作一个大黑箱，里面就进行着处理识别数字的具体工作。 这个网络中，我选择加两层隐含层，每层有16个神经元，但其实这些设置都是随便选的，结构选择两层的原因在后续的介绍中我会解释，而选择16个神经元无非是显得好看罢了。(ಡωಡ)实际应用中，在网络结构上，我们有很大的调整实验的余地。 在神经网络的实验中，上一层的激活值将决定下一层的激活值。所以说，神经网络处理信息的核心机制正是一层激活值是通过怎样的运算算出下一层的激活值的。某种程度上讲，它想模仿的是生物神经元组成的网络。某些神经元的激发，就会促使另一些神经元激发。如果这个神经元网络被训练成熟，你在网络输入层的784个神经元处，输入了784个代表图像像素的灰度值。那么，随着一层层神经元的激活，会产生某些特殊的图案，最终在输出层得到某种结果。那我们首先要讨论的是：我们到底希望这些中间层最好能做什么呢？ 当我们人类在识别数字的时候，我们其实是在组合数字的各个部件。 在理想的情况下，我们希望倒数第二层的各个神经元能分别对应上一个笔画部件。这样一来，当我们输入一个9或8这种带圈数字时，某个神经元的激活值就会接近于1，而且我兵部特指某种样子的圈，我是希望所有这种位于图像顶部的圆圈图案都能点亮这个神经元。这样一来，从第三层到最后一层，我们只需要学习哪些部件能组合出哪个数字即可。当然，这样一来我们就引来了更多的问题。例如，要如何识别这些部件？其实，识别圆圈还可以细分成很多部分： 于是我们希望在网络第二层的各个神经元就能对应上这些各种各样的短边，没准当这样的图像输入进来的时候，它就能把所有关联的八到十个神经元都给点亮，接着就能点亮对应顶部圆圈和长竖条的神经元，最后就能点亮对应9字的神经元👇👇👇👇👇👇👇👇👇👇 至于我们的网络是否真的能做到这一步，需要我们对网络进行训练，但这就是我们的希望，希望这种层状结构能完成的目标。更进一步的讲，假如神经网络真能识别出这类边缘和图案，它就能更好的运用到其他的图像识别上来。 甚至不光是图像识别，世界上各种人工智能的任务，都可以转化为抽象元素，一层层的抽丝剥茧，就比如语言识别，就是要从原音频中识别出特殊的声音，组合成特定的音节，组合成单词，再组合成短语，以及更抽象的概念。回到神经网络工作原理上来，试想一下，你要设计上一层中的激活值到底如何决定下一层中的激活值。我们需要设计一个机制，可以把像素拼成短边，把短边拼成图案，或把图案拼成数字等等。在这个例子里，我们来放大关注其中的一个。我们来设计，让第二层中的这一个神经元能够正确识别出图像的这快区域里是否存在一条边。 现在我们就需要知道这个网络的参数，以及如何调整网络上的旋钮开关，才能让它足以表示出特殊的图案。我们需要给这个神经元和第一层所有神经元间的每一条接线都赋上一个权重值，这些权重都不过是数字数字而已。 然后，我们拿起第一层所有的激活值值和它们对应的权重值一起，算出它们的加权和。 我觉得把这些权重值做成一个表格更好理解，让我们把正的权重标记为绿色，负的标记成红色，颜色越暗，就大致表示它的权重越接近于0。现在我们把关注区域的权重赋为正值，而其他所有的权重一律赋为0，这样一来，对所有的像素取加权和，就只会累加我们关注区域的像素值了。此时如果你真的想识别出这里是否存在一条边，你只需要给周围一圈的像素赋予负的权重。这样，当中间的像素量，周围的像素暗时，加权和就能达到最大。 这样计算出来的加权和可以是任意大小，但在这个网络中，我们需要激活值处在0与1之间。那么，我们就可以顺其自然把这个加权和输入进某个函数，把这条实数轴挤压进0到1的区间内，其中一个叫sigmoid的函数非常常用，它又叫logistic/逻辑斯蒂曲线。 简而言之，它能把非常大的负值变成接近0，非常大的正值变成接近于1，而在取值0附近则是平稳增长的。 所以这个神经元中的激活值，实际上就是对加权和到底有多正的打分。但有时候，即使加权和大于0时，你也不想把神经元点亮，可能只有当和大于例如10的时候才让它激发。此时，你就需要加上一个偏置值·，保证不能随便激发。（当加权值大于10时，激发才有意义，过早激发会出现偏差）而我们只需要在加权和之后加上一个负10之类的数，再把它送进sigmoid函数即可，这个附加的数就叫偏置。总而言之，权重告诉你这个第二层的神经元关注什么样的像素图案，偏置告诉你加权和得有多大，才能让神经元的激发变得有意义。我们这就解说完了其中一个神经元，但这每一层的每一个神经元，都会和第一层全部的784个神经元相连接，每个神经元各带784个权重，而且每一个神经元都会在计算自己的加权后加上自己的偏置，再通过sigmoid压缩输出自己的结果。 这一下子要考虑的东西就多了起来，这层隐含层的16个神经元，就需要总计784×16个权重值和16个偏置值，而且这还是单单第一层和第二层之间的连接，别的层之间还有它们分别自带的权重和偏置，一整套下来整个网络一共会用上将近13000个权重加偏置，相当于这个网络上有将近13000多个旋钮开关让你调整，从而带来不一样的结果。所以当我们讨论机器如何学习的时候，我们其实在讲，电脑应该如何设置这一大坨数字参数，才能让它正确地解决问题。这里有一个细思极恐的###思想实验，想象一下你自己手动调整这些权重还有偏置参数，让第二层识别短边，第三层识别图案。 思想实验2 比起把网络完全当作一个黑箱，我个人觉得这么考虑更加令人满意，毕竟当网络的输出和期望出了偏差的时候，如果你一定程度上了解了这些权重和偏置的意义，那么你再尝试对结构进行修正就有出发点了。或许你的神经网络能输出正确的结果，但过程和你想象的不一样，那么深挖权重和偏置的实际意义，就可能对你的假设提出挑战（即使正确工作，也要追究缘由，进而探索出所有可能的解决方案。） 让我们把某一层中所有的激活值统一成一列向量，再把它和下一层检索有的权重放到一个矩阵中，矩阵第n行就是这一层的所有神经元和下一层第n个神经元间所有的连线的权重，这样权重和向量乘积的第n项就是这一层所有的激活值和下一层第n个神经元间连线权重的加权和。 表达偏置值的时候，我们并不会把一个个值都拎出来单独讨论。相反，我们会把它们都放到一个向量里然后和它们之前的矩阵乘法相加。最后一步，我们把整个表达式用一个sigmoid包起来。所谓包起来就是指对表达式结果向量中的每一项都取一次sigmoid。 现在，只要我们一写下权重矩阵和相应向量的符号，神经网络各层之间激活值的转化就可以表达得清晰简明明了了。 这种表达也让我们写程序变得简便了许多，因为很多库在矩阵乘法方面做了十足的优化。 还记得之前，我叫你把神经元看作数字的容器吗？实际上，神经元中装着的值是取决于你的输入图像的，所以我们把神经元看作一个函数才更加准确， 它的输入是上层所有的神经元的输出，它的输出是一个0到1之间的值。其实整个神经网络就是一个函数，一个输入784个值，输出10个值的函数。不过这个函数极其复杂，使用了13000个权重参数偏置参数来识别特定的图案，又要循环不停地用到矩阵乘法和sigmoid映射运算，但它终究是个函数而已，而且它的复杂程度可以稍微让人安点心。如果它没有那么复杂的话，我们恐怕就不大能指望它数字识别能有多准了。说到这里，你明白神经网络是怎么运算了吗？ 狮子图片来自Kevin Pluck 参考文献： [1]Seltzer, Michael L.,Droppo, Jasha. Multi-task learning in deep neural networks for improved phoneme recognition[P]. ,2013. [2]Jeff Heaton. Ian Goodfellow, Yoshua Bengio, and Aaron Courville: Deep learning[J]. Genetic Programming and Evolvable Machines,2018,19(1-2). （本篇鸣谢3Blue1Brown的图文支持） ","date":"2020-04-09","objectID":"/shendu/:0:0","tags":["Python","神经网络"],"title":"深度学习之神经网络","uri":"/shendu/"},{"categories":["博客建站相关"],"content":"本地搭建博客 创建新文章 hugo new 你的文档名/你的文章名.md 创建库 1.名称一定是：你的用户名.github.io 2.选择本地存储复制 部署到云端 1.在config.toml中改参数 2.生成public: 打开文件根目录的cmd或git bash here输入 hugo 3.进入public 4.在该页面下打开git bash here 5.相继输入以下代码 git init git add -A git commit -am\"init\" git remote add origin https://github.com/你的用户名/你的用户名.github.io.git （假如是我：git remote add origin https://github.com/spiritLHL/spiritLHL.github.io.git） git push -f origin master （无响应则再次运行同一代码，最多两次） 你的博客:https://你的用户名.github.io/ 假如是我的博客：https://spiritLHL.github.io/ 欢迎访问 10分钟教你简单搭建个人博客hugo篇 10分钟教你简单部署hugo博客(github篇) 里面有我搭建博客和部署云端的流程及效果。 下载资源链接: https://pan.baidu.com/s/1As27iCyZ5-q3QvgOE4zdPw 提取码：f34x 注意 如果要绑定第三方域名给github-pages，每次更新博客都需要重新绑定！ ","date":"2020-04-04","objectID":"/hugogithub/:0:0","tags":["hugo"],"title":"hugo博客在GitHub上进行部署","uri":"/hugogithub/"},{"categories":["python","爬虫"],"content":" #!/usr/bin/env python3 #本篇介绍抓取含搜索引擎的爬虫 #UA检测：门户网站检测对应请求的身份标识 #UA：useragent（请求载体的身份标识） #UA伪装：伪装游览器 import requests a = True while a: # UA伪装：伪装游览器,将对应user-agent封装到字典headers中 headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36' }#这里可以使用各种headers，包括ios或者安卓，模拟手机或平板登录 url = \"https://www.sogou.com/web?\" kw = input('key words:')#输入搜索所需要的关键词 # step1:处理url携带的参数：封装到字典中 param = { 'query': kw } res = requests.get(url=url, params=param, headers=headers)#几乎所有大型搜索引擎都是get请求，若属于某些私密的网址搜索可能需要post请求等加密传输方式 # 对指定url发起的请求对应的url是带参数的，请求过程中处理了参数 page_text = res.text #text处理数据 filename = kw + '.html'#命名文件 with open(filename,'w',encoding='utf-8') as fp: #该语法自动创建文件并自动打开关闭文件，需要注意的是该文件在本爬虫文件所在文档内，需要更精确的存储位置推荐使用os库 fp.write(page_text)#输入数据 print(filename, '保存成功') a = False ","date":"2020-04-01","objectID":"/2020-04-01-%E7%88%AC%E8%99%AB03/:0:0","tags":["python","爬虫"],"title":"爬虫流程及方法03(搜索引擎爬取)","uri":"/2020-04-01-%E7%88%AC%E8%99%AB03/"},{"categories":["python","爬虫"],"content":" #!/usr/bin/env python3 #对某论坛的爬取 import requests from bs4 import BeautifulSoup import time #需求：爬取网站标题及详情页的文本 a = True while a:#可转变成实时循环#对首页的页面数据进行爬取 url = \"https://www.lolichan.vip/\" headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36' } page_text = requests.get(url=url, headers=headers).text#获取响应数据得加text，不然获取的是响应对象 #在首页中解析出章节标题和详情页URL #1.实例化BeautifulSoup对象，需要将页面源码加载到该对象中 soup = BeautifulSoup(page_text, 'lxml') #解析章节标题与详情页url div_list = soup.select('.node-body \u003e div \u003e h3 \u003e a')#使用select层级选择器 fp = open('./xiangqing.text','w',encoding='utf-8')#创建文档及设定只写w和编码utf-8 for div in div_list: time.sleep(填入休息时间)#防止频繁的请求链接失去响应 title = div.string#获得该标签下的所有文本 detail_url = 'https://www.lolichan.vip/' + div['href']#获得详情页的url #对详情页发起请求，解析出章节内容 detail_page_text = requests.get(url=detail_url, headers=headers).text #解析出详情页中相关的章节内容 detail_soup = BeautifulSoup(detail_page_text,'lxml') div_tag = detail_soup.select('.structItem-title \u003e a') #原来的class属性得用class_表示，不然会报错（class是保留字） content = []#设定空列表 for a in div_tag: content.append(a.text)#往空列表内装填 fp.write(title+':'+str(content)+'\\n')#str()使content对象变为字符串形式 print(title, '爬取成功')#响应成功 a = False #号符号是python注释的前置符号 pycharm的热键： ctrl+z 键回撤你的对代码的改动 ctrl+/键注释与代码的转换 ctrl+c复制 ctrl+v粘贴 #!/usr/bin/env python3 soup.tagName print(soup.meta)#第一组a标签 soup.tagName返回的是html中第一次出现的tagName标签 #!/usr/bin/env python3 soup.find print(soup.find('meta'))=print(soup.meta) 属性定位,定位一定class加空格再= #属性可以是class 或id 或attr\r #!/usr/bin/env python3 print(soup.find('div', class = 'song')) #!/usr/bin/env python3 soup.find_all('tagName') 找到符合标准的所有标签,返回一个列表 #!/usr/bin/env python3 print(soup.find_all('meta')) #!/usr/bin/env python3 select('某种选择器'). 表示class类选择器 id选择器 标签选择器 返回的是一个列表 #!/usr/bin/env python3 soup.select('xx \u003e xx xx') 或 #!/usr/bin/env python3 soup.select('xx \u003e xx \u003e xx') #!/usr/bin/env python3 print(soup.select('.tang'))#\u003cdiv class='tang'\u003e 部分html代码 \u003cdiv class='tang'\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"http://....\" title=\"qingming\"\u003emutongyao\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"http://....\" title=\"chunjie\"\u003e...\u003c/a\u003e\u003c/li\u003e \u003cul\u003e print(soup.select('.tang \u003e ul \u003e li \u003e a')) 结果： \u003ca href=\"http://....\" title=\"qingming\"\u003e...\u003c/a\u003e， \u003ca href=\"http://....\" title=\"chunjie\"\u003e...\u003c/a\u003e 层级选择器：此时返回一个列表，此时'.class的内容 \u003e ul \u003e li \u003e a’中大于号\u003e表示一个层级 #!/usr/bin/env python3 print(soup.select('.tang \u003e ul \u003e li \u003e a')[0]) #结果：\u003ca href=\"http://....\" title=\"qingming\"\u003emutongyao\u003c/a\u003e #多个层级'.tang \u003e ul a' 这里空格表示多个层级，大于号\u003e表示一个层级 #!/usr/bin/env python3 print(soup.select('.tang \u003e ul \u003e li \u003e a')[0])=print(soup.select('.tang \u003e ul a')[0]) 获取标签之间的文本数据 #!/usr/bin/env python3 soup.a.text/string/get_text() print(soup.select('. class的内容\u003e ul a')[0].text) 结果： mutongyao #!/usr/bin/env python3 text/get_text() get_text()可以获取一个标签中‘所有的’文本内容（即使不属于该标签直系文本内容） string:只可以获得该标签下直系文本内容 获取标签中的属性值 #!/usr/bin/env python3 print(soup.select('.class的内容 \u003e ul a')[0]['href']) ","date":"2020-03-31","objectID":"/2020-03-31-%E7%88%AC%E8%99%AB02/:0:0","tags":["python","爬虫"],"title":"爬虫流程及方法02(Beautiful Soup解析页面)","uri":"/2020-03-31-%E7%88%AC%E8%99%AB02/"},{"categories":["python","爬虫"],"content":"下行遍历（这里两个方法必须是循环中使用） #!/usr/bin/env python3 for child in soup.body.children: print(child) 遍历儿子节点 #!/usr/bin/env python3 for child in soup.body.descendants: print(child) 遍历子孙节点 ","date":"2020-03-31","objectID":"/2020-03-31-%E7%88%AC%E8%99%AB02/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法02(Beautiful Soup解析页面)","uri":"/2020-03-31-%E7%88%AC%E8%99%AB02/"},{"categories":["python","爬虫"],"content":"上行遍历 #!/usr/bin/env python3 for sibling in soup.a.next_siblings: print(sibling) 遍历后续节点 #!/usr/bin/env python3 for sibling in soup.a.previous_siblings: print(sibling) 遍历前续节点 soup.prettify() 每个节点一个换行符 \u003c\u003e .find_all(name, attrs, recursive, string, **kwargs） 返回一个列表类型，存储查找的结果。 name:对标签名称的检索字符串。 attrs:对标签属性值的检索字符串，可标注属性检索。 recursive:是否对子孙全部检索，默认True。 string: \u003c\u003e…\u003c/\u003e中字符串区域的检索字符串。 ","date":"2020-03-31","objectID":"/2020-03-31-%E7%88%AC%E8%99%AB02/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法02(Beautiful Soup解析页面)","uri":"/2020-03-31-%E7%88%AC%E8%99%AB02/"},{"categories":["python","爬虫"],"content":"爬虫究竟是合法还是违法的? 在法律中是不被禁止 具有违法风险 请善意爬虫 切勿恶意爬虫 ","date":"2020-03-20","objectID":"/2020-03-20-%E7%88%AC%E8%99%AB01/:0:1","tags":["python","爬虫"],"title":"爬虫流程及方法01(入门准备及Request库使用)","uri":"/2020-03-20-%E7%88%AC%E8%99%AB01/"},{"categories":["python","爬虫"],"content":"爬虫带来的风险可以体现在如下2方面: 爬虫干扰了被访问网站的正常运营 爬虫抓取了受到法律保护的特定类型的数据或信息 ","date":"2020-03-20","objectID":"/2020-03-20-%E7%88%AC%E8%99%AB01/:0:2","tags":["python","爬虫"],"title":"爬虫流程及方法01(入门准备及Request库使用)","uri":"/2020-03-20-%E7%88%AC%E8%99%AB01/"},{"categories":["python","爬虫"],"content":"如何在使用编写爬虫的过程中避免进入局子的厄运呢? 时常的优化自己的程序，避免干扰被访问网站的正常运行 在使用传播爬取到的数据时，审查抓取到的内容，如果发现了涉及到用户的商业机密等敏感内容需要及时停止爬取或传播 ","date":"2020-03-20","objectID":"/2020-03-20-%E7%88%AC%E8%99%AB01/:0:3","tags":["python","爬虫"],"title":"爬虫流程及方法01(入门准备及Request库使用)","uri":"/2020-03-20-%E7%88%AC%E8%99%AB01/"},{"categories":["python","爬虫"],"content":"爬虫的矛与盾 反爬机制:门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取。 反反爬策略:爬虫程序可以通过制定相关的策略或者技术手段，破解]户网站中具备的反爬机制，从而可以获取门户网 ","date":"2020-03-20","objectID":"/2020-03-20-%E7%88%AC%E8%99%AB01/:0:4","tags":["python","爬虫"],"title":"爬虫流程及方法01(入门准备及Request库使用)","uri":"/2020-03-20-%E7%88%AC%E8%99%AB01/"},{"categories":["python","爬虫"],"content":"robots. txt协议:? 君子协议:规定了网站中哪些数据可以被爬虫爬取哪些数据不可以被爬取。 例如这个：https://www.bilibili.com/robots.txt 正文： ","date":"2020-03-20","objectID":"/2020-03-20-%E7%88%AC%E8%99%AB01/:0:5","tags":["python","爬虫"],"title":"爬虫流程及方法01(入门准备及Request库使用)","uri":"/2020-03-20-%E7%88%AC%E8%99%AB01/"},{"categories":["python","爬虫"],"content":" 软件：pycharm/thonny/自带IDLE,明白python的基本语法，缩进/字典/元组/列表/循环结构/函数运用/文件存储（绝对路径/相对路径） step1.安装第三方模块：调出cmd窗口输入以下字符 （每一行是一个包，等待下载完后再进行下一个包的下载） python -m pip install --upgrade pip pip install requests pip install bs4 pip install lxml pip install urllib step2.确认爬虫流程： 1.指定url\r2.请求前进行UA伪装（模拟游览器发出请求）\r3.选择post还是get请求\r4.请求发送\r5.获取响应数据\r6.进行存储\r step3.实际代码的编写： import requests #每使用一个包的方法就得导入一个包 #（引入包后空两行，语法的正确书写习惯） a = True while a: #这里可以改成循环结构对网页进行实时爬取，每次爬取覆盖上次的成果 url = \"网址\" #指定所爬取页面的网址 headers = { 'user-agent':'粘贴1处' } #在页面中点击右键选择检查，调出网页自带的抓包工具，在network中刷新当前页面抓包找到user-agent的项复制粘贴1，找到Query String Parameters的项复制粘贴2（记得加符号’粘贴2‘） params = { '某名字':'某值', '粘贴2':'黏贴2' } res = requests.get(url=url,params=params,headers=headers) #这里是对网页发起请求并内置参数 dict_object = res.text #对返回内容进行text处理并赋值给一个字典 with open(\"./lolichan.html\",\"w\",encoding='utf-8') as fp: #打开或生成一个文档并选定为写w的状态，转换字符的编码为utf-8 fp.write(dict_object)#往文档内存储爬取的网页源码 print('over') #存储成功提示 a = False step4.实际运用： 安装而未用到的包下次再讲，剩下的包用于数据的解析定位 如果想要看效果视频，参照B站视频av92683334 更多内容: 【官方文档】opencv-python中文文档 ","date":"2020-03-20","objectID":"/2020-03-20-%E7%88%AC%E8%99%AB01/:0:6","tags":["python","爬虫"],"title":"爬虫流程及方法01(入门准备及Request库使用)","uri":"/2020-03-20-%E7%88%AC%E8%99%AB01/"},{"categories":["python"],"content":"直接放代码 import os libs = { \"requests\",\"jieba\",\"beautifulsoup4\",\\ \"django\",\"flask\",\\ \"此处填写你需要下载的库的名称，注意大小写并拼写正确，样式如上面例子\",\"pandas\" } try: for lib in libs: os.system('pip install '+lib) print(\"Successful\") except: print('error') os.system(command) command 为要执行的命令，近似于Windows下cmd窗口中输入的命令。 ","date":"2020-03-15","objectID":"/2020-03-15-%E5%AE%89%E8%A3%85python%E5%BA%93%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/:0:1","tags":["python"],"title":"安装python第三方库的小技巧","uri":"/2020-03-15-%E5%AE%89%E8%A3%85python%E5%BA%93%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"categories":["博客建站相关"],"content":"本站用于本人的学习笔记展出，如果对您的学习有所帮助，欢迎关注我,给我私信，我能及时看到。 有时间我会转移Python博客回来，暂时先这么看着先把↓ 原Python学习笔记已经迁移至SpiritLHL’s Python blog，有需要的可以点击跳转查看。 更多学习资料欢迎访问Python123、CSDN论坛与吾爱破解论坛。 友链：萌新论坛。 欢迎请站长喝一杯 ","date":"2020-02-01","objectID":"/about/about/:0:0","tags":["hugo"],"title":"关于本站","uri":"/about/about/"},{"categories":["博客建站相关"],"content":"创建新文档 hugo new posts/名字.md 引用B站视频 注意 如果要绑定第三方域名给github-pages，每次更新博客都需要重新绑定！ ","date":"2019-01-01","objectID":"/first_post/:0:0","tags":["hugo"],"title":"本主题使用小技巧","uri":"/first_post/"}]